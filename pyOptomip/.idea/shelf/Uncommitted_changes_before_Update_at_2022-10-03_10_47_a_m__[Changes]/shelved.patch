Index: QontrolMotorPanel.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># The MIT License (MIT)\r\n\r\n# Copyright (c) 2015 Michael Caverley\r\n\r\n# Permission is hereby granted, free of charge, to any person obtaining a copy\r\n# of this software and associated documentation files (the \"Software\"), to deal\r\n# in the Software without restriction, including without limitation the rights\r\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n# copies of the Software, and to permit persons to whom the Software is\r\n# furnished to do so, subject to the following conditions:\r\n\r\n# The above copyright notice and this permission notice shall be included in\r\n# all copies or substantial portions of the Software.\r\n\r\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n# THE SOFTWARE.\r\nimport wx\r\n\r\n\r\n# Panel that appears in the main window which contains the controls for the Qontrol motors.\r\nclass topQontrolMotorPanel(wx.Panel):\r\n    def __init__(self, parent, motor):\r\n        super(topQontrolMotorPanel, self).__init__(parent)\r\n        self.qontrol = motor[0]\r\n        self.numAxes = self.qontrol.numAxes\r\n        self.maxAxis = self.numAxes + 1\r\n        self.InitUI()\r\n\r\n    def InitUI(self):\r\n        sb = wx.StaticBox(self, label='Qontrol')\r\n        vbox = wx.StaticBoxSizer(sb, wx.VERTICAL)\r\n\r\n        axis = 1\r\n        for motorCtrl in range(axis, self.maxAxis):\r\n            motorPanel = QontrolPanel(self, motorCtrl, axis)\r\n            motorPanel.motor = self.qontrol\r\n            vbox.Add(motorPanel, flag=wx.LEFT | wx.TOP | wx.ALIGN_LEFT, border=0, proportion=0)\r\n            vbox.Add((-1, 2))\r\n            sl = wx.StaticLine(self)\r\n            vbox.Add(sl, flag=wx.EXPAND, border=0, proportion=0)\r\n            vbox.Add((-1, 2))\r\n            axis = axis + 1\r\n\r\n        self.SetSizer(vbox)\r\n\r\n\r\nclass QontrolPanel(wx.Panel):\r\n\r\n    def __init__(self, parent, motorCtrl, axis):\r\n        super(QontrolPanel, self).__init__(parent)\r\n        self.parent = parent\r\n        self.motorCtrl = motorCtrl\r\n        self.axis = axis\r\n        self.InitUI()\r\n\r\n    def InitUI(self):\r\n\r\n        hbox = wx.BoxSizer(wx.HORIZONTAL)\r\n        st1 = wx.StaticText(self, label='Electrical Probing Control')\r\n        hbox.Add(st1, flag=wx.ALIGN_LEFT, border=8)\r\n        st1 = wx.StaticText(self, label='')\r\n        hbox.Add(st1, flag=wx.EXPAND, border=8, proportion=1)\r\n        btn1 = wx.Button(self, label='-', size=(20, 20))\r\n        hbox.Add(btn1, flag=wx.EXPAND | wx.RIGHT, proportion=0, border=8)\r\n        btn1.Bind(wx.EVT_BUTTON, self.OnButton_MinusButtonHandler)\r\n\r\n        self.tc = wx.TextCtrl(self, value=str(self.axis))  # change str(self.axis) to '0'\r\n        hbox.Add(self.tc, proportion=2, flag=wx.EXPAND)\r\n\r\n        st1 = wx.StaticText(self, label='um')\r\n        hbox.Add(st1, flag=wx.ALIGN_LEFT, border=8)\r\n\r\n        btn2 = wx.Button(self, label='+', size=(20, 20))\r\n        hbox.Add(btn2, proportion=0, flag=wx.EXPAND | wx.LEFT | wx.RIGHT, border=8)\r\n        btn2.Bind(wx.EVT_BUTTON, self.OnButton_PlusButtonHandler)\r\n        self.SetSizer(hbox);\r\n\r\n    def getMoveValue(self):\r\n        try:\r\n            val = float(self.tc.GetValue())\r\n        except ValueError:\r\n            self.tc.SetValue('0')\r\n            return 0.0\r\n        return val\r\n\r\n    def OnButton_MinusButtonHandler(self, event):\r\n\r\n        if self.axis == 1:\r\n            current_position = self.parent.qontrol.q.x[0]\r\n            self.parent.qontrol.q.x[0] = (-1 * (current_position+self.getMoveValue()))\r\n            print(\"Axis 1 Moved\")\r\n\r\n        if self.axis == 2:\r\n            current_position = self.parent.qontrol.q.x[1]\r\n            self.parent.qontrol.q.x[1] = (-1 * (current_position + self.getMoveValue()))\r\n            print(\"Axis 2 Moved\")\r\n\r\n        if self.axis == 3:\r\n            current_position = self.parent.qontrol.q.x[2]\r\n            self.parent.qontrol.q.x[2] = (-1 * (current_position + self.getMoveValue()))\r\n            print(\"Axis 3 Moved\")\r\n\r\n    def OnButton_PlusButtonHandler(self, event):\r\n\r\n        if self.axis == 1:\r\n            current_position = self.parent.qontrol.q.x[0]\r\n            self.parent.qontrol.q.x[0] = (current_position + self.getMoveValue())\r\n            print(\"Axis 1 Moved\")\r\n        if self.axis == 2:\r\n            current_position = self.parent.qontrol.q.x[1]\r\n            self.parent.qontrol.q.x[1] = (current_position + self.getMoveValue())\r\n            print(\"Axis 2 Moved\")\r\n        if self.axis == 3:\r\n            current_position = self.parent.qontrol.q.x[2]\r\n            self.parent.qontrol.q.x[2] = (current_position + self.getMoveValue())\r\n            print(\"Axis 3 Moved\")\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/QontrolMotorPanel.py b/QontrolMotorPanel.py
--- a/QontrolMotorPanel.py	(revision abd26e7fa73a137f488f4dfbf10def44bc04de2c)
+++ b/QontrolMotorPanel.py	(date 1663711070675)
@@ -26,7 +26,7 @@
 class topQontrolMotorPanel(wx.Panel):
     def __init__(self, parent, motor):
         super(topQontrolMotorPanel, self).__init__(parent)
-        self.qontrol = motor[0]
+        self.qontrol = motor
         self.numAxes = self.qontrol.numAxes
         self.maxAxis = self.numAxes + 1
         self.InitUI()
@@ -85,37 +85,57 @@
             val = float(self.tc.GetValue())
         except ValueError:
             self.tc.SetValue('0')
+            print("Value Error")
             return 0.0
+        print(val)
         return val
 
     def OnButton_MinusButtonHandler(self, event):
 
         if self.axis == 1:
             current_position = self.parent.qontrol.q.x[0]
-            self.parent.qontrol.q.x[0] = (-1 * (current_position+self.getMoveValue()))
+            print(current_position)
+            self.parent.qontrol.q.x[0] = current_position-self.getMoveValue()
+            current_position = self.parent.qontrol.q.x[0]
+            print(current_position)
             print("Axis 1 Moved")
 
         if self.axis == 2:
             current_position = self.parent.qontrol.q.x[1]
-            self.parent.qontrol.q.x[1] = (-1 * (current_position + self.getMoveValue()))
+            print(current_position)
+            self.parent.qontrol.q.x[1] = current_position - self.getMoveValue()
+            current_position = self.parent.qontrol.q.x[1]
+            print(current_position)
             print("Axis 2 Moved")
 
         if self.axis == 3:
             current_position = self.parent.qontrol.q.x[2]
-            self.parent.qontrol.q.x[2] = (-1 * (current_position + self.getMoveValue()))
+            self.parent.qontrol.q.x[2] = current_position - self.getMoveValue()
+            print("Axis 3 Moved")
+            current_position = self.parent.qontrol.q.x[2]
+            print(current_position)
             print("Axis 3 Moved")
 
     def OnButton_PlusButtonHandler(self, event):
 
         if self.axis == 1:
             current_position = self.parent.qontrol.q.x[0]
+            print(current_position)
             self.parent.qontrol.q.x[0] = (current_position + self.getMoveValue())
+            current_position = self.parent.qontrol.q.x[0]
+            print(current_position)
             print("Axis 1 Moved")
         if self.axis == 2:
             current_position = self.parent.qontrol.q.x[1]
+            print(current_position)
             self.parent.qontrol.q.x[1] = (current_position + self.getMoveValue())
+            current_position = self.parent.qontrol.q.x[1]
+            print(current_position)
             print("Axis 2 Moved")
         if self.axis == 3:
             current_position = self.parent.qontrol.q.x[2]
             self.parent.qontrol.q.x[2] = (current_position + self.getMoveValue())
             print("Axis 3 Moved")
+            current_position = self.parent.qontrol.q.x[2]
+            print(current_position)
+            print("Axis 3 Moved")
Index: hp816x_N77Det_instr.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># The MIT License (MIT)\r\n\r\n# Copyright (c) 2015 Michael Caverley\r\n\r\n# Permission is hereby granted, free of charge, to any person obtaining a copy\r\n# of this software and associated documentation files (the \"Software\"), to deal\r\n# in the Software without restriction, including without limitation the rights\r\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n# copies of the Software, and to permit persons to whom the Software is\r\n# furnished to do so, subject to the following conditions:\r\n\r\n# The above copyright notice and this permission notice shall be included in\r\n# all copies or substantial portions of the Software.\r\n\r\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n# THE SOFTWARE.\r\n\r\nfrom ctypes import *\r\nimport numpy as np;\r\nfrom itertools import repeat;\r\nimport hp816x_instr\r\nimport math;\r\n\r\n\r\nclass hp816x_N77Det(hp816x_instr.hp816x):\r\n    name = 'hp816x N77 Detector'\r\n    numPWMSlots = 5\r\n    maxPWMPoints = 100000\r\n    isDetect = True\r\n    isSMU = False\r\n\r\n    def connect(self, visaAddr, n77DetAddr, reset=0, forceTrans=1, autoErrorCheck=1):\r\n        super(hp816x_N77Det, self).connect(visaAddr, reset, forceTrans, autoErrorCheck)\r\n\r\n        self.hN77Det = c_int32()\r\n\r\n        queryID = 1  # The instrument ignores this value.\r\n        res = self.hp816x_init(n77DetAddr.encode('utf-8'), queryID, reset, byref(self.hN77Det))\r\n        self.checkErrorN77(res)\r\n        self.registerMainframe(self.hN77Det)\r\n        self.N77SlotInfo = self.getN77SlotInfo()  # Keep mainframe slot info\r\n        self.pwmSlotIndex, self.pwmSlotMap = self.enumerateN77PWMSlots()\r\n        self.activeSlotIndex = self.pwmSlotIndex\r\n        return\r\n\r\n    def disconnect(self):\r\n        super(hp816x_N77Det, self).disconnect()\r\n        self.unregisterMainframe(self.hN77Det)\r\n\r\n        res = self.hp816x_close(self.hN77Det)\r\n        self.checkErrorN77(res)\r\n\r\n    def getN77SlotInfo(self):\r\n        slotInfoArr = (c_int32 * self.numPWMSlots)()\r\n        slotInfoArrPtr = cast(slotInfoArr, POINTER(c_int32))\r\n        res = self.hp816x_getSlotInformation_Q(self.hN77Det, self.numPWMSlots, slotInfoArrPtr)\r\n        self.checkErrorN77(res)\r\n        return slotInfoArrPtr[:self.numPWMSlots]\r\n\r\n    def enumerateN77PWMSlots(self):\r\n        pwmSlotIndex = list()\r\n        pwmSlotMap = list()\r\n        ii = 1\r\n        for slot in self.N77SlotInfo:\r\n            if slot == self.hp816x_SINGLE_SENSOR:\r\n                pwmSlotIndex.append(ii)\r\n                pwmSlotMap.append((ii, 0))\r\n                ii += 1\r\n            elif slot == self.hp816x_DUAL_SENSOR:\r\n                pwmSlotIndex.append(ii)\r\n                pwmSlotMap.append((ii, 0))\r\n                ii += 1\r\n                pwmSlotIndex.append(ii)\r\n                pwmSlotMap.append((ii, 1))\r\n                ii += 1\r\n        return (pwmSlotIndex, pwmSlotMap)\r\n\r\n    def getNumSweepChannels(self):\r\n        return len(self.pwmSlotIndex)\r\n\r\n    def setRangeParams(self, chan, initialRange, rangeDecrement, reset=0):\r\n        res = self.hp816x_setInitialRangeParams(self.hN77Det, chan, reset, initialRange, rangeDecrement)\r\n        self.checkErrorN77(res)\r\n        return\r\n\r\n    def setPWMPowerUnit(self, slot, chan, unit):\r\n        res = self.hp816x_set_PWM_powerUnit(self.hN77Det, slot, chan, self.sweepUnitDict[unit])\r\n        self.checkErrorN77(res)\r\n\r\n    def setPWMPowerRange(self, slot, chan, rangeMode='auto', range=0):\r\n        res = self.hp816x_set_PWM_powerRange(self.hN77Det, slot, chan, self.rangeModeDict[rangeMode], range)\r\n        self.checkErrorN77(res)\r\n\r\n    def checkInstrumentErrorN77(self):\r\n        \"\"\" Reads error messages from the instrument\"\"\"\r\n        ERROR_MSG_BUFFER_SIZE = 256\r\n        instErr = c_int32()\r\n        c_errMsg = (c_char * ERROR_MSG_BUFFER_SIZE)()\r\n        c_errMsgPtr = cast(c_errMsg, c_char_p)\r\n        self.hp816x_error_query(self.hN77Det, byref(instErr), c_errMsgPtr)\r\n        return instErr.value, c_errMsg.value\r\n\r\n    def checkErrorN77(self, errStatus):\r\n        ERROR_MSG_BUFFER_SIZE = 256\r\n        if errStatus < self.hp816x_SUCCESS:\r\n            if errStatus == self.hp816x_INSTR_ERROR_DETECTED:\r\n                instErr, instErrMsg = self.checkInstrumentError()\r\n                raise InstrumentError('Error ' + str(instErr) + ': ' + instErrMsg)\r\n            else:\r\n                c_errMsg = (c_char * ERROR_MSG_BUFFER_SIZE)()\r\n                c_errMsgPtr = cast(c_errMsg, c_char_p)\r\n\r\n                self.hp816x_error_message(self.hN77Det, errStatus, c_errMsgPtr)\r\n                raise InstrumentError(c_errMsg.value)\r\n        return 0\r\n\r\n    def getLambdaScanResult(self, chan, useClipping, clipLimit, numPts):\r\n        wavelengthArr = np.zeros(int(numPts))\r\n        powerArr = np.zeros(int(numPts))\r\n        res = self.hp816x_getLambdaScanResult(self.hN77Det, chan, useClipping, clipLimit, powerArr, wavelengthArr)\r\n        self.checkErrorN77(res)\r\n        return wavelengthArr, powerArr\r\n\r\n    def readPWM(self, slot, chan):\r\n        \"\"\" read a single wavelength \"\"\"\r\n        powerVal = c_double()\r\n        res = self.hp816x_PWM_readValue(self.hN77Det, slot, chan, byref(powerVal))\r\n        # Check for out of range error\r\n        if res == self.hp816x_INSTR_ERROR_DETECTED:\r\n            instErr, instErrMsg = self.checkInstrumentError()\r\n            if instErr == -231 or instErr == -261:\r\n                return self.sweepClipLimit  # Assumes unit is in dB\r\n            else:\r\n                raise InstrumentError('Error ' + str(instErr) + ': ' + instErrMsg)\r\n        self.checkError(res)\r\n        return float(powerVal.value)\r\n\r\n    def sweep(self):\r\n        \"\"\" Performs a wavelength sweep \"\"\"\r\n\r\n        # Convert values from string representation to integers for the driver\r\n        unitNum = self.sweepUnitDict[self.sweepUnit]\r\n        outputNum = self.laserOutputDict[self.sweepLaserOutput]\r\n        numScans = self.sweepNumScansDict[self.sweepNumScans]\r\n        numChan = len(self.pwmSlotIndex)\r\n        numActiveChan = len(self.activeSlotIndex)  # Number of active channels\r\n\r\n        # Total number of points in sweep\r\n        numTotalPoints = int(round((self.sweepStopWvl - self.sweepStartWvl) / self.sweepStepWvl + 1))\r\n\r\n        # The laser reserves 100 pm of spectrum which takes away from the maximum number of datapoints per scan\r\n        # Also, we will reserve another 100 datapoints as an extra buffer.\r\n        # maxPWMPointsTrunc = int(round(self.maxPWMPoints-100e-12/self.sweepStepWvl-1));\r\n        maxPWMPointsTrunc = int(round(self.maxPWMPoints - math.ceil(100e-12 / self.sweepStepWvl))) - 100\r\n        numFullScans = int(numTotalPoints // maxPWMPointsTrunc)\r\n        numRemainingPts = numTotalPoints % maxPWMPointsTrunc\r\n\r\n        stitchNumber = numFullScans + 1\r\n\r\n        print('Total number of datapoints: %d' % numTotalPoints)\r\n        print('Stitch number: %d' % stitchNumber)\r\n\r\n        # Create a list of the number of points per stitch\r\n        numPointsLst = list()\r\n\r\n        for x in repeat(maxPWMPointsTrunc, numFullScans):\r\n            numPointsLst.append(int(x))\r\n\r\n        numPointsLst.append(int(round(numRemainingPts)))\r\n\r\n        startWvlLst = list()\r\n        stopWvlLst = list()\r\n\r\n        # Create a list of the start and stop wavelengths per stitch\r\n        pointsAccum = 0\r\n        for points in numPointsLst:\r\n            startWvlLst.append(self.sweepStartWvl + pointsAccum * self.sweepStepWvl)\r\n            stopWvlLst.append(self.sweepStartWvl + (pointsAccum + points - 1) * self.sweepStepWvl)\r\n            pointsAccum += points\r\n\r\n        # Set sweep speed\r\n        self.setSweepSpeed(self.sweepSpeed)\r\n\r\n        wavelengthArrPWM = np.zeros(int(numTotalPoints))\r\n        powerArrPWM = np.zeros((int(numTotalPoints), numActiveChan))\r\n\r\n        pointsAccum = 0\r\n        # Loop over all the stitches\r\n        for points, startWvl, stopWvl in zip(numPointsLst, startWvlLst, stopWvlLst):\r\n            print('Sweeping from %g nm to %g nm' % (startWvl * 1e9, stopWvl * 1e9))\r\n            # If the start or end wavelength is not a multiple of 1 pm, the laser will sometimes choose the wrong start\r\n            # or end wavelength for doing the sweep. To fix this, we will set the sweep start wavelength to the \r\n            # nearest multiple of 1 pm below the start wavelength and the nearest multiple above the end wavelength.\r\n            # After the sweep is completed, the desired wavelength range is extracted from the results.\r\n            startWvlAdjusted = startWvl\r\n            stopWvlAdjusted = stopWvl\r\n            if startWvl * 1e12 - int(startWvl * 1e12) > 0:\r\n                startWvlAdjusted = math.floor(startWvl * 1e12) / 1e12\r\n            if stopWvl * 1e12 - int(stopWvl * 1e12) > 0:\r\n                stopWvlAdjusted = math.ceil(stopWvl * 1e12) / 1e12\r\n\r\n            # Format the start and dtop wvl to 13 digits of accuracy (otherwise the driver will sweep the wrong range)\r\n            startWvlAdjusted = float('%.13f' % (startWvlAdjusted))\r\n            stopWvlAdjusted = float('%.13f' % (stopWvlAdjusted))\r\n\r\n            c_numPts = c_uint32()\r\n            c_numChanRet = c_uint32()\r\n            res = self.hp816x_prepareMfLambdaScan(self.hDriver, unitNum, self.sweepPower, outputNum, numScans, numChan, \\\r\n                                                  startWvlAdjusted, stopWvlAdjusted, self.sweepStepWvl, byref(c_numPts),\r\n                                                  byref(c_numChanRet));\r\n\r\n            self.checkError(res)\r\n            numPts = int(c_numPts.value)\r\n\r\n            # Set range params\r\n            for ii in self.activeSlotIndex:\r\n                self.setRangeParams(ii, self.sweepInitialRange, self.sweepRangeDecrement)\r\n\r\n            # This value is unused since getLambdaScanResult returns the wavelength anyways\r\n            c_wavelengthArr = (c_double * int(numPts))()\r\n            c_wavelengthArrPtr = cast(c_wavelengthArr, POINTER(c_double))\r\n\r\n            # Perform the sweep\r\n            res = self.hp816x_executeMfLambdaScan(self.hDriver, c_wavelengthArrPtr)\r\n            self.checkError(res)\r\n\r\n            wavelengthArrTemp = np.zeros(int(numPts))\r\n            for zeroIdx, chanIdx in enumerate(self.activeSlotIndex):\r\n                # zeroIdx is the index starting from zero which is used to add the values to the power array\r\n                # chanIdx is the channel index used by the mainframe\r\n                # Get power values and wavelength values from the laser/detector\r\n                wavelengthArrTemp, powerArrTemp = self.getLambdaScanResult(chanIdx, self.sweepUseClipping,\r\n                                                                           self.sweepClipLimit, numPts)\r\n                # The driver sometimes doesn't return the correct starting wavelength for a sweep\r\n                # We will search the returned wavelength results to see the index at which\r\n                # the deired wavelength starts at, and take values starting from there\r\n                wavelengthStartIdx = self.findClosestValIdx(wavelengthArrTemp, startWvl)\r\n                wavelengthStopIdx = self.findClosestValIdx(wavelengthArrTemp, stopWvl)\r\n                wavelengthArrTemp = wavelengthArrTemp[wavelengthStartIdx:wavelengthStopIdx + 1]\r\n                powerArrTemp = powerArrTemp[wavelengthStartIdx:wavelengthStopIdx + 1]\r\n                powerArrPWM[pointsAccum:pointsAccum + points, zeroIdx] = powerArrTemp\r\n            wavelengthArrPWM[pointsAccum:pointsAccum + points] = wavelengthArrTemp\r\n            pointsAccum += points\r\n\r\n        return wavelengthArrPWM, powerArrPWM\r\n\r\n\r\nclass InstrumentError(Exception):\r\n    pass\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hp816x_N77Det_instr.py b/hp816x_N77Det_instr.py
--- a/hp816x_N77Det_instr.py	(revision abd26e7fa73a137f488f4dfbf10def44bc04de2c)
+++ b/hp816x_N77Det_instr.py	(date 1663700690103)
@@ -33,6 +33,7 @@
     maxPWMPoints = 100000
     isDetect = True
     isSMU = False
+    isQontrol = False
 
     def connect(self, visaAddr, n77DetAddr, reset=0, forceTrans=1, autoErrorCheck=1):
         super(hp816x_N77Det, self).connect(visaAddr, reset, forceTrans, autoErrorCheck)
Index: CorvusEco.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># The MIT License (MIT)\r\n\r\n# Copyright (c) 2015 Michael Caverley\r\n\r\n# Permission is hereby granted, free of charge, to any person obtaining a copy\r\n# of this software and associated documentation files (the \"Software\"), to deal\r\n# in the Software without restriction, including without limitation the rights\r\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n# copies of the Software, and to permit persons to whom the Software is\r\n# furnished to do so, subject to the following conditions:\r\n\r\n# The above copyright notice and this permission notice shall be included in\r\n# all copies or substantial portions of the Software.\r\n\r\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n# THE SOFTWARE.\r\n\r\n\"\"\"\r\nCreated on Mon Jun 02 10:01:33 2014\r\n\r\n@author: Stephen Lin\r\nLast updated: July 15, 2014\r\n\"\"\"\r\n#MAIN ISSUES\r\n#The Corvus does not return any errors for many things:\r\n#e.g.: If an axis is not connected but is enabled through the code, everything will still proceed\r\n#however, NONE of any of the axis will move when given the commmand (making it impossible to tell you which axis is not working)\r\n#Corvus will tell you there is an internal error, but it does not give ANY details.\r\n\r\n\r\nimport time\r\nimport pyvisa as visa\r\n\r\nclass CorvusEcoClass():\r\n    NumberOfAxis = 3 #default the axis number @ 3 just in case.\r\n    name = 'CorvusEco'\r\n    isSMU = False\r\n    isMotor = True\r\n    isOpt = True\r\n    isElec = False\r\n    isLaser = False\r\n    isQontrol = False\r\n    isDetect = False\r\n    def connect(self,visaName,rm,Velocity,Acceleration,NumberOfAxis):\r\n        self.ser = rm.get_instrument(visaName) #Connects to device with pyVisa\r\n        self.ser.baud_rate = 57600 # Sets baudrate\r\n        self.ser.write('identify') #Asks for identification\r\n        print((self.ser.read()+ ' [Model Name][Hardware Ver][Software Ver][Internal Use][Dip-Switch]'))\r\n        print('Connected\\n')\r\n        \r\n        #Sets minimum # of axis to send commands to\r\n        try:\r\n            self.ser.write('%d setdim'%(NumberOfAxis))\r\n            if NumberOfAxis >= 1:\r\n                self.ser.write('1 1 setaxis')\r\n                print('Axis 1 Enabled.')\r\n            if NumberOfAxis >= 2:\r\n                self.ser.write('1 2 setaxis')\r\n                print('Axis 2 Enabled.')\r\n            else:\r\n                self.ser.write('0 2 setaxis')\r\n            if NumberOfAxis >= 3:\r\n                self.ser.write('1 3 setaxis')\r\n                print('Axis 3 Enabled.')\r\n            else:\r\n                self.ser.write('0 3 setaxis')\r\n            self.NumberOfAxis = NumberOfAxis\r\n        except:\r\n            self.showErr()\r\n\r\n\r\n        #Sets units to um (microns)\r\n        self.ser.write('1 0 setunit') #Virtual Axis\r\n        self.ser.write('1 1 setunit') #Axis 1\r\n        self.ser.write('1 2 setunit') #Axis 2\r\n        self.ser.write('1 3 setunit') #Axis 3\r\n        print ('Units are set to: Microns(um)\\n')\r\n        \r\n\r\n        #Set Acceleration Function\r\n        self.ser.write('0 setaccelfunc') #Sets acceleration for long travel distances, probably dont need, 0 means no accel\r\n        \r\n        #Set output port\r\n        self.ser.write('1 setout') #Sets digital output, 1 means Dout1 = on, Dout2=OFF, Dout3=OFF\r\n        \r\n        #set trigger out\r\n        self.ser.write('10 0 1 ot')#Out Trigger: [time][polarity][output]\r\n        #time in range of 1-1000 in ms (integer)\r\n        #polarity in range of 0 or 1\r\n        #output in range of 1, 2 or 3\r\n        self.setcloop(1)\r\n        \r\n    def disconnect(self):\r\n        self.ser.close()\r\n        print ('Corvus Eco Disconnected')\r\n        \r\n\r\n    #Units: (Unit/s) use setunit command   \r\n    def setVelocity(self,velocity):\r\n        self.ser.write(str(velocity)+' sv') #set velocity\r\n        self.ser.write('gv') #Get Velocity\r\n        response = self.ser.read()\r\n        print(('Velocity set to: '+response+' [units]/s\\n'))\r\n        \r\n    #Units: (Unit/s^2) use setunit command            \r\n    def setAcceleration(self,Acceleration):\r\n        self.ser.write(str(Acceleration)+' sa') #Set Acceleration\r\n        self.ser.write('ga')#Get Acceleration\r\n        response = self.ser.read()\r\n        print(('Acceleration set to: '+response+' [units]/s^2\\n'))\r\n    \r\n    #Closed Loop ----------------------------\r\n    def setcloop(self,toggle):\r\n        #0 = off\r\n        #1 = on\r\n        try:\r\n            self.ser.write('%d 1 setcloop' %(toggle))\r\n            self.ser.write('%d 2 setcloop' %(toggle))\r\n            self.ser.write('%d 3 setcloop' %(toggle))\r\n            if toggle == 0:\r\n                print ('Close Loop Disabled for All Axis.')\r\n            if toggle == 1:\r\n                print ('Close Loop Enabled for All Axis.')\r\n        except:\r\n            self.showErr()\r\n\r\n    #set scale type\r\n    def setscaletype(self,stype):\r\n    #value of 0 or 1\r\n    # 0 = Analog\r\n    # 1 = digital\r\n        try:\r\n            self.ser.write('%d 1 setscaletype'%(stype))\r\n            self.ser.write('%d 2 setscaletype'%(stype))\r\n            self.ser.write('%d 3 setscaletype'%(stype))\r\n            if stype == 0:\r\n                print ('Scale Type set to Analog for All Axis')\r\n            if stype == 1:\r\n                print ('Scale Type set to Digital for All Axis')\r\n        except:\r\n            self.showErr()\r\n                \r\n    def setclperiod(self,direction,distance):\r\n        #+ or - for direction\r\n        #distance in microns, value from 0.0000001 to 1.999999\r\n            \r\n        microndistance = distance/1000\r\n            \r\n        try:\r\n            self.ser.write('%s %d 1 setclperiod'%(direction,microndistance))\r\n            self.ser.write('%s %d 2 setclperiod'%(direction,microndistance))\r\n            self.ser.write('%s %d 3 setclperiod'%(direction,microndistance))\r\n            print('Clperiod Set Successfully')\r\n        except:\r\n            self.showErr()\r\n            \r\n            \r\n    def setnselpos(self,pos):\r\n    #pos: 0 or 1\r\n    # 0 returns the calculated position\r\n    # 1 returns the measured position\r\n            \r\n        try:\r\n            self.ser.write('%d 1 setnselpos'%(pos))\r\n            self.ser.write('%d 2 setnselpos'%(pos))\r\n            self.ser.write('%d 3 setnselpos'%(pos))\r\n            print ('Complete')\r\n            #NOTE: Try doing this with axis disabled and see if the function still works\r\n            #should still work even if axis disabled.\r\n        except:\r\n            self.showErr()\r\n            \r\n    #sets the unit for all axis\r\n    #0 = microstep\r\n    #1 = micron\r\n    #2 = millimeters\r\n    #3 = centimeters\r\n    #4 = meters\r\n    #5 = inches\r\n    #6 = mil (1/1000 inch)\r\n    def setunit(self,unit):\r\n        self.ser.write('%d 0 setunit'%(unit))\r\n        self.ser.write('%d 1 setunit'%(unit))\r\n        self.ser.write('%d 2 setunit'%(unit))\r\n        self.ser.write('%d 3 setunit'%(unit))\r\n        print ('Units set successfully.')\r\n        \r\n    #Checks the currently set units\r\n    #0 = microstep\r\n    #1 = micron\r\n    #2 = millimeters\r\n    #3 = centimeters\r\n    #4 = meters\r\n    #5 = inches\r\n    #6 = mil (1/1000 inch)\r\n    def getunit(self,axis):\r\n        self.ser.write('%d getunit'%(axis))\r\n        value = self.ser.read()\r\n        print(('Axis %d is set to unitvalue: %s'%(axis,value)))\r\n            \r\n#=======Movement functions============\r\n    def moveX(self,distance):\r\n        if self.NumberOfAxis == 1:       \r\n            try:\r\n                self.ser.write(str(distance)+' r')\r\n                #print ('Move Complete')\r\n            except:\r\n                print('An Error has occured')\r\n                self.showErr()\r\n                \r\n        if self.NumberOfAxis == 2:\r\n            try:\r\n                self.ser.write(str(distance)+' 0 r')\r\n                #print ('Move Complete')\r\n            except:\r\n                print('An Error has occured')\r\n                self.showErr()\r\n                \r\n        if self.NumberOfAxis == 3:\r\n            try:\r\n                self.ser.write(str(distance)+' 0 0 r')\r\n                #print ('Move Complete')\r\n            except:\r\n                print('An Error has occured')\r\n                self.showErr()\r\n\r\n    def moveY(self,distance):\r\n        if self.NumberOfAxis == 1:       \r\n            print ('Error: Axis 2 Not Enabled.')\r\n                \r\n        if self.NumberOfAxis == 2:\r\n            try:\r\n                self.ser.write('0 '+str(distance)+' r')\r\n                #print ('Move Complete')\r\n            except:\r\n                print('An Error has occured')\r\n                self.showErr()\r\n                \r\n        if self.NumberOfAxis == 3:\r\n            try:\r\n                self.ser.write('0 '+str(distance)+' 0 r')\r\n                #print ('Move Complete')\r\n            except:\r\n                print('An Error has occured')\r\n                self.showErr()\r\n            \r\n    def moveZ(self,distance):\r\n        if self.NumberOfAxis == 1:       \r\n            print ('Error: Axis 3 Not Enabled.')\r\n                \r\n        if self.NumberOfAxis == 2:\r\n            print ('Error: Axis 3 Not Enabled.')\r\n                \r\n        if self.NumberOfAxis == 3:\r\n            try:\r\n                self.ser.write('0 0 '+str(distance)+' r')\r\n                #print ('Move Complete')\r\n            except:\r\n                print('An Error has occured')\r\n                self.showErr()\r\n                \r\n    #Moves all the axis together\r\n    #can be used regardless of how many axis are enabled\r\n    def moveRelative(self,x,y=0,z=0):\r\n        if self.NumberOfAxis == 1:       \r\n            try:\r\n                self.ser.write('%.6f r'%(x))\r\n                #print ('Move Complete')\r\n            except:\r\n                print('An Error has occured')\r\n                self.showErr()\r\n                \r\n        if self.NumberOfAxis == 2:\r\n            try:\r\n                self.ser.write('%.6f %.6f r'%(x,y))\r\n                #print ('Move Complete')\r\n            except:\r\n                print('An Error has occured')\r\n                self.showErr()\r\n                \r\n        if self.NumberOfAxis == 3:\r\n            try:\r\n                self.ser.write('%.6f %.6f %.6f r'%(x,y,z))\r\n                #print ('Move Complete')\r\n            except:\r\n                print('An Error has occured')\r\n                self.showErr()\r\n        self.waitMoveComplete()\r\n        \r\n        \r\n    def moveAbsoluteXYZ(self,x,y,z):\r\n        xCurrentPos = self.getPosition()[0];\r\n        yCurrentPos = self.getPosition()[1];\r\n        zCurrentPos = self.getPosition()[2];\r\n        self.moveRelative(x-xCurrentPos, y-yCurrentPos, z-zCurrentPos)\r\n    \r\n    def waitMoveComplete(self):\r\n        while int(self.ser.ask('st')) & 1:\r\n            time.sleep(0.001)\r\n                \r\n    #Absolute MOve\r\n    #Has a possible range of +/- 16383mm\r\n    #units are the ones defined to the axis (should be microns)\r\n    \r\n    #From manual: The move profile is calculated in respect to the velocity/acceleration\r\n    #setup and the given hard or software limits. The axes are linear interpolated, \r\n    #this causes the controller to start and stop all active axes simultaneously\r\n#    def moveAbsolute(self,x,y=0,z=0):\r\n#        if self.NumberOfAxis == 1:       \r\n#            try:\r\n#                self.ser.write('%d m'%(x))\r\n#                print ('Move Complete')\r\n#            except:\r\n#                print('An Error has occured')\r\n#                self.showErr()\r\n#                \r\n#        if self.NumberOfAxis == 2:\r\n#            try:\r\n#                self.ser.write('%d %d m'%(x,y))\r\n#                print ('Move Complete')\r\n#            except:\r\n#                print('An Error has occured')\r\n#                self.showErr()\r\n#                \r\n#        if self.NumberOfAxis == 3:\r\n#            try:\r\n#                self.ser.write('%d %d %d m'%(x,y,z))\r\n#                print ('Move Complete')\r\n#            except:\r\n#                print('An Error has occured')\r\n#                self.showErr()\r\n                \r\n    def getPosition(self):\r\n        try:\r\n            self.ser.write('pos')\r\n            motorPosStr = self.ser.read()\r\n            res = list(map(float, motorPosStr.strip().split()))\r\n        except Exception as e:\r\n            print(e)\r\n            print(motorPosStr)\r\n            print('An Error has occured')\r\n            self.showErr()\r\n        return res\r\n                         \r\n    def clear(self): #Should clear any lingering messages in the device\r\n        try:\r\n            self.ser.write('clear')#Clears the parameter stack, refer to page 287 in manual for more detail\r\n        except:\r\n            self.showErr()\r\n            \r\n    def reset(self):#Resets the whole device, equivalent of disconnecting the power according to the manual\r\n    #a beep should be heard after the device is reset\r\n        try:\r\n            self.ser.write('reset')\r\n        except:\r\n            self.showErr()\r\n        \r\n    def showErr(self):\r\n        self.ser.write('ge') #Returns error and clears the error stack, Errors are given as codes which are listen in them manual\r\n        error = str('Error Code: '+self.ser.read()+' (Refer to Manual Page 165)')\r\n        raise Exception(error)\r\n               \r\n        
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CorvusEco.py b/CorvusEco.py
--- a/CorvusEco.py	(revision abd26e7fa73a137f488f4dfbf10def44bc04de2c)
+++ b/CorvusEco.py	(date 1663700690071)
@@ -26,18 +26,19 @@
 @author: Stephen Lin
 Last updated: July 15, 2014
 """
-#MAIN ISSUES
-#The Corvus does not return any errors for many things:
-#e.g.: If an axis is not connected but is enabled through the code, everything will still proceed
-#however, NONE of any of the axis will move when given the commmand (making it impossible to tell you which axis is not working)
-#Corvus will tell you there is an internal error, but it does not give ANY details.
+# MAIN ISSUES
+# The Corvus does not return any errors for many things:
+# e.g.: If an axis is not connected but is enabled through the code, everything will still proceed
+# however, NONE of any of the axis will move when given the commmand (making it impossible to tell you which axis is not working)
+# Corvus will tell you there is an internal error, but it does not give ANY details.
 
 
 import time
 import pyvisa as visa
 
-class CorvusEcoClass():
-    NumberOfAxis = 3 #default the axis number @ 3 just in case.
+
+class CorvusEcoClass:
+    NumberOfAxis = 3  # default the axis number @ 3 just in case.
     name = 'CorvusEco'
     isSMU = False
     isMotor = True
@@ -46,16 +47,26 @@
     isLaser = False
     isQontrol = False
     isDetect = False
-    def connect(self,visaName,rm,Velocity,Acceleration,NumberOfAxis):
-        self.ser = rm.get_instrument(visaName) #Connects to device with pyVisa
-        self.ser.baud_rate = 57600 # Sets baudrate
-        self.ser.write('identify') #Asks for identification
-        print((self.ser.read()+ ' [Model Name][Hardware Ver][Software Ver][Internal Use][Dip-Switch]'))
+
+    def connect(self, visaName, rm, Velocity, Acceleration, NumberOfAxis):
+        """
+
+        Args:
+            visaName: visa address of the corvus
+            rm:
+            Velocity:
+            Acceleration:
+            NumberOfAxis:
+        """
+        self.ser = rm.get_instrument(visaName)  # Connects to device with pyVisa
+        self.ser.baud_rate = 57600  # Sets baudrate
+        self.ser.write('identify')  # Asks for identification
+        print((self.ser.read() + ' [Model Name][Hardware Ver][Software Ver][Internal Use][Dip-Switch]'))
         print('Connected\n')
-        
-        #Sets minimum # of axis to send commands to
+
+        # Sets minimum # of axis to send commands to
         try:
-            self.ser.write('%d setdim'%(NumberOfAxis))
+            self.ser.write('%d setdim' % (NumberOfAxis))
             if NumberOfAxis >= 1:
                 self.ser.write('1 1 setaxis')
                 print('Axis 1 Enabled.')
@@ -73,268 +84,265 @@
         except:
             self.showErr()
 
-
-        #Sets units to um (microns)
-        self.ser.write('1 0 setunit') #Virtual Axis
-        self.ser.write('1 1 setunit') #Axis 1
-        self.ser.write('1 2 setunit') #Axis 2
-        self.ser.write('1 3 setunit') #Axis 3
-        print ('Units are set to: Microns(um)\n')
-        
+        # Sets units to um (microns)
+        self.ser.write('1 0 setunit')  # Virtual Axis
+        self.ser.write('1 1 setunit')  # Axis 1
+        self.ser.write('1 2 setunit')  # Axis 2
+        self.ser.write('1 3 setunit')  # Axis 3
+        print('Units are set to: Microns(um)\n')
 
-        #Set Acceleration Function
-        self.ser.write('0 setaccelfunc') #Sets acceleration for long travel distances, probably dont need, 0 means no accel
-        
-        #Set output port
-        self.ser.write('1 setout') #Sets digital output, 1 means Dout1 = on, Dout2=OFF, Dout3=OFF
-        
-        #set trigger out
-        self.ser.write('10 0 1 ot')#Out Trigger: [time][polarity][output]
-        #time in range of 1-1000 in ms (integer)
-        #polarity in range of 0 or 1
-        #output in range of 1, 2 or 3
+        # Set Acceleration Function
+        self.ser.write(
+            '0 setaccelfunc')  # Sets acceleration for long travel distances, probably dont need, 0 means no accel
+
+        # Set output port
+        self.ser.write('1 setout')  # Sets digital output, 1 means Dout1 = on, Dout2=OFF, Dout3=OFF
+
+        # set trigger out
+        self.ser.write('10 0 1 ot')  # Out Trigger: [time][polarity][output]
+        # time in range of 1-1000 in ms (integer)
+        # polarity in range of 0 or 1
+        # output in range of 1, 2 or 3
         self.setcloop(1)
-        
+
     def disconnect(self):
+        """Disconnects from the Corvus"""
         self.ser.close()
-        print ('Corvus Eco Disconnected')
-        
+        print('Corvus Eco Disconnected')
 
-    #Units: (Unit/s) use setunit command   
-    def setVelocity(self,velocity):
-        self.ser.write(str(velocity)+' sv') #set velocity
-        self.ser.write('gv') #Get Velocity
+    # Units: (Unit/s) use setunit command
+    def setVelocity(self, velocity):
+        self.ser.write(str(velocity) + ' sv')  # set velocity
+        self.ser.write('gv')  # Get Velocity
         response = self.ser.read()
-        print(('Velocity set to: '+response+' [units]/s\n'))
-        
-    #Units: (Unit/s^2) use setunit command            
-    def setAcceleration(self,Acceleration):
-        self.ser.write(str(Acceleration)+' sa') #Set Acceleration
-        self.ser.write('ga')#Get Acceleration
+        print(('Velocity set to: ' + response + ' [units]/s\n'))
+
+    # Units: (Unit/s^2) use setunit command
+    def setAcceleration(self, Acceleration):
+        self.ser.write(str(Acceleration) + ' sa')  # Set Acceleration
+        self.ser.write('ga')  # Get Acceleration
         response = self.ser.read()
-        print(('Acceleration set to: '+response+' [units]/s^2\n'))
-    
-    #Closed Loop ----------------------------
-    def setcloop(self,toggle):
-        #0 = off
-        #1 = on
+        print(('Acceleration set to: ' + response + ' [units]/s^2\n'))
+
+    # Closed Loop ----------------------------
+    def setcloop(self, toggle):
+        # 0 = off
+        # 1 = on
         try:
-            self.ser.write('%d 1 setcloop' %(toggle))
-            self.ser.write('%d 2 setcloop' %(toggle))
-            self.ser.write('%d 3 setcloop' %(toggle))
+            self.ser.write('%d 1 setcloop' % (toggle))
+            self.ser.write('%d 2 setcloop' % (toggle))
+            self.ser.write('%d 3 setcloop' % (toggle))
             if toggle == 0:
-                print ('Close Loop Disabled for All Axis.')
+                print('Close Loop Disabled for All Axis.')
             if toggle == 1:
-                print ('Close Loop Enabled for All Axis.')
+                print('Close Loop Enabled for All Axis.')
         except:
             self.showErr()
 
-    #set scale type
-    def setscaletype(self,stype):
-    #value of 0 or 1
-    # 0 = Analog
-    # 1 = digital
+    # set scale type
+    def setscaletype(self, stype):
+        # value of 0 or 1
+        # 0 = Analog
+        # 1 = digital
         try:
-            self.ser.write('%d 1 setscaletype'%(stype))
-            self.ser.write('%d 2 setscaletype'%(stype))
-            self.ser.write('%d 3 setscaletype'%(stype))
+            self.ser.write('%d 1 setscaletype' % (stype))
+            self.ser.write('%d 2 setscaletype' % (stype))
+            self.ser.write('%d 3 setscaletype' % (stype))
             if stype == 0:
-                print ('Scale Type set to Analog for All Axis')
+                print('Scale Type set to Analog for All Axis')
             if stype == 1:
-                print ('Scale Type set to Digital for All Axis')
+                print('Scale Type set to Digital for All Axis')
         except:
             self.showErr()
-                
-    def setclperiod(self,direction,distance):
-        #+ or - for direction
-        #distance in microns, value from 0.0000001 to 1.999999
-            
-        microndistance = distance/1000
-            
+
+    def setclperiod(self, direction, distance):
+        # + or - for direction
+        # distance in microns, value from 0.0000001 to 1.999999
+
+        microndistance = distance / 1000
+
         try:
-            self.ser.write('%s %d 1 setclperiod'%(direction,microndistance))
-            self.ser.write('%s %d 2 setclperiod'%(direction,microndistance))
-            self.ser.write('%s %d 3 setclperiod'%(direction,microndistance))
+            self.ser.write('%s %d 1 setclperiod' % (direction, microndistance))
+            self.ser.write('%s %d 2 setclperiod' % (direction, microndistance))
+            self.ser.write('%s %d 3 setclperiod' % (direction, microndistance))
             print('Clperiod Set Successfully')
         except:
             self.showErr()
-            
-            
-    def setnselpos(self,pos):
-    #pos: 0 or 1
-    # 0 returns the calculated position
-    # 1 returns the measured position
-            
+
+    def setnselpos(self, pos):
+        # pos: 0 or 1
+        # 0 returns the calculated position
+        # 1 returns the measured position
+
         try:
-            self.ser.write('%d 1 setnselpos'%(pos))
-            self.ser.write('%d 2 setnselpos'%(pos))
-            self.ser.write('%d 3 setnselpos'%(pos))
-            print ('Complete')
-            #NOTE: Try doing this with axis disabled and see if the function still works
-            #should still work even if axis disabled.
+            self.ser.write('%d 1 setnselpos' % (pos))
+            self.ser.write('%d 2 setnselpos' % (pos))
+            self.ser.write('%d 3 setnselpos' % (pos))
+            print('Complete')
+            # NOTE: Try doing this with axis disabled and see if the function still works
+            # should still work even if axis disabled.
         except:
             self.showErr()
-            
-    #sets the unit for all axis
-    #0 = microstep
-    #1 = micron
-    #2 = millimeters
-    #3 = centimeters
-    #4 = meters
-    #5 = inches
-    #6 = mil (1/1000 inch)
-    def setunit(self,unit):
-        self.ser.write('%d 0 setunit'%(unit))
-        self.ser.write('%d 1 setunit'%(unit))
-        self.ser.write('%d 2 setunit'%(unit))
-        self.ser.write('%d 3 setunit'%(unit))
-        print ('Units set successfully.')
-        
-    #Checks the currently set units
-    #0 = microstep
-    #1 = micron
-    #2 = millimeters
-    #3 = centimeters
-    #4 = meters
-    #5 = inches
-    #6 = mil (1/1000 inch)
-    def getunit(self,axis):
-        self.ser.write('%d getunit'%(axis))
+
+    # sets the unit for all axis
+    # 0 = microstep
+    # 1 = micron
+    # 2 = millimeters
+    # 3 = centimeters
+    # 4 = meters
+    # 5 = inches
+    # 6 = mil (1/1000 inch)
+    def setunit(self, unit):
+        self.ser.write('%d 0 setunit' % (unit))
+        self.ser.write('%d 1 setunit' % (unit))
+        self.ser.write('%d 2 setunit' % (unit))
+        self.ser.write('%d 3 setunit' % (unit))
+        print('Units set successfully.')
+
+    # Checks the currently set units
+    # 0 = microstep
+    # 1 = micron
+    # 2 = millimeters
+    # 3 = centimeters
+    # 4 = meters
+    # 5 = inches
+    # 6 = mil (1/1000 inch)
+    def getunit(self, axis):
+        self.ser.write('%d getunit' % (axis))
         value = self.ser.read()
-        print(('Axis %d is set to unitvalue: %s'%(axis,value)))
-            
-#=======Movement functions============
-    def moveX(self,distance):
-        if self.NumberOfAxis == 1:       
+        print(('Axis %d is set to unitvalue: %s' % (axis, value)))
+
+    # =======Movement functions============
+    def moveX(self, distance):
+        if self.NumberOfAxis == 1:
             try:
-                self.ser.write(str(distance)+' r')
-                #print ('Move Complete')
+                self.ser.write(str(distance) + ' r')
+                # print ('Move Complete')
             except:
                 print('An Error has occured')
                 self.showErr()
-                
+
         if self.NumberOfAxis == 2:
             try:
-                self.ser.write(str(distance)+' 0 r')
-                #print ('Move Complete')
+                self.ser.write(str(distance) + ' 0 r')
+                # print ('Move Complete')
             except:
                 print('An Error has occured')
                 self.showErr()
-                
+
         if self.NumberOfAxis == 3:
             try:
-                self.ser.write(str(distance)+' 0 0 r')
-                #print ('Move Complete')
+                self.ser.write(str(distance) + ' 0 0 r')
+                # print ('Move Complete')
             except:
                 print('An Error has occured')
                 self.showErr()
 
-    def moveY(self,distance):
-        if self.NumberOfAxis == 1:       
-            print ('Error: Axis 2 Not Enabled.')
-                
+    def moveY(self, distance):
+        if self.NumberOfAxis == 1:
+            print('Error: Axis 2 Not Enabled.')
+
         if self.NumberOfAxis == 2:
             try:
-                self.ser.write('0 '+str(distance)+' r')
-                #print ('Move Complete')
+                self.ser.write('0 ' + str(distance) + ' r')
+                # print ('Move Complete')
             except:
                 print('An Error has occured')
                 self.showErr()
-                
+
         if self.NumberOfAxis == 3:
             try:
-                self.ser.write('0 '+str(distance)+' 0 r')
-                #print ('Move Complete')
+                self.ser.write('0 ' + str(distance) + ' 0 r')
+                # print ('Move Complete')
             except:
                 print('An Error has occured')
                 self.showErr()
-            
-    def moveZ(self,distance):
-        if self.NumberOfAxis == 1:       
-            print ('Error: Axis 3 Not Enabled.')
-                
+
+    def moveZ(self, distance):
+        if self.NumberOfAxis == 1:
+            print('Error: Axis 3 Not Enabled.')
+
         if self.NumberOfAxis == 2:
-            print ('Error: Axis 3 Not Enabled.')
-                
+            print('Error: Axis 3 Not Enabled.')
+
         if self.NumberOfAxis == 3:
             try:
-                self.ser.write('0 0 '+str(distance)+' r')
-                #print ('Move Complete')
+                self.ser.write('0 0 ' + str(distance) + ' r')
+                # print ('Move Complete')
             except:
                 print('An Error has occured')
                 self.showErr()
-                
-    #Moves all the axis together
-    #can be used regardless of how many axis are enabled
-    def moveRelative(self,x,y=0,z=0):
-        if self.NumberOfAxis == 1:       
+
+    # Moves all the axis together
+    # can be used regardless of how many axis are enabled
+    def moveRelative(self, x, y=0, z=0):
+        if self.NumberOfAxis == 1:
             try:
-                self.ser.write('%.6f r'%(x))
-                #print ('Move Complete')
+                self.ser.write('%.6f r' % (x))
+                # print ('Move Complete')
             except:
                 print('An Error has occured')
                 self.showErr()
-                
+
         if self.NumberOfAxis == 2:
             try:
-                self.ser.write('%.6f %.6f r'%(x,y))
-                #print ('Move Complete')
+                self.ser.write('%.6f %.6f r' % (x, y))
+                # print ('Move Complete')
             except:
                 print('An Error has occured')
                 self.showErr()
-                
+
         if self.NumberOfAxis == 3:
             try:
-                self.ser.write('%.6f %.6f %.6f r'%(x,y,z))
-                #print ('Move Complete')
+                self.ser.write('%.6f %.6f %.6f r' % (x, y, z))
+                # print ('Move Complete')
             except:
                 print('An Error has occured')
                 self.showErr()
         self.waitMoveComplete()
-        
-        
-    def moveAbsoluteXYZ(self,x,y,z):
+
+    def moveAbsoluteXYZ(self, x, y, z):
         xCurrentPos = self.getPosition()[0];
         yCurrentPos = self.getPosition()[1];
         zCurrentPos = self.getPosition()[2];
-        self.moveRelative(x-xCurrentPos, y-yCurrentPos, z-zCurrentPos)
-    
+        self.moveRelative(x - xCurrentPos, y - yCurrentPos, z - zCurrentPos)
+
     def waitMoveComplete(self):
         while int(self.ser.ask('st')) & 1:
             time.sleep(0.001)
-                
-    #Absolute MOve
-    #Has a possible range of +/- 16383mm
-    #units are the ones defined to the axis (should be microns)
-    
-    #From manual: The move profile is calculated in respect to the velocity/acceleration
-    #setup and the given hard or software limits. The axes are linear interpolated, 
-    #this causes the controller to start and stop all active axes simultaneously
-#    def moveAbsolute(self,x,y=0,z=0):
-#        if self.NumberOfAxis == 1:       
-#            try:
-#                self.ser.write('%d m'%(x))
-#                print ('Move Complete')
-#            except:
-#                print('An Error has occured')
-#                self.showErr()
-#                
-#        if self.NumberOfAxis == 2:
-#            try:
-#                self.ser.write('%d %d m'%(x,y))
-#                print ('Move Complete')
-#            except:
-#                print('An Error has occured')
-#                self.showErr()
-#                
-#        if self.NumberOfAxis == 3:
-#            try:
-#                self.ser.write('%d %d %d m'%(x,y,z))
-#                print ('Move Complete')
-#            except:
-#                print('An Error has occured')
-#                self.showErr()
-                
+
+    # Absolute MOve
+    # Has a possible range of +/- 16383mm
+    # units are the ones defined to the axis (should be microns)
+
+    # From manual: The move profile is calculated in respect to the velocity/acceleration
+    # setup and the given hard or software limits. The axes are linear interpolated,
+    # this causes the controller to start and stop all active axes simultaneously
+    #    def moveAbsolute(self,x,y=0,z=0):
+    #        if self.NumberOfAxis == 1:
+    #            try:
+    #                self.ser.write('%d m'%(x))
+    #                print ('Move Complete')
+    #            except:
+    #                print('An Error has occured')
+    #                self.showErr()
+    #
+    #        if self.NumberOfAxis == 2:
+    #            try:
+    #                self.ser.write('%d %d m'%(x,y))
+    #                print ('Move Complete')
+    #            except:
+    #                print('An Error has occured')
+    #                self.showErr()
+    #
+    #        if self.NumberOfAxis == 3:
+    #            try:
+    #                self.ser.write('%d %d %d m'%(x,y,z))
+    #                print ('Move Complete')
+    #            except:
+    #                print('An Error has occured')
+    #                self.showErr()
+
     def getPosition(self):
         try:
             self.ser.write('pos')
@@ -346,23 +354,22 @@
             print('An Error has occured')
             self.showErr()
         return res
-                         
-    def clear(self): #Should clear any lingering messages in the device
+
+    def clear(self):  # Should clear any lingering messages in the device
         try:
-            self.ser.write('clear')#Clears the parameter stack, refer to page 287 in manual for more detail
+            self.ser.write('clear')  # Clears the parameter stack, refer to page 287 in manual for more detail
         except:
             self.showErr()
-            
-    def reset(self):#Resets the whole device, equivalent of disconnecting the power according to the manual
-    #a beep should be heard after the device is reset
+
+    def reset(self):  # Resets the whole device, equivalent of disconnecting the power according to the manual
+        # a beep should be heard after the device is reset
         try:
             self.ser.write('reset')
         except:
             self.showErr()
-        
+
     def showErr(self):
-        self.ser.write('ge') #Returns error and clears the error stack, Errors are given as codes which are listen in them manual
-        error = str('Error Code: '+self.ser.read()+' (Refer to Manual Page 165)')
+        self.ser.write(
+            'ge')  # Returns error and clears the error stack, Errors are given as codes which are listen in them manual
+        error = str('Error Code: ' + self.ser.read() + ' (Refer to Manual Page 165)')
         raise Exception(error)
-               
-        
\ No newline at end of file
Index: Qontrol.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import qontrol\r\n\r\n\r\nclass QontrolMotor:\r\n    name = 'Qontrol'\r\n    isQontrol = True\r\n    isMotor = False\r\n    isOpt = False\r\n    isElec = True\r\n    isLaser = False\r\n\r\n    def __init__(self):\r\n        self.q = None\r\n        self.numAxes = 0\r\n\r\n    def connect(self, SerialPortName, NumberOfAxis):\r\n        self.q = qontrol.MXMotor(serial_port_name=SerialPortName)\r\n        self.numAxes = NumberOfAxis\r\n        print('Connected\\n')\r\n\r\n        # Sets maximum # of axis to send commands to\r\n        if NumberOfAxis >= 6 | NumberOfAxis < 0:\r\n            print('Invalid number of axes. Please enter at most six axes.\\n')\r\n            self.numAxes = 6\r\n\r\n    def disconnect(self):\r\n        self.q.close()\r\n\r\n    # Moves all the axis together\r\n    # can be used regardless of how many axis are enabled\r\n    def moveAbsoluteXYZ(self, x, y=0, z=0):\r\n        self.q[0] = x\r\n        self.q[1] = y\r\n        self.q[2] = z\r\n\r\n    def moveRelativeXYZ(self, x, y, z):\r\n        xCurrentPos = self.q[0]\r\n        yCurrentPos = self.q[1]\r\n        zCurrentPos = self.q[2]\r\n        self.q[0] = x - xCurrentPos\r\n        self.q[1] = y - yCurrentPos\r\n        self.q[2] = z - zCurrentPos\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Qontrol.py b/Qontrol.py
--- a/Qontrol.py	(revision abd26e7fa73a137f488f4dfbf10def44bc04de2c)
+++ b/Qontrol.py	(date 1664486242393)
@@ -1,5 +1,5 @@
 import qontrol
-
+import re
 
 class QontrolMotor:
     name = 'Qontrol'
@@ -8,13 +8,20 @@
     isOpt = False
     isElec = True
     isLaser = False
+    isDetect = False
+    isSMU = False
 
     def __init__(self):
         self.q = None
         self.numAxes = 0
 
     def connect(self, SerialPortName, NumberOfAxis):
-        self.q = qontrol.MXMotor(serial_port_name=SerialPortName)
+        numbers = re.findall('[0-9]+', SerialPortName)
+        COM = "COM" + numbers[0]
+        self.q = qontrol.MXMotor(serial_port_name=COM)
+        self.q.mode = 21
+        #self.q.xmin =
+        #self.q.xmax =
         self.numAxes = NumberOfAxis
         print('Connected\n')
 
@@ -28,16 +35,27 @@
 
     # Moves all the axis together
     # can be used regardless of how many axis are enabled
-    def moveAbsoluteXYZ(self, x, y=0, z=0):
-        self.q[0] = x
-        self.q[1] = y
-        self.q[2] = z
 
-    def moveRelativeXYZ(self, x, y, z):
+        
+    def moveAbsoluteXYZ(self, x, y, z):
+        print("Absolute")
+        self.q.x[0] = x
+        self.q.wait_until_stopped()
+        self.q.x[1] = y
+        self.q.wait_until_stopped()
+        self.q.x[2] = z
+        self.q.wait_until_stopped()
+
+    def moveRelativeXYZ(self, x, y, z=0):
         xCurrentPos = self.q[0]
         yCurrentPos = self.q[1]
         zCurrentPos = self.q[2]
+        print(xCurrentPos)
+        print(yCurrentPos)
         self.q[0] = x - xCurrentPos
+        self.q.wait_until_stopped()
         self.q[1] = y - yCurrentPos
+        self.q.wait_until_stopped()
         self.q[2] = z - zCurrentPos
+        self.q.wait_until_stopped()
 
Index: TestParameters.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n# The MIT License (MIT)\r\n\r\n# Copyright (c) 2015 Michael Caverley\r\n\r\n# Permission is hereby granted, free of charge, to any person obtaining a copy\r\n# of this software and associated documentation files (the \"Software\"), to deal\r\n# in the Software without restriction, including without limitation the rights\r\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n# copies of the Software, and to permit persons to whom the Software is\r\n# furnished to do so, subject to the following conditions:\r\n\r\n# The above copyright notice and this permission notice shall be included in\r\n# all copies or substantial portions of the Software.\r\n\r\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n# THE SOFTWARE.\r\nimport os\r\nimport wx\r\nimport re\r\nfrom outputlogPanel import outputlogPanel\r\nfrom logWriter import logWriter, logWriterError\r\nimport sys\r\nfrom ElectroOpticDevice import ElectroOpticDevice\r\n\r\n\r\nclass testParameters(wx.Frame):\r\n\r\n    def __init__(self):\r\n\r\n        displaySize = wx.DisplaySize()\r\n        super(testParameters, self).__init__(None, title='Instrument Control', size=(int(displaySize[0] * 5 / 8.0), int(displaySize[1] * 3 / 4.0)))\r\n\r\n        try:\r\n            self.InitUI()\r\n        except Exception as e:\r\n            self.Destroy()\r\n            raise\r\n        self.Centre()\r\n        self.Show()\r\n\r\n\r\n    def InitUI(self):\r\n        \"\"\"\r\n        Creates the highest level formatting for the testing parameters frame\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n        self.Bind(wx.EVT_CLOSE, self.OnExitApp)\r\n        vbox = wx.BoxSizer(wx.VERTICAL)\r\n        panel = TopPanel(self)\r\n        vbox.Add(panel, proportion=1, border=0, flag=wx.EXPAND)\r\n        self.log = outputlogPanel(self)\r\n        vbox.Add(self.log, 1, wx.EXPAND)\r\n        self.SetSizer(vbox)\r\n        sys.stdout = logWriter(self.log)\r\n        sys.stderr = logWriterError(self.log)\r\n\r\n\r\n    def OnExitApp(self, event):\r\n        \"\"\"\r\n        Terminates the window on close\r\n        Parameters\r\n        ----------\r\n        event :\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n        self.Destroy()\r\n\r\n\r\n# Panel which contains the panels used for controlling the laser and detectors. It also\r\n# contains the graph.\r\nclass TopPanel(wx.Panel):\r\n\r\n    def __init__(self, parent):\r\n        super(TopPanel, self).__init__(parent)\r\n        self.routineflag = \"\"\r\n        self.setpanel = SetPanel(self)#BlankPanel(self)\r\n        self.instructpanel = InstructPanel(self, self.setpanel)\r\n        self.autoMeasure = autoMeasure()\r\n        self.selected = []\r\n        self.retrievedataselected = []\r\n        self.setflag = False\r\n        self.highlightchecked = []\r\n        self.beginning = False\r\n        self.end = False\r\n        self.routinenum = 0\r\n        self.retrievedataflag = False\r\n        self.deviceListset = []\r\n        self.data = {'user': [], 'index': [], 'device': [], 'ELECflag': [], 'OPTICflag': [], 'setwflag': [], 'setvflag': [], 'Voltsel': [],\r\n                     'Currentsel': [], 'VoltMin': [], 'VoltMax': [], 'CurrentMin': [], 'CurrentMax': [],\r\n                     'VoltRes': [], 'CurrentRes': [], 'IV': [], 'RV': [], 'PV': [], 'ChannelA': [], 'ChannelB': [],\r\n                     'Start': [], 'Stop': [], 'Stepsize': [], 'Sweeppower': [], 'Sweepspeed': [], 'Laseroutput': [],\r\n                     'Numscans': [], 'InitialRange': [], 'RangeDec': [] ,'setwVoltsel': [],'setwCurrentsel': [],\r\n                     'setwVoltMin': [], 'setwVoltMax': [], 'setwCurrentMin': [], 'setwCurrentMax': [],\r\n                     'setwVoltRes': [], 'setwCurrentRes': [], 'setwIV': [], 'setwRV': [], 'setwPV': [],\r\n                     'setwChannelA': [], 'setwChannelB': [], 'Wavelengths': [], 'setvStart': [], 'setvStop': [],\r\n                     'setvStepsize': [], 'setvSweeppower': [], 'setvSweepspeed': [], 'setvLaseroutput': [],\r\n                     'setvNumscans': [], 'setvInitialRange': [], 'setvRangeDec': [], 'setvChannelA': [],\r\n                     'setvChannelB': [], 'Voltages': [], 'RoutineNumber': []}\r\n\r\n        self.InitUI()\r\n\r\n\r\n    def InitUI(self):\r\n\r\n        sbOuter = wx.StaticBox(self, label='Test Parameter Creation')\r\n        vboxOuter = wx.StaticBoxSizer(sbOuter, wx.VERTICAL)\r\n\r\n        #Coordinate file select\r\n        hbox = wx.BoxSizer(wx.HORIZONTAL)\r\n        self.coordFileTb = wx.TextCtrl(self, style=wx.TE_READONLY)\r\n        self.coordFileTb.SetValue('No file selected')\r\n        self.coordFileSelectBtn = wx.Button(self, wx.ID_OPEN, size=(50, 20))\r\n        self.coordFileSelectBtn.Bind(wx.EVT_BUTTON, self.OnButton_ChooseCoordFile)\r\n        hbox.AddMany([(self.coordFileTb, 1, wx.EXPAND), (self.coordFileSelectBtn, 0, wx.EXPAND)])\r\n\r\n        #select all button, unselect all button, select keyword button, unselect keyword button, retreive data button\r\n        hbox2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        self.checkAllBtn = wx.Button(self, label='Select All', size=(80, 20))\r\n        self.checkAllBtn.Bind(wx.EVT_BUTTON, self.OnButton_CheckAll)\r\n        self.uncheckAllBtn = wx.Button(self, label='Unselect All', size=(80, 20))\r\n        self.uncheckAllBtn.Bind(wx.EVT_BUTTON, self.OnButton_UncheckAll)\r\n        self.searchFile = wx.TextCtrl(self)\r\n        self.searchFile.SetValue('')\r\n        self.searchFile.Bind(wx.EVT_TEXT, self.highlight)\r\n        self.searchBtn = wx.Button(self, label='Select keyword', size=(100, 20))\r\n        self.searchBtn.Bind(wx.EVT_BUTTON, self.SearchDevices)\r\n        self.unsearchBtn = wx.Button(self, label='Unselect keyword', size=(100, 20))\r\n        self.unsearchBtn.Bind(wx.EVT_BUTTON, self.unSearchDevices)\r\n        self.retrievedataBtn = wx.Button(self, label='Retrieve Data', size=(100, 20))\r\n        self.retrievedataBtn.Bind(wx.EVT_BUTTON, self.retrievedata)\r\n        self.indicator = wx.StaticText(self, label='')\r\n\r\n        self.setname = wx.StaticText(self, label='Enter name of User (optional):')\r\n        self.name = wx.TextCtrl(self)\r\n        self.name.SetValue('')\r\n        self.name.Bind(wx.EVT_TEXT, self.nameselect)\r\n        hbox2.AddMany([(self.checkAllBtn, 0, wx.EXPAND), (self.uncheckAllBtn, 0, wx.EXPAND), (self.searchFile, 0, wx.EXPAND), (self.searchBtn, 0, wx.EXPAND), (self.unsearchBtn, 0, wx.EXPAND), (self.retrievedataBtn, 0, wx.EXPAND),(self.setname, 0, wx.EXPAND), (self.name, 0, wx.EXPAND), (self.indicator, 0, wx.EXPAND)])\r\n\r\n        ##\r\n        self.checkList = wx.ListCtrl(self, -1, style=wx.LC_REPORT)\r\n        self.checkList.InsertColumn(0, 'Device', width=100)\r\n        self.checkList.Bind(wx.EVT_LIST_ITEM_CHECKED, self.checkListchecked)\r\n        self.checkList.Bind(wx.EVT_LIST_ITEM_UNCHECKED, self.checkListunchecked)\r\n\r\n        hbox3 = wx.BoxSizer(wx.HORIZONTAL)\r\n        vboxdevices = wx.BoxSizer(wx.VERTICAL)\r\n\r\n        vboxdevices.AddMany([(self.checkList, 1, wx.EXPAND), (self.instructpanel, 1, wx.EXPAND)])\r\n        #vboxdevices.Add(self.instructpanel, 1, wx.EXPAND)\r\n\r\n        #hbox3.AddMany([(vboxdevices, 0, wx.EXPAND)])\r\n\r\n\r\n\r\n\r\n        hbox5 = wx.BoxSizer(wx.HORIZONTAL)\r\n\r\n        hbox5.Add(self.setpanel, 0, wx.EXPAND)\r\n\r\n\r\n        hbox6 = wx.BoxSizer(wx.HORIZONTAL)\r\n        st2 = wx.StaticText(self, label='Save folder:')\r\n        self.outputFolderTb = wx.TextCtrl(self, style=wx.TE_READONLY)\r\n        self.outputFolderBtn = wx.Button(self, wx.ID_OPEN, size=(50, 20))\r\n        self.outputFolderBtn.Bind(wx.EVT_BUTTON, self.OnButton_SelectOutputFolder)\r\n        hbox6.AddMany([(st2, 1, wx.EXPAND), (self.outputFolderTb, 1, wx.EXPAND), (self.outputFolderBtn, 0, wx.EXPAND)])\r\n\r\n\r\n        #set button, import button and export button\r\n        hbox7 = wx.BoxSizer(wx.HORIZONTAL)\r\n        self.setBtn = wx.Button(self, label='Set', size=(50, 20))\r\n        self.setBtn.Bind(wx.EVT_BUTTON, self.SetButton)\r\n\r\n        self.exportBtn = wx.Button(self, label='Export', size=(50, 20))\r\n        self.exportBtn.Bind(wx.EVT_BUTTON, self.ExportButton)\r\n        hbox7.AddMany([(self.setBtn, 0, wx.EXPAND), (self.exportBtn, 0, wx.EXPAND)])\r\n\r\n        hbox6.AddMany([((1,1), 1, wx.EXPAND), ((1,1), 1, wx.EXPAND), ((1,1), 1, wx.EXPAND), ((1,1), 1, wx.EXPAND), ((1,1), 1, wx.EXPAND), ((1,1), 1, wx.EXPAND), ((1,1), 1, wx.EXPAND), ((1,1), 1, wx.EXPAND), (hbox7, 0, wx.EXPAND)])\r\n\r\n        hboxouter = wx.BoxSizer(wx.HORIZONTAL)\r\n\r\n        hboxouter.AddMany([(vboxdevices, 1 , wx.EXPAND), (hbox5, 0, wx.EXPAND)])\r\n        #hboxouter.Add(hbox5, 0, wx.EXPAND)\r\n        #hboxouter.Add(vboxdevices, 0, wx.EXPAND)\r\n\r\n        vboxOuter.AddMany([(hbox, 0, wx.EXPAND), (hbox2, 0, wx.EXPAND), (hboxouter, 0, wx.EXPAND),\r\n                           (hbox6, 0, wx.ALIGN_LEFT)])#, (hbox7, 0, wx.ALIGN_RIGHT)])\r\n\r\n        self.SetSizer(vboxOuter)\r\n\r\n\r\n    def nameselect(self, event):\r\n        \"\"\"\r\n        Takes the user inputted name and stores it under the data dictionary user key\r\n        Parameters\r\n        ----------\r\n        event : the event triggered by inputting something into the user name box\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n\r\n        self.data['user'].clear()\r\n        self.data['user'].append(self.name.GetValue())\r\n\r\n\r\n    def OnButton_ChooseCoordFile(self, event):\r\n        \"\"\"\r\n        When event is triggered this function opens the chosen coordinate file and displays the devices in a checklist\r\n        Parameters\r\n        ----------\r\n        event : the event triggered by clicking the open button to choose the auto-coordinate file\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n\r\n        \"\"\" Opens a file dialog to select a coordinate file. \"\"\"\r\n        fileDlg = wx.FileDialog(self, \"Open\", \"\", \"\",\r\n                                \"Text Files (*.txt)|*.txt\",\r\n                                wx.FD_OPEN | wx.FD_FILE_MUST_EXIST)\r\n        fileDlg.ShowModal()\r\n        self.coordFileTb.SetValue(fileDlg.GetFilenames()[0])\r\n        # fileDlg.Destroy()\r\n        self.autoMeasure.readCoordFile(fileDlg.GetPath())\r\n        global deviceListAsObjects\r\n        deviceListAsObjects = self.autoMeasure.devices\r\n        self.device_list = deviceListAsObjects\r\n        global deviceList\r\n        deviceList = []\r\n        for device in deviceListAsObjects:\r\n            deviceList.append(device.getDeviceID())\r\n        # Adds items to the check list\r\n        self.checkList.DeleteAllItems()\r\n        for ii, device in enumerate(deviceList):\r\n            self.checkList.InsertItem(ii, device)\r\n            for dev in deviceListAsObjects:\r\n                if dev.getDeviceID() == device:\r\n                    index = deviceListAsObjects.index(dev)  # Stores index of device in list\r\n            self.checkList.SetItemData(ii, index)\r\n        self.checkList.SortItems(self.checkListSort)  # Make sure items in list are sorted\r\n        self.checkList.EnableCheckBoxes()\r\n        self.set = [False] * self.checkList.GetItemCount()\r\n\r\n       # for ii in range(self.checkList.GetItemCount()):\r\n            #self.data['index'] = ii\r\n\r\n            #electrical parameters of data\r\n        self.data['index'] = []\r\n        self.data['device'] = [] #* self.checkList.GetItemCount()\r\n        self.data['Voltsel'] = [] #* self.checkList.GetItemCount()\r\n        self.data['Currentsel'] = []# * self.checkList.GetItemCount()\r\n        self.data['VoltMin'] = [] #* self.checkList.GetItemCount()\r\n        self.data['VoltMax'] = [] #* self.checkList.GetItemCount()\r\n        self.data['CurrentMin'] = []# * self.checkList.GetItemCount()\r\n        self.data['CurrentMax'] = [] #* self.checkList.GetItemCount()\r\n        self.data['VoltRes'] = [] #* self.checkList.GetItemCount()\r\n        self.data['CurrentRes'] = [] #* self.checkList.GetItemCount()\r\n        self.data['IV'] = [] #* self.checkList.GetItemCount()\r\n        self.data['RV'] = [] #* self.checkList.GetItemCount()\r\n        self.data['PV'] = [] #* self.checkList.GetItemCount()\r\n        self.data['ChannelA'] = [] #* self.checkList.GetItemCount()\r\n        self.data['ChannelB'] = [] #* self.checkList.GetItemCount()\r\n\r\n            #optical parameters of data\r\n        self.data['Start'] = [] #* self.checkList.GetItemCount()\r\n        self.data['Stop'] = [] #* self.checkList.GetItemCount()\r\n        self.data['Stepsize'] = [] #* self.checkList.GetItemCount()\r\n        self.data['Sweeppower'] = [] #* self.checkList.GetItemCount()\r\n        self.data['Sweepspeed'] = [] #* self.checkList.GetItemCount()\r\n        self.data['Laseroutput'] = [] #* self.checkList.GetItemCount()\r\n        self.data['Numscans'] = [] #* self.checkList.GetItemCount()\r\n        self.data['InitialRange'] = [] #* self.checkList.GetItemCount()\r\n        self.data['RangeDec'] = [] #* self.checkList.GetItemCount()\r\n\r\n            #set wavelength parameters of data\r\n        self.data['setwVoltsel'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setwCurrentsel'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setwVoltMin'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setwVoltMax'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setwCurrentMin'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setwCurrentMax'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setwVoltRes'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setwCurrentRes'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setwIV'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setwRV'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setwPV'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setwChannelA'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setwChannelB'] = [] #* self.checkList.GetItemCount()\r\n        self.data['Wavelengths'] = [] #* self.checkList.GetItemCount()\r\n\r\n            #set voltage parameters of data\r\n        self.data['setvStart'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setvStop'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setvStepsize'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setvSweeppower'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setvSweepspeed'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setvLaseroutput'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setvNumscans'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setvInitialRange'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setvRangeDec'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setvChannelA'] = [] #* self.checkList.GetItemCount()\r\n        self.data['setvChannelB'] = []# * self.checkList.GetItemCount()\r\n        self.data['Voltages'] = []# * self.checkList.GetItemCount()\r\n\r\n\r\n        global fileLoaded\r\n        fileLoaded = True\r\n        self.Refresh()\r\n\r\n\r\n    def OnButton_CheckAll(self, event):\r\n        \"\"\"\r\n        Checks all the devices in the checklist, will not check the devices that have already been set\r\n        Parameters\r\n        ----------\r\n        event : the event triggered when the select all button is pushed\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n\r\n        if self.retrievedataflag == False:\r\n            for ii in range(self.checkList.GetItemCount()):\r\n                if self.set[ii] == False:\r\n                    self.checkList.CheckItem(ii, True)\r\n        else:\r\n            return\r\n\r\n\r\n    def retrievedata(self, event):\r\n        \"\"\"\r\n        configures the switch from set data mode to retrieve data mode by setting or unsetting various flags\r\n        Parameters\r\n        ----------\r\n        event : the event triggered when the user presses the retrieve data button\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n\r\n        if self.retrievedataflag == False:\r\n            print(\"Entering routine extraction mode\")\r\n            self.indicator.SetLabel('Retrieve Data Mode')\r\n            self.retrievedataflag = True\r\n            self.beginning = True\r\n            for c in self.selected:\r\n                self.checkList.CheckItem(c, False)\r\n            self.beginning = False\r\n            return\r\n\r\n        self.end = True\r\n        for c in self.retrievedataselected:\r\n            self.checkList.CheckItem(c, False)\r\n\r\n        for c in self.selected:\r\n            self.checkList.CheckItem(c, True)\r\n        self.end = False\r\n\r\n        self.highlightchecked = []\r\n        self.retrievedataselected = []\r\n\r\n        for x in range(self.checkList.GetItemCount()):\r\n            self.checkList.SetItemBackgroundColour(x, wx.Colour(255, 255, 255))\r\n\r\n\r\n        self.indicator.SetLabel('')\r\n        self.retrievedataflag = False\r\n        print(\"Exiting routine extraction mode\")\r\n\r\n        #self.retrievedataselected\r\n        #for c in self.set\r\n\r\n\r\n    def OnButton_UncheckAll(self, event):\r\n        \"\"\"\r\n        Uncheck all items in the checklist\r\n        Parameters\r\n        ----------\r\n        event : the event triggered by pressing the unselect all button\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n\r\n        for ii in range(self.checkList.GetItemCount()):\r\n            self.checkList.CheckItem(ii, False)\r\n\r\n\r\n    def highlight(self, event):\r\n        \"\"\"\r\n        Highlights the items in the checklist that contain the string in the searchfile textctrl box\r\n        Parameters\r\n        ----------\r\n        event : the event triggered by pressing the select keyword button\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n\r\n        for c in range(self.checkList.GetItemCount()):\r\n            if self.set[c] != True and self.searchFile.GetValue() != None and self.searchFile.GetValue() in self.checkList.GetItemText(c, 0):\r\n                self.checkList.SetItemBackgroundColour(c, wx.Colour(255, 255, 0))\r\n            else:\r\n                self.checkList.SetItemBackgroundColour(c, wx.Colour(255,255,255))\r\n\r\n            if self.searchFile.GetValue() == '':\r\n                self.checkList.SetItemBackgroundColour(c, wx.Colour(255,255,255))\r\n\r\n\r\n    def retrievehighlight(self, index):\r\n        \"\"\"\r\n        When an item is selected while in retrieve data mode this function highlights all the items that have the same\r\n        routine (routine similarity is based on when the routine was originally set, not whether of not the routines are\r\n        numerically the same)\r\n        Parameters\r\n        ----------\r\n        index : the index of the checklist device chosen while in retrieve data mode\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n\r\n        flag = False\r\n        if self.set[index] == True:\r\n            flag = True\r\n\r\n        if flag == False:\r\n            return\r\n\r\n        num = []\r\n        for d in self.highlightchecked:\r\n            for a in range(len(self.data['index'])):\r\n                if self.data['index'][a] == d:\r\n                    num.append(a)\r\n\r\n        for d in range(len(num)):\r\n            if self.data['RoutineNumber'][num[d]] != self.data['RoutineNumber'][index]:\r\n                return\r\n\r\n        self.highlightchecked.append(index)\r\n\r\n\r\n\r\n        for c in range(len(self.data['RoutineNumber'])):\r\n            if self.data['RoutineNumber'][c] == self.data['RoutineNumber'][index]:\r\n                d = self.data['index'][c]\r\n                self.checkList.SetItemBackgroundColour(d, wx.Colour(255, 255, 0))\r\n\r\n\r\n    def retrieveunhighlight(self, index):\r\n        \"\"\"\r\n        When the device that was previosuly selected becomes unselected this function unhighlights all similar routine devices\r\n        Parameters\r\n        ----------\r\n        index : the index of the checklist device being unselected\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n\r\n        num = []\r\n        for d in self.highlightchecked:\r\n            for a in range(len(self.data['index'])):\r\n                if self.data['index'][a] == d:\r\n                    num.append(a)\r\n\r\n        for d in range(len(num)):\r\n            if self.data['RoutineNumber'][num[d]] != self.data['RoutineNumber'][index]:\r\n                return\r\n\r\n        self.highlightchecked.remove(index)\r\n\r\n        if self.highlightchecked == []:\r\n            for c in range(len(self.data['RoutineNumber'])):\r\n                if self.data['RoutineNumber'][c] == self.data['RoutineNumber'][index]:\r\n                    d = self.data['index'][c]\r\n                    self.checkList.SetItemBackgroundColour(d, wx.Colour(255, 255, 255))\r\n\r\n\r\n    def SearchDevices(self, event):\r\n        \"\"\"\r\n        When the search devices button is clicked this function selects all devices in the checklist that contain the string in searchfile textctrl box\r\n        Parameters\r\n        ----------\r\n        event : the event triggered by pressing the search keyword button\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n\r\n        for c in range(len(self.set)):\r\n            if self.set[c] != True and self.searchFile.GetValue() != '' and self.searchFile.GetValue() in self.checkList.GetItemText(c, 0):\r\n                self.checkList.CheckItem(c, True)\r\n\r\n\r\n    def unSearchDevices(self, event):\r\n        \"\"\"\r\n        Unselects all devices in checklist that contain the string in searchfile textctrl box\r\n        Parameters\r\n        ----------\r\n        event : the event triggered on pressing the unselect keyword button\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n\r\n        for c in range(len(self.set)):\r\n            if self.set[c] != True and self.searchFile.GetValue() != '' and self.searchFile.GetValue() in self.checkList.GetItemText(c, 0):\r\n                self.checkList.CheckItem(c, False)\r\n\r\n\r\n    def checkListSort(self, item1, item2):\r\n        \"\"\"\r\n        Sorts two items passed to it, used to sort the items in the checklist on creation\r\n        Parameters\r\n        ----------\r\n        item1 : integer value\r\n        item2 : integer value\r\n\r\n        Returns\r\n        -------\r\n        A -1, a 1 or a 0 depending on the size of the items\r\n\r\n        \"\"\"\r\n        # Items are the client data associated with each entry\r\n        if item2 < item2:\r\n            return -1\r\n        elif item1 > item2:\r\n            return 1\r\n        else:\r\n            return 0\r\n\r\n\r\n    def checkListchecked(self, event):\r\n        \"\"\"\r\n        If in set data mode this function adds the now checked device to a list of selected devices, if in retrieve\r\n        data mode this function calls reteivedataswap beginning the data reteival process for the device in quuestion\r\n        Parameters\r\n        ----------\r\n        event : the event triggered by selecting a device in the list\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n        c = event.GetIndex()\r\n\r\n        if self.retrievedataflag == False:\r\n            self.selected.append(c)\r\n        elif self.end == True:\r\n            pass\r\n        elif self.retrievedataflag == True:\r\n            self.retrievedataswap(c)\r\n            self.retrievehighlight(c)\r\n\r\n\r\n    def retrievedataswap(self, c):\r\n        \"\"\"\r\n        Swaps the data in the parameters menu to that of the selected device when in retrieve data mode\r\n        Parameters\r\n        ----------\r\n        c : the index of the selected device in the checklist\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n\r\n        self.retrievedataselected.append(c)\r\n\r\n        if self.set[c] == False:\r\n            print('Please select a preset device')\r\n            self.checkList.CheckItem(c, False)\r\n            return\r\n\r\n        number = []\r\n\r\n        for d in range(len(self.data['device'])):\r\n\r\n            if self.data['device'][d] == self.checkList.GetItemText(c, 0):\r\n                number.append(d)\r\n\r\n        for d in self.retrievedataselected:\r\n\r\n            comindex = []\r\n\r\n            if d == c:\r\n                pass\r\n            else:\r\n                for a in range(len(self.data['device'])):\r\n                    if self.data['device'][a] == self.checkList.GetItemText(d, 0):\r\n                        comindex.append(d)\r\n\r\n                if self.data['RoutineNumber'][comindex[0]] != self.data['RoutineNumber'][number[0]]:\r\n                    print(\r\n                        'Cannot fetch two different routines, please select devices with same routine, or individually modify each device')\r\n                    self.checkList.CheckItem(c, False)\r\n                    return\r\n\r\n            ELECcount = 0\r\n            OPTcount = 0\r\n            SETWcount = 0\r\n            SETVcount = 0\r\n            for q in number:\r\n\r\n                if self.data['ELECflag'][q] == True:\r\n                    ELECcount = ELECcount + 1\r\n                if self.data['OPTICflag'][q] == True:\r\n                    OPTcount = OPTcount + 1\r\n                if self.data['setvflag'][q] == True:\r\n                    SETVcount = SETVcount + 1\r\n                if self.data['setwflag'][q] == True:\r\n                    SETWcount = SETWcount + 1\r\n\r\n            self.instructpanel.elecroutine.SetValue(str(ELECcount))\r\n            self.instructpanel.optroutine.SetValue(str(OPTcount))\r\n            self.instructpanel.setvroutine.SetValue(str(SETVcount))\r\n            self.instructpanel.setwroutine.SetValue(str(SETWcount))\r\n\r\n            elecoptions = []\r\n            optoptions = []\r\n            setvoptions = []\r\n            setwoptions = []\r\n\r\n            if ELECcount != '' and ELECcount != '0':\r\n                for x in range(int(ELECcount)):\r\n                    x = x + 1\r\n                    elecoptions.append(str(x))\r\n\r\n            if OPTcount != '' and OPTcount != '0':\r\n                for x in range(int(OPTcount)):\r\n                    x = x + 1\r\n                    optoptions.append(str(x))\r\n\r\n            if SETVcount != '' and SETVcount != '0':\r\n                for x in range(int(SETVcount)):\r\n                    x = x + 1\r\n                    setvoptions.append(str(x))\r\n\r\n            if SETWcount != '' and SETWcount != '0':\r\n                options = []\r\n                for x in range(int(SETWcount)):\r\n                    x = x + 1\r\n                    setwoptions.append(str(x))\r\n\r\n\r\n            #Electrical set#############################################################################################\r\n            self.setpanel.routineselectelec.SetItems(elecoptions)\r\n            self.setpanel.elecvolt = [''] * int(ELECcount)\r\n            self.setpanel.eleccurrent = [''] * int(ELECcount)\r\n            self.setpanel.elecvmax = [''] * int(ELECcount)\r\n            self.setpanel.elecvmin = [''] * int(ELECcount)\r\n            self.setpanel.elecimin = [''] * int(ELECcount)\r\n            self.setpanel.elecimax = [''] * int(ELECcount)\r\n            self.setpanel.elecires = [''] * int(ELECcount)\r\n            self.setpanel.elecvres = [''] * int(ELECcount)\r\n            self.setpanel.eleciv = [''] * int(ELECcount)\r\n            self.setpanel.elecrv = [''] * int(ELECcount)\r\n            self.setpanel.elecpv = [''] * int(ELECcount)\r\n            self.setpanel.elecchannelA = [''] * int(ELECcount)\r\n            self.setpanel.elecchannelB = [''] * int(ELECcount)\r\n            self.setpanel.elecflagholder = [''] * int(ELECcount)\r\n\r\n            for p in range(int(ELECcount)):\r\n                self.setpanel.elecvolt[p] = self.data['Voltsel'][number[p]]\r\n                self.setpanel.eleccurrent[p] = self.data['Currentsel'][number[p]]\r\n                self.setpanel.elecvmax[p] = self.data['VoltMax'][number[p]]\r\n                self.setpanel.elecvmin[p] = self.data['VoltMin'][number[p]]\r\n                self.setpanel.elecimin[p] = self.data['CurrentMin'][number[p]]\r\n                self.setpanel.elecimax[p] = self.data['CurrentMax'][number[p]]\r\n                self.setpanel.elecires[p] = self.data['CurrentRes'][number[p]]\r\n                self.setpanel.elecvres[p] = self.data['VoltRes'][number[p]]\r\n                self.setpanel.eleciv[p] = self.data['IV'][number[p]]\r\n                self.setpanel.elecrv[p] = self.data['RV'][number[p]]\r\n                self.setpanel.elecpv[p] = self.data['PV'][number[p]]\r\n                self.setpanel.elecchannelA[p] = self.data['ChannelA'][number[p]]\r\n                self.setpanel.elecchannelB[p] = self.data['ChannelB'][number[p]]\r\n                self.setpanel.elecflagholder[p] = self.data['ELECflag'][number[p]]\r\n\r\n\r\n            #Optical set################################################################################################\r\n            self.setpanel.routineselectopt.SetItems(optoptions)\r\n            self.setpanel.start = [''] * int(OPTcount)\r\n            self.setpanel.stop = [''] * int(OPTcount)\r\n            self.setpanel.step = [''] * int(OPTcount)\r\n            self.setpanel.sweeppow = [''] * int(OPTcount)\r\n            self.setpanel.sweepsped = [''] * int(OPTcount)\r\n            self.setpanel.laserout = [''] * int(OPTcount)\r\n            self.setpanel.numscans = [''] * int(OPTcount)\r\n            self.setpanel.initialran = [''] * int(OPTcount)\r\n            self.setpanel.rangedecre = [''] * int(OPTcount)\r\n            self.setpanel.opticflagholder = [''] * int(OPTcount)\r\n\r\n            for p in range(int(OPTcount)):\r\n                self.setpanel.start[p] = self.data['Start'][number[p]]\r\n                self.setpanel.stop[p] = self.data['Stop'][number[p]]\r\n                self.setpanel.step[p] = self.data['Stepsize'][number[p]]\r\n                self.setpanel.sweeppow[p] = self.data['Sweeppower'][number[p]]\r\n                self.setpanel.sweepsped[p] = self.data['Sweepspeed'][number[p]]\r\n                self.setpanel.laserout[p] = self.data['Laseroutput'][number[p]]\r\n                self.setpanel.numscans[p] = self.data['Numscans'][number[p]]\r\n                self.setpanel.initialran[p] = self.data['InitialRange'][number[p]]\r\n                self.setpanel.rangedecre[p] = self.data['RangeDec'][number[p]]\r\n                self.setpanel.opticflagholder[p] = self.data['OPTICflag'][number[p]]\r\n\r\n            #Setw set###################################################################################################\r\n            self.setpanel.routineselectsetw.SetItems(setwoptions)\r\n            self.setpanel.setwvolt = [''] * int(SETWcount)\r\n            self.setpanel.setwcurrent = [''] * int(SETWcount)\r\n            self.setpanel.setwvmax = [''] * int(SETWcount)\r\n            self.setpanel.setwvmin = [''] * int(SETWcount)\r\n            self.setpanel.setwimin = [''] * int(SETWcount)\r\n            self.setpanel.setwimax = [''] * int(SETWcount)\r\n            self.setpanel.setwires = [''] * int(SETWcount)\r\n            self.setpanel.setwvres = [''] * int(SETWcount)\r\n            self.setpanel.setwiv = [''] * int(SETWcount)\r\n            self.setpanel.setwrv = [''] * int(SETWcount)\r\n            self.setpanel.setwpv = [''] * int(SETWcount)\r\n            self.setpanel.setwchannelA = [''] * int(SETWcount)\r\n            self.setpanel.setwchannelB = [''] * int(SETWcount)\r\n            self.setpanel.setwwavelengths = [''] * int(SETWcount)\r\n            self.setpanel.setwflagholder = [''] * int(SETWcount)\r\n\r\n            for p in range(int(SETWcount)):\r\n                self.setpanel.setwvolt = self.data['setwVoltsel'][number[p]]\r\n                self.setpanel.setwcurrent = self.data['setwCurrentsel'][number[p]]\r\n                self.setpanel.setwvmax = self.data['setwVoltMax'][number[p]]\r\n                self.setpanel.setwvmin = self.data['setwVoltMin'][number[p]]\r\n                self.setpanel.setwimin = self.data['setwCurrentMin'][number[p]]\r\n                self.setpanel.setwimax = self.data['setwCurrentMax'][number[p]]\r\n                self.setpanel.setwires = self.data['setwCurrentRes'][number[p]]\r\n                self.setpanel.setwvres = self.data['setwVoltRes'][number[p]]\r\n                self.setpanel.setwiv = self.data['setwIV'][number[p]]\r\n                self.setpanel.setwrv = self.data['setwRV'][number[p]]\r\n                self.setpanel.setwpv = self.data['setwPV'][number[p]]\r\n                self.setpanel.setwchannelA = self.data['setwChannelA'][number[p]]\r\n                self.setpanel.setwchannelB = self.data['setwChannelB'][number[p]]\r\n                self.setpanel.setwwavelengths = self.data['Wavelengths'][number[p]]\r\n                self.setpanel.setwflagholder = self.data['setwflag'][number[p]]\r\n\r\n\r\n            #setv set###################################################################################################\r\n            self.setpanel.routineselectsetv.SetItems(setvoptions)\r\n            self.setpanel.setvstart = [''] * int(SETVcount)\r\n            self.setpanel.setvstop = [''] * int(SETVcount)\r\n            self.setpanel.setvstep = [''] * int(SETVcount)\r\n            self.setpanel.setvsweeppow = [''] * int(SETVcount)\r\n            self.setpanel.setvsweepsped = [''] * int(SETVcount)\r\n            self.setpanel.setvlaserout = [''] * int(SETVcount)\r\n            self.setpanel.setvnumscans = [''] * int(SETVcount)\r\n            self.setpanel.setvinitialran = [''] * int(SETVcount)\r\n            self.setpanel.setvrangedecre = [''] * int(SETVcount)\r\n            self.setpanel.setvchannelA = [''] * int(SETVcount)\r\n            self.setpanel.setvchannelB = [''] * int(SETVcount)\r\n            self.setpanel.setvvoltages = [''] * int(SETVcount)\r\n            self.setpanel.setvflagholder = [''] * int(SETVcount)\r\n\r\n            for p in range(int(SETVcount)):\r\n                self.setpanel.setvstart = self.data['setvStart'][number[p]]\r\n                self.setpanel.setvstop = self.data['setvStop'][number[p]]\r\n                self.setpanel.setvstep = self.data['setvStepsize'][number[p]]\r\n                self.setpanel.setvsweeppow = self.data['setvSweeppower'][number[p]]\r\n                self.setpanel.setvsweepsped = self.data['setvSweepspeed'][number[p]]\r\n                self.setpanel.setvlaserout = self.data['setvLaseroutput'][number[p]]\r\n                self.setpanel.setvnumscans = self.data['setvNumscans'][number[p]]\r\n                self.setpanel.setvinitialran = self.data['setvInitialRange'][number[p]]\r\n                self.setpanel.setvrangedecre = self.data['setvChannelB'][number[p]]\r\n                self.setpanel.setvchannelA = self.data['setvChannelB'][number[p]]\r\n                self.setpanel.setvchannelB = self.data['setvChannelB'][number[p]]\r\n                self.setpanel.setvvoltages = self.data['Voltages'][number[p]]\r\n                self.setpanel.setvflagholder = self.data['setvflag'][number[p]]\r\n\r\n\r\n    def checkListunchecked(self, event):\r\n        \"\"\"\r\n        If in set data mode this function removes the now unchecked device from the list of selected devices, if in\r\n        retrieve data mode this function removes the device from the list of selected retrieve data devices and\r\n        unhighlights the similar routine devices\r\n        Parameters\r\n        ----------\r\n        event : the event triggered by unselecting a device in the list\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n        x = event.GetIndex()\r\n        if self.setflag == False and self.retrievedataflag == False:\r\n            self.selected.remove(x)\r\n        elif self.beginning == False and self.end == False and self.retrievedataflag == True:\r\n            self.retrievedataselected.remove(x)\r\n            self.retrieveunhighlight(x)\r\n        elif self.end == True:\r\n            pass\r\n\r\n\r\n    def OnButton_SelectOutputFolder(self, event):\r\n        \"\"\"\r\n        Opens the file explorer and allows user to choose the location to save the exported csv file\r\n        Parameters\r\n        ----------\r\n        event : the event triggered by pressing the \"open\" button to choose the output save location\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n        dirDlg = wx.DirDialog(self, \"Open\", \"\", wx.DD_DEFAULT_STYLE)\r\n        dirDlg.ShowModal()\r\n        self.outputFolderTb.SetValue(dirDlg.GetPath())\r\n        dirDlg.Destroy()\r\n\r\n\r\n    def SetButton(self, event):\r\n        \"\"\"\r\n        This function converts the data input by the user into the various parameter locations and loads it into a\r\n        dictionary that can then be used to either export the data or directly control the equipment\r\n        Parameters\r\n        ----------\r\n        event : the event triggered by pressing the set button\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n\r\n        if self.retrievedataflag == True:\r\n            print('Cannot set data while in retrieve data mode, please change to set data mode to set data')\r\n            return\r\n\r\n        list.sort(self.selected, reverse=True)\r\n        self.setflag = True\r\n        self.routinenum = self.routinenum + 1\r\n\r\n\r\n        self.big = max([self.instructpanel.elecroutine.GetValue(), self.instructpanel.optroutine.GetValue(), self.instructpanel.setwroutine.GetValue(), self.instructpanel.setvroutine.GetValue()])\r\n\r\n        #to ensure all lists are the same length we find the largest list and append blank strings to the other lists until they match the largest string\r\n\r\n        while len(self.setpanel.elecvolt) < int(self.big):\r\n            self.setpanel.elecvolt.append('')\r\n            self.setpanel.eleccurrent.append('')\r\n            self.setpanel.elecvmin.append('')\r\n            self.setpanel.elecvmax.append('')\r\n            self.setpanel.elecimin.append('')\r\n            self.setpanel.elecimax.append('')\r\n            self.setpanel.elecvres.append('')\r\n            self.setpanel.elecires.append('')\r\n            self.setpanel.eleciv.append('')\r\n            self.setpanel.elecrv.append('')\r\n            self.setpanel.elecpv.append('')\r\n            self.setpanel.elecchannelA.append('')\r\n            self.setpanel.elecchannelB.append('')\r\n            self.setpanel.elecflagholder.append('')\r\n\r\n        while len(self.setpanel.start) < int(self.big):\r\n            self.setpanel.start.append('')\r\n            self.setpanel.stop.append('')\r\n            self.setpanel.step.append('')\r\n            self.setpanel.sweeppow.append('')\r\n            self.setpanel.sweepsped.append('')\r\n            self.setpanel.laserout.append('')\r\n            self.setpanel.numscans.append('')\r\n            self.setpanel.initialran.append('')\r\n            self.setpanel.rangedecre.append('')\r\n            self.setpanel.opticflagholder.append('')\r\n\r\n        while len(self.setpanel.setwvolt) < int(self.big):\r\n            self.setpanel.setwvolt.append('')\r\n            self.setpanel.setwcurrent.append('')\r\n            self.setpanel.setwvmin.append('')\r\n            self.setpanel.setwvmax.append('')\r\n            self.setpanel.setwimin.append('')\r\n            self.setpanel.setwimax.append('')\r\n            self.setpanel.setwvres.append('')\r\n            self.setpanel.setwires.append('')\r\n            self.setpanel.setwiv.append('')\r\n            self.setpanel.setwrv.append('')\r\n            self.setpanel.setwpv.append('')\r\n            self.setpanel.setwchannelA.append('')\r\n            self.setpanel.setwchannelB.append('')\r\n            self.setpanel.setwwavelengths.append('')\r\n            self.setpanel.setwflagholder.append('')\r\n\r\n        while len(self.setpanel.setvstart) < int(self.big):\r\n            self.setpanel.setvstart.append('')\r\n            self.setpanel.setvstop.append('')\r\n            self.setpanel.setvstep.append('')\r\n            self.setpanel.setvsweeppow.append('')\r\n            self.setpanel.setvsweepsped.append('')\r\n            self.setpanel.setvlaserout.append('')\r\n            self.setpanel.setvnumscans.append('')\r\n            self.setpanel.setvinitialran.append('')\r\n            self.setpanel.setvrangedecre.append('')\r\n            self.setpanel.setvchannelA.append('')\r\n            self.setpanel.setvchannelB.append('')\r\n            self.setpanel.setvvoltages.append('')\r\n            self.setpanel.setvflagholder.append('')\r\n\r\n\r\n        for c in range(len(self.selected)):\r\n\r\n            save = []\r\n\r\n            for a in range(len(self.data['index'])):\r\n\r\n                if int(self.data['index'][a]) == int(self.selected[c]):\r\n                    save.append(a)\r\n\r\n            list.sort(save, reverse=True)\r\n\r\n            for i in range(len(save)):\r\n                del self.data['device'][save[i]]\r\n                del self.data['index'][save[i]]\r\n                del self.data['Voltsel'][save[i]]\r\n                del self.data['Currentsel'][save[i]]\r\n                del self.data['VoltMin'][save[i]]\r\n                del self.data['VoltMax'][save[i]]\r\n                del self.data['CurrentMin'][save[i]]\r\n                del self.data['CurrentMax'][save[i]]\r\n                del self.data['VoltRes'][save[i]]\r\n                del self.data['CurrentRes'][save[i]]\r\n                del self.data['IV'][save[i]]\r\n                del self.data['RV'][save[i]]\r\n                del self.data['PV'][save[i]]\r\n                del self.data['ChannelA'][save[i]]\r\n                del self.data['ChannelB'][save[i]]\r\n                del self.data['ELECflag'][save[i]]\r\n                del self.data['Start'][save[i]]\r\n                del self.data['Stop'][save[i]]\r\n                del self.data['Stepsize'][save[i]]\r\n                del self.data['Sweeppower'][save[i]]\r\n                del self.data['Sweepspeed'][save[i]]\r\n                del self.data['Laseroutput'][save[i]]\r\n                del self.data['Numscans'][save[i]]\r\n                del self.data['InitialRange'][save[i]]\r\n                del self.data['RangeDec'][save[i]]\r\n                del self.data['OPTICflag'][save[i]]\r\n                del self.data['setwVoltsel'][save[i]]\r\n                del self.data['setwCurrentsel'][save[i]]\r\n                del self.data['setwVoltMin'][save[i]]\r\n                del self.data['setwVoltMax'][save[i]]\r\n                del self.data['setwCurrentMin'][save[i]]\r\n                del self.data['setwCurrentMax'][save[i]]\r\n                del self.data['setwVoltRes'][save[i]]\r\n                del self.data['setwCurrentRes'][save[i]]\r\n                del self.data['setwIV'][save[i]]\r\n                del self.data['setwRV'][save[i]]\r\n                del self.data['setwPV'][save[i]]\r\n                del self.data['setwChannelA'][save[i]]\r\n                del self.data['setwChannelB'][save[i]]\r\n                del self.data['Wavelengths'][save[i]]\r\n                del self.data['setwflag'][save[i]]\r\n                del self.data['setvStart'][save[i]]\r\n                del self.data['setvStop'][save[i]]\r\n                del self.data['setvStepsize'][save[i]]\r\n                del self.data['setvSweeppower'][save[i]]\r\n                del self.data['setvSweepspeed'][save[i]]\r\n                del self.data['setvLaseroutput'][save[i]]\r\n                del self.data['setvNumscans'][save[i]]\r\n                del self.data['setvInitialRange'][save[i]]\r\n                del self.data['setvRangeDec'][save[i]]\r\n                del self.data['setvChannelA'][save[i]]\r\n                del self.data['setvChannelB'][save[i]]\r\n                del self.data['Voltages'][save[i]]\r\n                del self.data['setvflag'][save[i]]\r\n                del self.data['RoutineNumber'][save[i]]\r\n\r\n\r\n            for i in range(int(self.big)):\r\n                self.data['device'].append(self.checkList.GetItemText(int(self.selected[c]), 0))\r\n                self.data['index'].append(int(self.selected[c]))\r\n\r\n            for i in range(int(self.big)):\r\n\r\n                self.data['Voltsel'].append(self.setpanel.elecvolt[i])\r\n                self.data['Currentsel'].append(self.setpanel.eleccurrent[i])\r\n                self.data['VoltMin'].append(self.setpanel.elecvmin[i])\r\n                self.data['VoltMax'].append(self.setpanel.elecvmax[i])\r\n                self.data['CurrentMin'].append(self.setpanel.elecimin[i])\r\n                self.data['CurrentMax'].append(self.setpanel.elecimax[i])\r\n                self.data['VoltRes'].append(self.setpanel.elecvres[i])\r\n                self.data['CurrentRes'].append(self.setpanel.elecires[i])\r\n                self.data['IV'].append(self.setpanel.eleciv[i])\r\n                self.data['RV'].append(self.setpanel.elecrv[i])\r\n                self.data['PV'].append(self.setpanel.elecpv[i])\r\n                self.data['ChannelA'].append(self.setpanel.elecchannelA[i])\r\n                self.data['ChannelB'].append(self.setpanel.elecchannelB[i])\r\n                self.data['ELECflag'].append(self.setpanel.elecflagholder[i])\r\n\r\n\r\n            for i in range(int(self.big)):\r\n\r\n                self.data['Start'].append(self.setpanel.start[i])\r\n                self.data['Stop'].append(self.setpanel.stop[i])\r\n                self.data['Stepsize'].append(self.setpanel.step[i])\r\n                self.data['Sweeppower'].append(self.setpanel.sweeppow[i])\r\n                self.data['Sweepspeed'].append(self.setpanel.sweepsped[i])\r\n                self.data['Laseroutput'].append(self.setpanel.laserout[i])\r\n                self.data['Numscans'].append(self.setpanel.numscans[i])\r\n                self.data['InitialRange'].append(self.setpanel.initialran[i])\r\n                self.data['RangeDec'].append(self.setpanel.rangedecre[i])\r\n                self.data['OPTICflag'].append(self.setpanel.opticflagholder[i])\r\n\r\n            for i in range(int(self.big)):\r\n\r\n                self.data['setwVoltsel'].append(self.setpanel.setwvolt[i])\r\n                self.data['setwCurrentsel'].append(self.setpanel.setwcurrent[i])\r\n                self.data['setwVoltMin'].append(self.setpanel.setwvmin[i])\r\n                self.data['setwVoltMax'].append(self.setpanel.setwvmax[i])\r\n                self.data['setwCurrentMin'].append(self.setpanel.setwimin[i])\r\n                self.data['setwCurrentMax'].append(self.setpanel.setwimax[i])\r\n                self.data['setwVoltRes'].append(self.setpanel.setwvres[i])\r\n                self.data['setwCurrentRes'].append(self.setpanel.setwires[i])\r\n                self.data['setwIV'].append(self.setpanel.setwiv[i])\r\n                self.data['setwRV'].append(self.setpanel.setwrv[i])\r\n                self.data['setwPV'].append(self.setpanel.setwpv[i])\r\n                self.data['setwChannelA'].append(self.setpanel.setwchannelA[i])\r\n                self.data['setwChannelB'].append(self.setpanel.setwchannelB[i])\r\n                self.data['Wavelengths'].append(self.setpanel.setwwavelengths[i])\r\n                self.data['setwflag'].append(self.setpanel.setwflagholder[i])\r\n\r\n            for i in range(int(self.big)):\r\n\r\n                self.data['setvStart'].append(self.setpanel.setvstart[i])\r\n                self.data['setvStop'].append(self.setpanel.setvstop[i])\r\n                self.data['setvStepsize'].append(self.setpanel.setvstep[i])\r\n                self.data['setvSweeppower'].append(self.setpanel.setvsweeppow[i])\r\n                self.data['setvSweepspeed'].append(self.setpanel.setvsweepsped[i])\r\n                self.data['setvLaseroutput'].append(self.setpanel.setvlaserout[i])\r\n                self.data['setvNumscans'].append(self.setpanel.setvnumscans[i])\r\n                self.data['setvInitialRange'].append(self.setpanel.setvinitialran[i])\r\n                self.data['setvRangeDec'].append(self.setpanel.setvrangedecre[i])\r\n                self.data['setvChannelA'].append(self.setpanel.setvchannelA[i])\r\n                self.data['setvChannelB'].append(self.setpanel.setvchannelB[i])\r\n                self.data['Voltages'].append(self.setpanel.setvvoltages[i])\r\n                self.data['setvflag'].append(self.setpanel.setvflagholder[i])\r\n\r\n            self.checkList.SetItemTextColour(self.selected[c], wx.Colour(211, 211, 211))\r\n            self.checkList.SetItemBackgroundColour(c, wx.Colour(255, 255, 255))\r\n            self.checkList.CheckItem(self.selected[c], False)\r\n            self.set[self.selected[c]] = True\r\n\r\n            print('Testing parameters for ' + self.checkList.GetItemText(self.selected[c], 0) + ' set')\r\n\r\n        for c in range(int(len(self.selected))*int(self.big)):\r\n            self.data['RoutineNumber'].append(self.routinenum)\r\n\r\n        self.selected = []\r\n        self.setflag = False\r\n        self.setpanel.elecvolt = []\r\n        self.setpanel.eleccurrent = []\r\n        self.setpanel.elecvmax = []\r\n        self.setpanel.elecvmin = []\r\n        self.setpanel.elecimin = []\r\n        self.setpanel.elecimax = []\r\n        self.setpanel.elecires = []\r\n        self.setpanel.elecvres = []\r\n        self.setpanel.eleciv = []\r\n        self.setpanel.elecrv = []\r\n        self.setpanel.elecpv = []\r\n        self.setpanel.elecchannelA = []\r\n        self.setpanel.elecchannelB = []\r\n        self.setpanel.elecflagholder = []\r\n\r\n        self.setpanel.start = []\r\n        self.setpanel.stop = []\r\n        self.setpanel.step = []\r\n        self.setpanel.sweeppow = []\r\n        self.setpanel.sweepsped = []\r\n        self.setpanel.laserout = []\r\n        self.setpanel.numscans = []\r\n        self.setpanel.initialran = []\r\n        self.setpanel.rangedecre = []\r\n        self.setpanel.opticflagholder = []\r\n\r\n        self.setpanel.setwvolt = []\r\n        self.setpanel.setwcurrent = []\r\n        self.setpanel.setwvmax = []\r\n        self.setpanel.setwvmin = []\r\n        self.setpanel.setwimin = []\r\n        self.setpanel.setwimax = []\r\n        self.setpanel.setwires = []\r\n        self.setpanel.setwvres = []\r\n        self.setpanel.setwiv = []\r\n        self.setpanel.setwrv = []\r\n        self.setpanel.setwpv = []\r\n        self.setpanel.setwchannelA = []\r\n        self.setpanel.setwchannelB = []\r\n        self.setpanel.setwwavelengths = []\r\n        self.setpanel.setwflagholder = []\r\n\r\n        self.setpanel.setvstart = []\r\n        self.setpanel.setvstop = []\r\n        self.setpanel.setvstep = []\r\n        self.setpanel.setvsweeppow = []\r\n        self.setpanel.setvsweepsped = []\r\n        self.setpanel.setvlaserout = []\r\n        self.setpanel.setvnumscans = []\r\n        self.setpanel.setvinitialran = []\r\n        self.setpanel.setvrangedecre = []\r\n        self.setpanel.setvvoltages = []\r\n        self.setpanel.setvchannelA = []\r\n        self.setpanel.setvchannelB = []\r\n        self.setpanel.setvflagholder = []\r\n\r\n        optionsblank = []\r\n\r\n        self.setpanel.routineselectelec.SetItems(optionsblank)\r\n        self.setpanel.routineselectopt.SetItems(optionsblank)\r\n        self.setpanel.routineselectsetw.SetItems(optionsblank)\r\n        self.setpanel.routineselectsetv.SetItems(optionsblank)\r\n\r\n        self.instructpanel.elecroutine.SetValue('')\r\n        self.instructpanel.optroutine.SetValue('')\r\n        self.instructpanel.setwroutine.SetValue('')\r\n        self.instructpanel.setvroutine.SetValue('')\r\n\r\n        #reset electrical panel parameters\r\n        self.setpanel.voltsel.SetValue(False)\r\n        self.setpanel.currentsel.SetValue(False)\r\n        self.setpanel.maxsetvoltage.SetValue('')\r\n        self.setpanel.maxsetcurrent.SetValue('')\r\n        self.setpanel.minsetvoltage.SetValue('')\r\n        self.setpanel.minsetcurrent.SetValue('')\r\n        self.setpanel.resovoltage.SetValue('')\r\n        self.setpanel.resocurrent.SetValue('')\r\n        self.setpanel.typesel.SetValue(False)\r\n        self.setpanel.type2sel.SetValue(False)\r\n        self.setpanel.type3sel.SetValue(False)\r\n        self.setpanel.Asel.SetValue(True)\r\n        self.setpanel.Bsel.SetValue(False)\r\n\r\n        # reset optical panel parameters\r\n        self.setpanel.startWvlTc.SetValue('')\r\n        self.setpanel.stopWvlTc.SetValue('')\r\n        self.setpanel.stepWvlTc.SetValue('')\r\n        self.setpanel.sweepPowerTc.SetValue('')\r\n        self.setpanel.sweepinitialrangeTc.SetValue('')\r\n        self.setpanel.rangedecTc.SetValue('')\r\n\r\n        # reset setv panel parameters\r\n        self.setpanel.startWvlTc2.SetValue('')\r\n        self.setpanel.stopWvlTc2.SetValue('')\r\n        self.setpanel.stepWvlTc2.SetValue('')\r\n        self.setpanel.sweepPowerTc2.SetValue('')\r\n        self.setpanel.sweepinitialrangeTc2.SetValue('')\r\n        self.setpanel.rangedecTc2.SetValue('')\r\n        self.setpanel.voltagesetTc2.SetValue('')\r\n\r\n        # reset setw panel parameters\r\n        self.setpanel.voltsel2.SetValue(False)\r\n        self.setpanel.currentsel2.SetValue(False)\r\n        self.setpanel.maxsetvoltage2.SetValue('')\r\n        self.setpanel.maxsetcurrent2.SetValue('')\r\n        self.setpanel.minsetvoltage2.SetValue('')\r\n        self.setpanel.minsetcurrent2.SetValue('')\r\n        self.setpanel.resovoltage2.SetValue('')\r\n        self.setpanel.resocurrent2.SetValue('')\r\n        self.setpanel.typesel2.SetValue(False)\r\n        self.setpanel.type2sel2.SetValue(False)\r\n        self.setpanel.type3sel2.SetValue(False)\r\n        self.setpanel.Asel2.SetValue(True)\r\n        self.setpanel.Bsel2.SetValue(False)\r\n        self.setpanel.wavesetTc2.SetValue('')\r\n\r\n        #if want to see items in dictionary uncommment code below\r\n        #for keys, values in self.data.items():\r\n         #   print(keys)\r\n          #  print(values)\r\n\r\n        print('Data has been set')\r\n\r\n\r\n    def ExportButton(self, event):\r\n        \"\"\"\r\n        This function takes the data contained in the data dictionary and formats it into a csv file\r\n        Parameters\r\n        ----------\r\n        event : The event triggered by clicking the export button\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n\r\n        ROOT_DIR = format(os.getcwd())\r\n        primarysavefile = ROOT_DIR + '\\TestParameters.csv'\r\n\r\n        with open(primarysavefile, 'w', newline='') as f:\r\n            f.write(',,,,,,,,,,,,,,,,\\n')\r\n            f.write(',,,,,,IV Sweep,,,,,,,,,,,,,Optical Sweep,,,,,,,,,Set Wavelength,,,,,,,,,,,,,,SetVoltage\\n')\r\n            f.write('RoutineNumber, Device ID, ELECFlag, OPTICflag, setwflag, setvflag, Volt Select, Current Select,'\r\n                    ' Volt Min,Volt Max,Current Min,Current Max,Volt Resolution,Current Resolution,IV/VI,RV/RI,PV/PI, '\r\n                    'Channel A, Channel B,Start,Stop,Stepsize,Sweep power,Sweep speed,Laser Output,Number of scans,'\r\n                    ' Initial Range, Range Dec, Volt Select, Current Select, Volt Min,Volt Max,Current Min,Current Max,'\r\n                    'Volt Resolution,Current Resolution,IV/VI,RV/RI,PV/PI, Channel A, Channel B, Wavelength, Start, Stop,'\r\n                    ' Stepsize, Sweep power,Sweep speed,Laser Output,Number of scans, Initial Range, Range Dec,'\r\n                    ' Channel A, Channel B, Voltages \\n')\r\n\r\n            for c in range(len(self.data['device'])):\r\n                f.write(str(self.data['RoutineNumber'][c]) + ',' + str(self.data['device'][c]) + ',' + str(\r\n                    self.data['ELECflag'][c]) + ',' + str(self.data['OPTICflag'][c]) + ',' + str(\r\n                    self.data['setwflag'][c]) + ',' + str(self.data['setvflag'][c]) + ',' + str(\r\n                    self.data['Voltsel'][c]) + ',' + str(self.data['Currentsel'][c]) + ',' + str(\r\n                    self.data['VoltMin'][c]) + ',' + str(self.data['VoltMax'][c])\r\n                        + ',' + str(self.data['CurrentMin'][c]) + ',' + str(self.data['CurrentMax'][c]) + ',' +\r\n                        str(self.data['VoltRes'][c]) + ',' + str(self.data['CurrentRes'][c]) + ',' + str(\r\n                    self.data['IV'][c]) + ','\r\n                        + str(self.data['RV'][c]) + ',' + str(self.data['PV'][c]) + ',' + str(\r\n                    self.data['ChannelA'][c]) + ',' + str(self.data['ChannelB'][c]) + ',' + str(\r\n                    self.data['Start'][c]) + ','\r\n                        + str(self.data['Stop'][c]) + ',' + str(self.data['Stepsize'][c]) + ',' + str(\r\n                    self.data['Sweeppower'][c])\r\n                        + ',' + str(self.data['Sweepspeed'][c]) + ',' + str(self.data['Laseroutput'][c]) + ','\r\n                        + str(self.data['Numscans'][c]) + ',' + str(self.data['InitialRange'][c]) + ',' + str(\r\n                    self.data['RangeDec'][c]) + ',' + str(self.data['setwVoltsel'][c]) + ',' + str(\r\n                    self.data['setwCurrentsel'][c]) + ',' + str(self.data['setwVoltMin'][c]) + ',' + str(\r\n                    self.data['setwVoltMax'][c])\r\n                        + ',' + str(self.data['setwCurrentMin'][c]) + ',' + str(self.data['setwCurrentMax'][c]) + ',' +\r\n                        str(self.data['setwVoltRes'][c]) + ',' + str(self.data['setwCurrentRes'][c]) + ',' + str(\r\n                    self.data['setwIV'][c]) + ','\r\n                        + str(self.data['setwRV'][c]) + ',' + str(self.data['setwPV'][c]) + ',' + str(\r\n                    self.data['setwChannelA'][c]) + ',' + str(self.data['setwChannelB'][c]) + ',' + str(\r\n                    self.data['Wavelengths'][c]) + ',' + str(self.data['setvStart'][c]) + ','\r\n                        + str(self.data['setvStop'][c]) + ',' + str(self.data['setvStepsize'][c]) + ',' + str(\r\n                    self.data['setvSweeppower'][c])\r\n                        + ',' + str(self.data['setvSweepspeed'][c]) + ',' + str(self.data['setvLaseroutput'][c]) + ','\r\n                        + str(self.data['setvNumscans'][c]) + ',' + str(self.data['setvInitialRange'][c]) + ',' + str(\r\n                    self.data['setvRangeDec'][c]) + ',' + str(self.data['setvChannelA'][c]) + ',' + str(\r\n                    self.data['setvChannelB'][c]) + ',' + str(self.data['Voltages'][c]) + ',' + '\\n')\r\n\r\n        if self.outputFolderTb.GetValue() != '':\r\n\r\n            savelocation = self.outputFolderTb.GetValue()\r\n            savefile = savelocation + '/TestingParameters.csv'\r\n            savefilestring = savelocation + '\\TestingParameters.csv'\r\n\r\n            with open(savefile, 'w', newline='') as f:\r\n                f.write(',,,,,,,,,,,,,,,,\\n')\r\n                f.write(',,,,,,IV Sweep,,,,,,,,,,,,,Optical Sweep,,,,,,,,,Set Wavelength,,,,,,,,,,,,,,SetVoltage\\n')\r\n                f.write('RoutineNumber, Device ID, ELECFlag, OPTICflag, setwflag, setvflag, Volt Select,'\r\n                        ' Current Select, Volt Min,Volt Max,Current Min,Current Max,Volt Resolution,Current Resolution,'\r\n                        'IV/VI,RV/RI,PV/PI, Channel A, Channel B,Start,Stop,Stepsize,Sweep power,Sweep speed,'\r\n                        'Laser Output,Number of scans, Initial Range, Range Dec, Volt Select, Current Select, Volt Min,'\r\n                        'Volt Max,Current Min,Current Max,Volt Resolution,Current Resolution,IV/VI,RV/RI,PV/PI,'\r\n                        ' Channel A, Channel B, Wavelength, Start, Stop, Stepsize, Sweep power,Sweep speed,Laser Output,'\r\n                        'Number of scans, Initial Range, Range Dec, Channel A, Channel B, Voltages \\n')\r\n\r\n                for c in range(len(self.data['device'])):\r\n\r\n                    f.write(str(self.data['RoutineNumber'][c]) + ',' + str(self.data['device'][c]) + ',' +\r\n                            str(self.data['ELECflag'][c]) + ',' + str(self.data['OPTICflag'][c]) + ',' +\r\n                            str(self.data['setwflag'][c]) + ',' + str(self.data['setvflag'][c]) + ',' +\r\n                            str(self.data['Voltsel'][c]) + ',' + str(self.data['Currentsel'][c]) + ',' +\r\n                            str(self.data['VoltMin'][c]) + ',' + str(self.data['VoltMax'][c])\r\n                            + ',' + str(self.data['CurrentMin'][c]) + ',' + str(self.data['CurrentMax'][c]) + ',' +\r\n                            str(self.data['VoltRes'][c]) + ',' + str(self.data['CurrentRes'][c]) + ',' +\r\n                            str(self.data['IV'][c]) + ',' + str(self.data['RV'][c]) + ',' + str(self.data['PV'][c]) +\r\n                            ',' + str(self.data['ChannelA'][c]) + ',' + str(self.data['ChannelB'][c]) + ',' +\r\n                            str(self.data['Start'][c]) + ',' + str(self.data['Stop'][c]) + ',' +\r\n                            str(self.data['Stepsize'][c]) + ',' + str(self.data['Sweeppower'][c]) + ',' +\r\n                            str(self.data['Sweepspeed'][c]) + ',' + str(self.data['Laseroutput'][c]) + ',' +\r\n                            str(self.data['Numscans'][c]) + ',' + str(self.data['InitialRange'][c]) + ',' +\r\n                            str(self.data['RangeDec'][c]) + ',' + str(self.data['setwVoltsel'][c]) + ',' +\r\n                            str(self.data['setwCurrentsel'][c]) + ',' + str(self.data['setwVoltMin'][c]) + ',' +\r\n                            str(self.data['setwVoltMax'][c]) + ',' + str(self.data['setwCurrentMin'][c]) + ',' +\r\n                            str(self.data['setwCurrentMax'][c]) + ',' + str(self.data['setwVoltRes'][c]) + ',' +\r\n                            str(self.data['setwCurrentRes'][c]) + ',' + str(self.data['setwIV'][c]) + ',' +\r\n                            str(self.data['setwRV'][c]) + ',' + str(self.data['setwPV'][c]) + ',' +\r\n                            str(self.data['setwChannelA'][c]) + ',' + str(self.data['setwChannelB'][c]) + ',' +\r\n                            str(self.data['Wavelengths'][c]) + ',' + str(self.data['setvStart'][c]) + ',' +\r\n                            str(self.data['setvStop'][c]) + ',' + str(self.data['setvStepsize'][c]) + ',' +\r\n                            str(self.data['setvSweeppower'][c]) + ',' + str(self.data['setvSweepspeed'][c]) + ',' +\r\n                            str(self.data['setvLaseroutput'][c]) + ',' + str(self.data['setvNumscans'][c]) + ',' +\r\n                            str(self.data['setvInitialRange'][c]) + ',' + str(self.data['setvRangeDec'][c]) + ',' +\r\n                            str(self.data['setvChannelA'][c]) + ',' + str(self.data['setvChannelB'][c]) + ',' +\r\n                            str(self.data['Voltages'][c]) + ',' + '\\n')\r\n                print('Data exported to ' + savefilestring)\r\n\r\n\r\n#This panel class contains the instructions for going about inputting the routine data for the devices as well as the\r\n#selection menu for the number of different routines\r\nclass InstructPanel(wx.Panel):\r\n\r\n    def __init__(self, parent, setpanel):\r\n        super(InstructPanel, self).__init__(parent)\r\n        self.setpanel = setpanel\r\n        self.InitUI()\r\n\r\n\r\n    def InitUI(self):\r\n\r\n        # INSTRUCTIONS###################################################################################################\r\n\r\n        sbw = wx.StaticBox(self, label='Instructions')\r\n        instructions = wx.StaticBoxSizer(sbw, wx.VERTICAL)\r\n\r\n        # create sizers and text for instructions\r\n        steps = wx.BoxSizer(wx.VERTICAL)\r\n        step1 = wx.BoxSizer(wx.HORIZONTAL)\r\n        stp1 = wx.StaticText(self, label='1. Upload automated test coordinate file')\r\n        step1.Add(stp1, 1, wx.EXPAND)\r\n\r\n        step1_5 = wx.BoxSizer(wx.HORIZONTAL)\r\n        stp1_5 = wx.StaticText(self, label='coordinate file')\r\n        step1_5.Add(stp1_5, 1, wx.EXPAND)\r\n\r\n        step2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        stp2 = wx.StaticText(self, label='2. Select devices you wish to create routines for')\r\n        step2.Add(stp2, 1, wx.EXPAND)\r\n\r\n        step2_5 = wx.BoxSizer(wx.HORIZONTAL)\r\n        stp2_5 = wx.StaticText(self, label='create routines for')\r\n        step2_5.Add(stp2_5, 1, wx.EXPAND)\r\n\r\n        step3 = wx.BoxSizer(wx.HORIZONTAL)\r\n        stp3 = wx.StaticText(self, label='3. Select number of routines per type of routine')\r\n        step3.Add(stp3, 1, wx.EXPAND)\r\n\r\n        step3_5 = wx.BoxSizer(wx.HORIZONTAL)\r\n        stp3_5 = wx.StaticText(self, label='per type of routine')\r\n        step3_5.Add(stp3_5, 1, wx.EXPAND)\r\n\r\n        step4 = wx.BoxSizer(wx.HORIZONTAL)\r\n        stp4 = wx.StaticText(self, label='4. Fill in routine data')\r\n        step4.Add(stp4, 1, wx.EXPAND)\r\n\r\n        step5 = wx.BoxSizer(wx.HORIZONTAL)\r\n        stp5 = wx.StaticText(self, label='5. Click set button')\r\n        step5.Add(stp5, 1, wx.EXPAND)\r\n\r\n        step6 = wx.BoxSizer(wx.HORIZONTAL)\r\n        stp6 = wx.StaticText(self, label='6. Repeat from step 2')\r\n        step6.Add(stp6, 1, wx.EXPAND)\r\n\r\n        # format steps\r\n        steps.AddMany([(step1, 1, wx.EXPAND), (step1_5, 1, wx.EXPAND), (step2, 1, wx.EXPAND), (step2_5, 1, wx.EXPAND), (step3, 1, wx.EXPAND), (step3_5, 1, wx.EXPAND), (step4, 1, wx.EXPAND),\r\n                       (step5, 1, wx.EXPAND), (step6, 1, wx.EXPAND)])\r\n        instructions.Add(steps, 1, wx.EXPAND)\r\n\r\n        # NUMBER OF ROUTINES SELECTION###################################################################################\r\n\r\n        # create general sizer for routine selection\r\n        sb1_3 = wx.StaticBox(self, label='Routine Select')\r\n        routineselect = wx.StaticBoxSizer(sb1_3, wx.VERTICAL)\r\n\r\n        # Electrical, set number of routines selection\r\n        electricalroutine = wx.BoxSizer(wx.HORIZONTAL)\r\n        st10_2 = wx.StaticText(self, label='Electrical Routine')\r\n        self.elecroutine = wx.TextCtrl(self, size=(40, 20))\r\n        self.elecroutine.name = 'elecroutine'\r\n        self.elecroutine.SetValue('0')\r\n        self.elecroutine.Bind(wx.EVT_TEXT, self.setnumroutine)\r\n        electricalroutine.AddMany([(st10_2, 1, wx.EXPAND), (self.elecroutine, 0)])\r\n\r\n        # Optical, set number of routines selection\r\n        opticalroutine = wx.BoxSizer(wx.HORIZONTAL)\r\n        st11_2 = wx.StaticText(self, label='Optical Routine')\r\n        self.optroutine = wx.TextCtrl(self, size=(40, 20))\r\n        self.optroutine.name = 'optroutine'\r\n        self.optroutine.SetValue('0')\r\n        self.optroutine.Bind(wx.EVT_TEXT, self.setnumroutine)\r\n        opticalroutine.AddMany([(st11_2, 1, wx.EXPAND), (self.optroutine, 0)])\r\n\r\n        # Set voltage, wavelength sweep, set number of routines selection\r\n        setvwsweeproutine = wx.BoxSizer(wx.HORIZONTAL)\r\n        st12_2 = wx.StaticText(self, label='Set Voltage')\r\n        self.setvroutine = wx.TextCtrl(self, size=(40, 20))\r\n        self.setvroutine.name = 'setvroutine'\r\n        self.setvroutine.SetValue('0')\r\n        self.setvroutine.Bind(wx.EVT_TEXT, self.setnumroutine)\r\n        setvwsweeproutine.AddMany([(st12_2, 1, wx.EXPAND), (self.setvroutine, 0)])\r\n\r\n        # Set wavelength, voltage sweep, set number of routines selection\r\n        setwvsweeproutine = wx.BoxSizer(wx.HORIZONTAL)\r\n        st13_2 = wx.StaticText(self, label='Set Wavelength')\r\n        self.setwroutine = wx.TextCtrl(self, size=(40, 20))\r\n        self.setwroutine.name = 'setwroutine'\r\n        self.setwroutine.SetValue('0')\r\n        self.setwroutine.Bind(wx.EVT_TEXT, self.setnumroutine)\r\n        setwvsweeproutine.AddMany([(st13_2, 1, wx.EXPAND), (self.setwroutine)])\r\n\r\n        # format routine selection sizers\r\n        routineselect.AddMany(\r\n            [(instructions, 0, wx.EXPAND), (electricalroutine, 0, wx.EXPAND), (opticalroutine, 0, wx.EXPAND),\r\n             (setvwsweeproutine, 0, wx.EXPAND), (setwvsweeproutine, 0, wx.EXPAND)])\r\n\r\n        self.SetSizer(routineselect)\r\n\r\n\r\n    def setnumroutine(self, event):\r\n        \"\"\"\r\n        Based on the input for number of different routines this function will create lists for each routine with\r\n        the length equal to the number of routines input\r\n        :param event: the event created on input of number into number of routine menu\r\n        Parameters\r\n        ----------\r\n        event : the event triggered on input of number into number of routine menu\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n        c = event.GetEventObject()\r\n\r\n        optionsblank = []\r\n\r\n        if c.GetValue().isdigit() != True and c.GetValue() != '':\r\n            c.SetValue('')\r\n            print('Routine number must be a positive integer')\r\n            return\r\n\r\n        if c.GetValue() != '':\r\n            options = []\r\n            for x in range(int(c.GetValue())):\r\n                x = x + 1\r\n                options.append(str(x))\r\n\r\n            if c.name == 'elecroutine':\r\n                self.setpanel.routineselectelec.SetItems(options)\r\n                self.setpanel.elecvolt = [''] * int(c.GetValue())\r\n                self.setpanel.eleccurrent = [''] * int(c.GetValue())\r\n                self.setpanel.elecvmax = [''] * int(c.GetValue())\r\n                self.setpanel.elecvmin = ['']* int(c.GetValue())\r\n                self.setpanel.elecimin = [''] * int(c.GetValue())\r\n                self.setpanel.elecimax = [''] * int(c.GetValue())\r\n                self.setpanel.elecires = [''] * int(c.GetValue())\r\n                self.setpanel.elecvres = [''] * int(c.GetValue())\r\n                self.setpanel.eleciv = [''] * int(c.GetValue())\r\n                self.setpanel.elecrv = [''] * int(c.GetValue())\r\n                self.setpanel.elecpv = [''] * int(c.GetValue())\r\n                self.setpanel.elecchannelA = [''] * int(c.GetValue())\r\n                self.setpanel.elecchannelB = [''] * int(c.GetValue())\r\n                self.setpanel.elecflagholder = [''] * int(c.GetValue())\r\n\r\n            if c.name == 'optroutine':\r\n                self.setpanel.routineselectopt.SetItems(options)\r\n                self.setpanel.start = [''] * int(c.GetValue())\r\n                self.setpanel.stop = [''] * int(c.GetValue())\r\n                self.setpanel.step = [''] * int(c.GetValue())\r\n                self.setpanel.sweeppow = [''] * int(c.GetValue())\r\n                self.setpanel.sweepsped = [''] * int(c.GetValue())\r\n                self.setpanel.laserout = [''] * int(c.GetValue())\r\n                self.setpanel.numscans = [''] * int(c.GetValue())\r\n                self.setpanel.initialran = [''] * int(c.GetValue())\r\n                self.setpanel.rangedecre = [''] * int(c.GetValue())\r\n                self.setpanel.opticflagholder = [''] * int(c.GetValue())\r\n\r\n            if c.name == 'setwroutine':\r\n                self.setpanel.routineselectsetw.SetItems(options)\r\n                self.setpanel.setwvolt = [''] * int(c.GetValue())\r\n                self.setpanel.setwcurrent = [''] * int(c.GetValue())\r\n                self.setpanel.setwvmax = [''] * int(c.GetValue())\r\n                self.setpanel.setwvmin = [''] * int(c.GetValue())\r\n                self.setpanel.setwimin = [''] * int(c.GetValue())\r\n                self.setpanel.setwimax = [''] * int(c.GetValue())\r\n                self.setpanel.setwires = [''] * int(c.GetValue())\r\n                self.setpanel.setwvres = [''] * int(c.GetValue())\r\n                self.setpanel.setwiv = [''] * int(c.GetValue())\r\n                self.setpanel.setwrv = [''] * int(c.GetValue())\r\n                self.setpanel.setwpv = [''] * int(c.GetValue())\r\n                self.setpanel.setwchannelA = [''] * int(c.GetValue())\r\n                self.setpanel.setwchannelB = [''] * int(c.GetValue())\r\n                self.setpanel.setwwavelengths = [''] * int(c.GetValue())\r\n                self.setpanel.setwflagholder = [''] * int(c.GetValue())\r\n\r\n            if c.name == 'setvroutine':\r\n                self.setpanel.routineselectsetv.SetItems(options)\r\n                self.setpanel.setvstart = [''] * int(c.GetValue())\r\n                self.setpanel.setvstop = [''] * int(c.GetValue())\r\n                self.setpanel.setvstep = [''] * int(c.GetValue())\r\n                self.setpanel.setvsweeppow = [''] * int(c.GetValue())\r\n                self.setpanel.setvsweepsped = [''] * int(c.GetValue())\r\n                self.setpanel.setvlaserout = [''] * int(c.GetValue())\r\n                self.setpanel.setvnumscans = [''] * int(c.GetValue())\r\n                self.setpanel.setvinitialran = [''] * int(c.GetValue())\r\n                self.setpanel.setvrangedecre = [''] * int(c.GetValue())\r\n                self.setpanel.setvchannelA = [''] * int(c.GetValue())\r\n                self.setpanel.setvchannelB = [''] * int(c.GetValue())\r\n                self.setpanel.setvvoltages = [''] * int(c.GetValue())\r\n                self.setpanel.setvflagholder = [''] * int(c.GetValue())\r\n\r\n        if c.GetValue() == '':\r\n            if c.name == 'elecroutine':\r\n                self.setpanel.routineselectelec.SetItems(optionsblank)\r\n            if c.name == 'optroutine':\r\n                self.setpanel.routineselectopt.SetItems(optionsblank)\r\n            if c.name == 'setwroutine':\r\n                self.setpanel.routineselectsetw.SetItems(optionsblank)\r\n            if c.name == 'setvroutine':\r\n                self.setpanel.routineselectsetv.SetItems(optionsblank)\r\n\r\n\r\n#the Panel responsible for the user input of parameters\r\nclass SetPanel(wx.Panel):\r\n\r\n    def __init__(self, parent):\r\n        super(SetPanel, self).__init__(parent)\r\n        self.elecvolt = []\r\n        self.eleccurrent = []\r\n        self.elecvmax = []\r\n        self.elecvmin = []\r\n        self.elecimin = []\r\n        self.elecimax = []\r\n        self.elecires = []\r\n        self.elecvres = []\r\n        self.eleciv = []\r\n        self.elecrv = []\r\n        self.elecpv = []\r\n        self.elecchannelA = []\r\n        self.elecchannelB = []\r\n        self.elecflagholder = []\r\n\r\n        self.start = []\r\n        self.stop = []\r\n        self.step = []\r\n        self.sweeppow = []\r\n        self.sweepsped = []\r\n        self.laserout = []\r\n        self.numscans = []\r\n        self.initialran = []\r\n        self.rangedecre = []\r\n        self.opticflagholder = []\r\n\r\n        self.setwvolt = []\r\n        self.setwcurrent = []\r\n        self.setwvmax = []\r\n        self.setwvmin = []\r\n        self.setwimin = []\r\n        self.setwimax = []\r\n        self.setwires = []\r\n        self.setwvres = []\r\n        self.setwiv = []\r\n        self.setwrv = []\r\n        self.setwpv = []\r\n        self.setwchannelA = []\r\n        self.setwchannelB = []\r\n        self.setwwavelengths = []\r\n        self.setwflagholder = []\r\n\r\n        self.setvstart = []\r\n        self.setvstop = []\r\n        self.setvstep = []\r\n        self.setvsweeppow = []\r\n        self.setvsweepsped = []\r\n        self.setvlaserout = []\r\n        self.setvnumscans = []\r\n        self.setvinitialran = []\r\n        self.setvrangedecre = []\r\n        self.setvvoltages = []\r\n        self.setvchannelA = []\r\n        self.setvchannelB = []\r\n        self.setvflagholder = []\r\n        self.InitUI()\r\n\r\n\r\n    def InitUI(self):\r\n\r\n        ##CREATE ELECTRICAL PANEL#######################################################################################\r\n\r\n        #create electrical panel sizer and necessary vboxes and hboxes\r\n        sb = wx.StaticBox(self, label='Electrical')\r\n        elecvbox = wx.StaticBoxSizer(sb, wx.VERTICAL)\r\n        hbox = wx.BoxSizer(wx.HORIZONTAL)\r\n        evbox = wx.BoxSizer(wx.VERTICAL)\r\n        tophbox = wx.BoxSizer(wx.HORIZONTAL)\r\n\r\n        #Electrical routine selection tab\r\n        hbox0 = wx.BoxSizer(wx.HORIZONTAL)\r\n        sq0_1 = wx.StaticText(self, label='Select Routine ')\r\n        options = []\r\n        self.routineselectelec = wx.ComboBox(self, choices=options, style=wx.CB_READONLY, value='1')\r\n        self.routineselectelec.name = 'routineselectelec'\r\n        self.routineselectelec.Bind(wx.EVT_COMBOBOX_DROPDOWN, self.routinepanel)\r\n        self.routineselectelec.Bind(wx.EVT_COMBOBOX, self.swaproutine)\r\n        hbox0.AddMany([(sq0_1, 1, wx.EXPAND), (self.routineselectelec, 1, wx.EXPAND)])\r\n\r\n        #Independent Variable selection\r\n        hbox1 = wx.BoxSizer(wx.HORIZONTAL)\r\n        sq1_1 = wx.StaticText(self, label='Select Independent Variable: ')\r\n        self.voltsel = wx.CheckBox(self, label='Voltage', pos=(20, 20))\r\n        self.voltsel.SetValue(False)\r\n        self.voltsel.Bind(wx.EVT_CHECKBOX, self.trueorfalse)\r\n        self.currentsel = wx.CheckBox(self, label='Current', pos=(20, 20))\r\n        self.currentsel.SetValue(False)\r\n        self.currentsel.Bind(wx.EVT_CHECKBOX, self.trueorfalse)\r\n        hbox1.AddMany([(sq1_1, 1, wx.EXPAND), (self.voltsel, 1, wx.EXPAND), (self.currentsel, 1, wx.EXPAND)])\r\n\r\n        #Voltage and Current maximum select\r\n        hbox2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        sw1 = wx.StaticText(self, label='Set Max:')\r\n        self.maxsetvoltage = wx.TextCtrl(self)\r\n        self.maxsetvoltage.SetValue('V')\r\n        self.maxsetvoltage.Bind(wx.EVT_SET_FOCUS, self.cleartext)\r\n        self.maxsetvoltage.SetForegroundColour(wx.Colour(211, 211, 211))\r\n        self.maxsetcurrent = wx.TextCtrl(self)\r\n        self.maxsetcurrent.SetValue('mA')\r\n        self.maxsetcurrent.Bind(wx.EVT_SET_FOCUS, self.cleartext)\r\n        self.maxsetcurrent.SetForegroundColour(wx.Colour(211,211,211))\r\n        hbox2.AddMany([(sw1, 1, wx.EXPAND), (self.maxsetvoltage, 1, wx.EXPAND), (self.maxsetcurrent, 1, wx.EXPAND)])\r\n\r\n        #Voltage and current minimum select\r\n        hbox3 = wx.BoxSizer(wx.HORIZONTAL)\r\n        sw2 = wx.StaticText(self, label='Set Min:')\r\n        self.minsetcurrent = wx.TextCtrl(self)\r\n        self.minsetcurrent.SetValue('mA')\r\n        self.minsetcurrent.Bind(wx.EVT_SET_FOCUS, self.cleartext)\r\n        self.minsetcurrent.SetForegroundColour(wx.Colour(211, 211, 211))\r\n        self.minsetvoltage = wx.TextCtrl(self)\r\n        self.minsetvoltage.SetValue('V')\r\n        self.minsetvoltage.Bind(wx.EVT_SET_FOCUS, self.cleartext)\r\n        self.minsetvoltage.SetForegroundColour(wx.Colour(211, 211, 211))\r\n        hbox3.AddMany([(sw2, 1, wx.EXPAND), (self.minsetvoltage, 1, wx.EXPAND), (self.minsetcurrent, 1, wx.EXPAND)])\r\n\r\n        #Voltage and Current resolution select\r\n        hbox4 = wx.BoxSizer(wx.HORIZONTAL)\r\n        sw3 = wx.StaticText(self, label='Set Resolution:')\r\n        self.resovoltage = wx.TextCtrl(self)\r\n        self.resovoltage.SetValue('V')\r\n        self.resovoltage.Bind(wx.EVT_SET_FOCUS, self.cleartext)\r\n        self.resovoltage.SetForegroundColour(wx.Colour(211, 211, 211))\r\n        self.resocurrent = wx.TextCtrl(self)\r\n        self.resocurrent.SetValue('mA')\r\n        self.resocurrent.Bind(wx.EVT_SET_FOCUS, self.cleartext)\r\n        self.resocurrent.SetForegroundColour(wx.Colour(211, 211, 211))\r\n        hbox4.AddMany([(sw3, 1, wx.EXPAND), (self.resovoltage, 1, wx.EXPAND), (self.resocurrent, 1, wx.EXPAND)])\r\n\r\n        #Plot type selection checkboxes\r\n        hbox5 = wx.BoxSizer(wx.HORIZONTAL)\r\n        sh2 = wx.StaticText(self, label='Plot Type:')\r\n        self.typesel = wx.CheckBox(self, label='IV/VI', pos=(20, 20))\r\n        self.typesel.SetValue(False)\r\n        self.type2sel = wx.CheckBox(self, label='RV/RI', pos=(20, 20))\r\n        self.type2sel.SetValue(False)\r\n        self.type3sel = wx.CheckBox(self, label='PV/PI', pos=(20, 20))\r\n        self.type3sel.SetValue(False)\r\n        hbox5.AddMany([(sh2, 1, wx.EXPAND), (self.typesel, 1, wx.EXPAND), (self.type2sel, 1, wx.EXPAND),\r\n                       (self.type3sel, 1, wx.EXPAND)])\r\n\r\n        #electrical SMU channel select checkboxes and elecrical save button\r\n        hbox6 = wx.BoxSizer(wx.HORIZONTAL)\r\n        sq6_1 = wx.StaticText(self, label='Select SMU Channel: ')\r\n        self.Asel = wx.CheckBox(self, label='A', pos=(20, 20))\r\n        self.Asel.SetValue(False)\r\n        self.Bsel = wx.CheckBox(self, label='B', pos=(20, 20))\r\n        self.Bsel.SetValue(False)\r\n        self.Asel.Bind(wx.EVT_CHECKBOX, self.trueorfalse)\r\n        self.Bsel.Bind(wx.EVT_CHECKBOX, self.trueorfalse)\r\n        self.elecsave = wx.Button(self, label='Save', size=(50, 20))\r\n        self.elecsave.Bind(wx.EVT_BUTTON, self.routinesaveelec)\r\n        hbox6.AddMany([(sq6_1, 1, wx.EXPAND), (self.Asel, 1, wx.EXPAND), (self.Bsel, 1, wx.EXPAND), (self.elecsave, 1, wx.EXPAND)])\r\n\r\n        #format sizers\r\n        evbox.AddMany([(hbox0, 1, wx.EXPAND), (hbox1, 1, wx.EXPAND), (hbox2, 1, wx.EXPAND), (hbox3, 1, wx.EXPAND),\r\n                       (hbox4, 1, wx.EXPAND), (hbox5, 1, wx.EXPAND), (hbox6, 1, wx.EXPAND)])\r\n        hbox.AddMany([(evbox, 1, wx.EXPAND)])\r\n        elecvbox.Add(hbox, 1, wx.EXPAND)\r\n\r\n        #CREATE OPTICAL PANEL###########################################################################################\r\n\r\n        #create optical panel sizer and necessary hboxes and vboxes\r\n        sb1 = wx.StaticBox(self, label='Optical')\r\n        opticvbox = wx.StaticBoxSizer(sb1, wx.VERTICAL)\r\n        opvbox = wx.BoxSizer(wx.VERTICAL)\r\n        opvbox2 = wx.BoxSizer(wx.VERTICAL)\r\n        ophbox = wx.BoxSizer(wx.HORIZONTAL)\r\n\r\n        #optical routine select tab\r\n        opt_hbox0 = wx.BoxSizer(wx.HORIZONTAL)\r\n        sq0_2 = wx.StaticText(self, label='Select Routine ')\r\n        self.routineselectopt = wx.ComboBox(self, choices=options, style=wx.CB_READONLY, value='1')\r\n        self.routineselectopt.name = 'routineselectopt'\r\n        self.routineselectopt.Bind(wx.EVT_COMBOBOX_DROPDOWN, self.routinepanel)\r\n        self.routineselectopt.Bind(wx.EVT_COMBOBOX, self.swaproutine)\r\n        opt_hbox0.AddMany([(sq0_2, 1, wx.EXPAND), (self.routineselectopt, 1, wx.EXPAND)])\r\n\r\n        #optical start wavelength select\r\n        opt_hbox = wx.BoxSizer(wx.HORIZONTAL)\r\n        st4 = wx.StaticText(self, label='Start (nm)')\r\n        self.startWvlTc = wx.TextCtrl(self)\r\n        self.startWvlTc.SetValue('0')\r\n        opt_hbox.AddMany([(st4, 1, wx.EXPAND), (self.startWvlTc, 1, wx.EXPAND)])\r\n\r\n        #optical stop wavelength select\r\n        opt_hbox2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        st5 = wx.StaticText(self, label='Stop (nm)')\r\n        self.stopWvlTc = wx.TextCtrl(self)\r\n        self.stopWvlTc.SetValue('0')\r\n        opt_hbox2.AddMany([(st5, 1, wx.EXPAND), (self.stopWvlTc, 1, wx.EXPAND)])\r\n\r\n        #optical step size select\r\n        opt_hbox3 = wx.BoxSizer(wx.HORIZONTAL)\r\n        st6 = wx.StaticText(self, label='Step (nm)')\r\n        self.stepWvlTc = wx.TextCtrl(self)\r\n        self.stepWvlTc.SetValue('0')\r\n        opt_hbox3.AddMany([(st6, 1, wx.EXPAND), (self.stepWvlTc, 1, wx.EXPAND)])\r\n\r\n        #optical sweep power tab\r\n        opt_hbox4 = wx.BoxSizer(wx.HORIZONTAL)\r\n        sweepPowerSt = wx.StaticText(self, label='Sweep power (dBm)')\r\n        self.sweepPowerTc = wx.TextCtrl(self)\r\n        self.sweepPowerTc.SetValue('0')\r\n        opt_hbox4.AddMany([(sweepPowerSt, 1, wx.EXPAND), (self.sweepPowerTc, 1, wx.EXPAND)])\r\n\r\n        #optical Initial range tab\r\n        opt_hbox4_5 = wx.BoxSizer(wx.HORIZONTAL)\r\n        sweepinitialrangeSt = wx.StaticText(self, label='Initial Range (dBm)')\r\n        self.sweepinitialrangeTc = wx.TextCtrl(self)\r\n        self.sweepinitialrangeTc.SetValue('0')\r\n        opt_hbox4_5.AddMany([(sweepinitialrangeSt, 1, wx.EXPAND), (self.sweepinitialrangeTc, 1, wx.EXPAND)])\r\n\r\n        #optical range decrement tab\r\n        opt_hbox4_6 = wx.BoxSizer(wx.HORIZONTAL)\r\n        rangedecSt = wx.StaticText(self, label='Range Decrement (dBm)')\r\n        self.rangedecTc = wx.TextCtrl(self)\r\n        self.rangedecTc.SetValue('0')\r\n        opt_hbox4_6.AddMany([(rangedecSt, 1, wx.EXPAND), (self.rangedecTc, 0, wx.EXPAND)])\r\n\r\n        #optical sweep speed tab\r\n        opt_hbox5 = wx.BoxSizer(wx.HORIZONTAL)\r\n        st7 = wx.StaticText(self, label='Sweep speed')\r\n        sweepSpeedOptions = ['80 nm/s', '40 nm/s', '20 nm/s', '10 nm/s', '5 nm/s', '0.5 nm/s', 'auto']\r\n        self.sweepSpeedCb = wx.ComboBox(self, choices=sweepSpeedOptions, style=wx.CB_READONLY, value='auto')\r\n        opt_hbox5.AddMany([(st7, 1, wx.EXPAND), (self.sweepSpeedCb, 1, wx.EXPAND)])\r\n\r\n        #optical laser output tab\r\n        opt_hbox6 = wx.BoxSizer(wx.HORIZONTAL)\r\n        st8 = wx.StaticText(self, label='Laser output')\r\n        laserOutputOptions = ['High power', 'Low SSE']\r\n        self.laserOutputCb = wx.ComboBox(self, choices=laserOutputOptions, style=wx.CB_READONLY, value='High power')\r\n        opt_hbox6.AddMany([(st8, 1, wx.EXPAND), (self.laserOutputCb, 1, wx.EXPAND)])\r\n\r\n        #optical number of scans tab\r\n        opt_hbox7 = wx.BoxSizer(wx.HORIZONTAL)\r\n        st9 = wx.StaticText(self, label='Number of scans')\r\n        numSweepOptions = ['1', '2', '3']\r\n        self.numSweepCb = wx.ComboBox(self, choices=numSweepOptions, style=wx.CB_READONLY, value='1')\r\n        opt_hbox7.AddMany([(st9, 1, wx.EXPAND), (self.numSweepCb, 1, wx.EXPAND)])\r\n\r\n        #optical save box, to save parameters to temporary list\r\n        optsavebox = wx.BoxSizer(wx.HORIZONTAL)\r\n        self.optsave = wx.Button(self, label='Save', size=(120, 25))\r\n        self.optsave.Bind(wx.EVT_BUTTON, self.routinesaveopt)\r\n        optsavebox.AddMany([((1,1),1), (self.optsave, 0, wx.EXPAND)])\r\n\r\n        #format sizers\r\n        opvbox0 = wx.BoxSizer(wx.HORIZONTAL)\r\n        opvbox0.AddMany([(opt_hbox0, 1, wx.EXPAND)])\r\n        opvbox.AddMany([(opt_hbox, 1, wx.EXPAND), (opt_hbox2, 1, wx.EXPAND), (opt_hbox3, 1, wx.EXPAND), (opt_hbox4, 1, wx.EXPAND), (opt_hbox4_5, 1, wx.EXPAND)])\r\n        opvbox2.AddMany([(opt_hbox5, 1, wx.EXPAND), (opt_hbox6, 1, wx.EXPAND), (opt_hbox7, 1, wx.EXPAND), (opt_hbox4_6, 1, wx.EXPAND)])\r\n        ophbox.AddMany([(opvbox, 0, wx.EXPAND), (opvbox2, 0, wx.EXPAND)])\r\n        opticvbox.AddMany([(opvbox0, 0, wx.EXPAND), ((0,0),1), (ophbox, 0, wx.EXPAND), ((1,1), 1), (optsavebox, 0, wx.EXPAND)])\r\n\r\n        ##CREATE SET WAVELENGTH, VOLTAGE SWEEP BOX######################################################################\r\n\r\n        #initialize sizers\r\n        sb_2 = wx.StaticBox(self, label='Set Wavelength, Electrical sweep')\r\n        elecvbox2 = wx.StaticBoxSizer(sb_2, wx.VERTICAL)\r\n        hboxsetw = wx.BoxSizer(wx.HORIZONTAL)\r\n        evbox2 = wx.BoxSizer(wx.VERTICAL)\r\n        tophbox2 = wx.BoxSizer(wx.HORIZONTAL)\r\n\r\n        #set wavelength, routine select tab\r\n        hbox0_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        sq0_1_2 = wx.StaticText(self, label='Select Routine ')\r\n        self.routineselectsetw = wx.ComboBox(self, choices=options, style=wx.CB_READONLY, value='1')\r\n        self.routineselectsetw.name = 'routineselectsetw'\r\n        self.routineselectsetw.Bind(wx.EVT_COMBOBOX_DROPDOWN, self.routinepanel)\r\n        self.routineselectsetw.Bind(wx.EVT_COMBOBOX, self.swaproutine)\r\n        hbox0_2.AddMany([(sq0_1_2, 1, wx.EXPAND), (self.routineselectsetw, 1, wx.EXPAND)])\r\n\r\n        #set wavelength, independant variable checkboxes\r\n        hbox1_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        sq1_1_2 = wx.StaticText(self, label='Select Independant Variable: ')\r\n        self.voltsel2 = wx.CheckBox(self, label='Voltage', pos=(20, 20))\r\n        self.voltsel2.SetValue(False)\r\n        self.currentsel2 = wx.CheckBox(self, label='Current', pos=(20, 20))\r\n        self.currentsel2.SetValue(False)\r\n        self.voltsel2.Bind(wx.EVT_CHECKBOX, self.trueorfalse)\r\n        self.currentsel2.Bind(wx.EVT_CHECKBOX, self.trueorfalse)\r\n        hbox1_2.AddMany([(sq1_1_2, 1, wx.EXPAND), (self.voltsel2, 1, wx.EXPAND), (self.currentsel2, 1, wx.EXPAND)])\r\n\r\n        #set wavelength, voltage and current maximum select\r\n        hbox2_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        sw1_2 = wx.StaticText(self, label='Set Max:')\r\n        self.maxsetvoltage2 = wx.TextCtrl(self)\r\n        self.maxsetvoltage2.SetValue('V')\r\n        self.maxsetvoltage2.Bind(wx.EVT_SET_FOCUS, self.cleartext)\r\n        self.maxsetvoltage2.SetForegroundColour(wx.Colour(211, 211, 211))\r\n        self.maxsetcurrent2 = wx.TextCtrl(self)\r\n        self.maxsetcurrent2.SetValue('mA')\r\n        self.maxsetcurrent2.Bind(wx.EVT_SET_FOCUS, self.cleartext)\r\n        self.maxsetcurrent2.SetForegroundColour(wx.Colour(211, 211, 211))\r\n        hbox2_2.AddMany([(sw1_2, 1, wx.EXPAND), (self.maxsetvoltage2, 1, wx.EXPAND), (self.maxsetcurrent2, 1, wx.EXPAND)])\r\n\r\n        #set wavelength, voltage and current minimum select\r\n        hbox3_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        sw2_2 = wx.StaticText(self, label='Set Min:')\r\n        self.minsetcurrent2 = wx.TextCtrl(self)\r\n        self.minsetcurrent2.SetValue('mA')\r\n        self.minsetcurrent2.Bind(wx.EVT_SET_FOCUS, self.cleartext)\r\n        self.minsetcurrent2.SetForegroundColour(wx.Colour(211, 211, 211))\r\n        self.minsetvoltage2 = wx.TextCtrl(self)\r\n        self.minsetvoltage2.SetValue('V')\r\n        self.minsetvoltage2.Bind(wx.EVT_SET_FOCUS, self.cleartext)\r\n        self.minsetvoltage2.SetForegroundColour(wx.Colour(211, 211, 211))\r\n        hbox3_2.AddMany([(sw2_2, 1, wx.EXPAND), (self.minsetvoltage2, 1, wx.EXPAND), (self.minsetcurrent2, 1, wx.EXPAND)])\r\n\r\n        #set wavelength, voltage and current resolution set\r\n        hbox4_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        sw3_2 = wx.StaticText(self, label='Set Resolution:')\r\n        self.resovoltage2 = wx.TextCtrl(self)\r\n        self.resovoltage2.SetValue('V')\r\n        self.resovoltage2.Bind(wx.EVT_SET_FOCUS, self.cleartext)\r\n        self.resovoltage2.SetForegroundColour(wx.Colour(211, 211, 211))\r\n        self.resocurrent2 = wx.TextCtrl(self)\r\n        self.resocurrent2.SetValue('mA')\r\n        self.resocurrent2.Bind(wx.EVT_SET_FOCUS, self.cleartext)\r\n        self.resocurrent2.SetForegroundColour(wx.Colour(211, 211, 211))\r\n        hbox4_2.AddMany([(sw3_2, 1, wx.EXPAND), (self.resovoltage2, 1, wx.EXPAND), (self.resocurrent2, 1, wx.EXPAND)])\r\n\r\n        #set wavelength, plot type checkboxes\r\n        hbox5_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        sh2_2 = wx.StaticText(self, label='Plot Type:')\r\n        self.typesel2 = wx.CheckBox(self, label='IV/VI', pos=(20, 20))\r\n        self.typesel2.SetValue(False)\r\n        self.type2sel2 = wx.CheckBox(self, label='RV/RI', pos=(20, 20))\r\n        self.type2sel2.SetValue(False)\r\n        self.type3sel2 = wx.CheckBox(self, label='PV/PI', pos=(20, 20))\r\n        self.type3sel2.SetValue(False)\r\n        hbox5_2.AddMany([(sh2_2, 1, wx.EXPAND), (self.typesel2, 1, wx.EXPAND), (self.type2sel2, 1, wx.EXPAND),\r\n                         (self.type3sel2, 1, wx.EXPAND)])\r\n\r\n        #set wavelength, select smu channel and save button\r\n        hbox6_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        sq6_2 = wx.StaticText(self, label='Select SMU Channel: ')\r\n        self.Asel2 = wx.CheckBox(self, label='A', pos=(20, 20))\r\n        self.Asel2.SetValue(False)\r\n        self.Bsel2 = wx.CheckBox(self, label='B', pos=(20, 20))\r\n        self.Bsel2.SetValue(False)\r\n        self.Asel2.Bind(wx.EVT_CHECKBOX, self.trueorfalse)\r\n        self.Bsel2.Bind(wx.EVT_CHECKBOX, self.trueorfalse)\r\n        self.setwsave = wx.Button(self, label='Save', size=(50, 20))\r\n        self.setwsave.Bind(wx.EVT_BUTTON, self.routinesavesetw)\r\n        hbox6_2.AddMany([(sq6_2, 1, wx.EXPAND), (self.Asel2, 1, wx.EXPAND), (self.Bsel2, 1, wx.EXPAND), (self.setwsave, 1, wx.EXPAND)])\r\n\r\n        #set wavelength, wavelength select\r\n        hbox7_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        wavesetst = wx.StaticText(self, label='Wavelengths (nm)')\r\n        self.wavesetTc2 = wx.TextCtrl(self)\r\n        self.wavesetTc2.SetValue('0')\r\n        hbox7_2.AddMany([(wavesetst, 1, wx.EXPAND), (self.wavesetTc2, 1, wx.EXPAND)])\r\n\r\n        #set wavelength, format sizers\r\n        evbox2.AddMany([(hbox0_2, 1, wx.EXPAND), (hbox1_2, 1, wx.EXPAND), (hbox2_2, 1, wx.EXPAND),\r\n                        (hbox3_2, 1, wx.EXPAND), (hbox4_2, 1, wx.EXPAND), (hbox5_2, 1, wx.EXPAND),\r\n                        (hbox7_2, 1, wx.EXPAND), (hbox6_2, 1, wx.EXPAND)])\r\n        hboxsetw.AddMany([(evbox2, 1, wx.EXPAND)])\r\n        elecvbox2.Add(hboxsetw, 1, wx.EXPAND)\r\n\r\n        #SET VOLTAGE SWEEP WAVELENGTH###################################################################################\r\n\r\n        #create set voltage, wavelength sweep sizer\r\n        sb1_2 = wx.StaticBox(self, label='Set Electrical, Wavelength Sweep')\r\n        opticvbox_2 = wx.StaticBoxSizer(sb1_2, wx.VERTICAL)\r\n        opvbox_2 = wx.BoxSizer(wx.VERTICAL)\r\n        opvbox2_2 = wx.BoxSizer(wx.VERTICAL)\r\n        ophbox_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n\r\n        #set voltage, routine select tab\r\n        hbox0_2_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        sq0_1_2_2 = wx.StaticText(self, label='Select Routine ')\r\n        self.routineselectsetv = wx.ComboBox(self, choices=options, style=wx.CB_READONLY, value='1')\r\n        self.routineselectsetv.name = 'routineselectsetv'\r\n        self.routineselectsetv.SetItems(options)\r\n        self.routineselectsetv.Bind(wx.EVT_COMBOBOX_DROPDOWN, self.routinepanel)\r\n        self.routineselectsetv.Bind(wx.EVT_COMBOBOX, self.swaproutine)\r\n        hbox0_2_2.AddMany([(sq0_1_2_2, 1, wx.EXPAND), (self.routineselectsetv, 1, wx.EXPAND)])\r\n\r\n        #set voltage, wavelength start select\r\n        opt_hbox_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        st4_2 = wx.StaticText(self, label='Start (nm)')\r\n        self.startWvlTc2 = wx.TextCtrl(self)\r\n        self.startWvlTc2.SetValue('0')\r\n        opt_hbox_2.AddMany([(st4_2, 1, wx.EXPAND), (self.startWvlTc2, 1, wx.EXPAND)])\r\n\r\n        #set voltage, wavelength stop select\r\n        opt_hbox2_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        st5_2 = wx.StaticText(self, label='Stop (nm)')\r\n        self.stopWvlTc2 = wx.TextCtrl(self)\r\n        self.stopWvlTc2.SetValue('0')\r\n        opt_hbox2_2.AddMany([(st5_2, 1, wx.EXPAND), (self.stopWvlTc2, 1, wx.EXPAND)])\r\n\r\n        #set voltage, step size select\r\n        opt_hbox3_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        st6_2 = wx.StaticText(self, label='Step (nm)')\r\n        self.stepWvlTc2 = wx.TextCtrl(self)\r\n        self.stepWvlTc2.SetValue('0')\r\n        opt_hbox3_2.AddMany([(st6_2, 1, wx.EXPAND), (self.stepWvlTc2, 1, wx.EXPAND)])\r\n\r\n        #set voltage, sweep power select\r\n        opt_hbox4_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        sweepPowerSt2 = wx.StaticText(self, label='Sweep power (dBm)')\r\n        self.sweepPowerTc2 = wx.TextCtrl(self)\r\n        self.sweepPowerTc2.SetValue('0')\r\n        opt_hbox4_2.AddMany([(sweepPowerSt2, 1, wx.EXPAND), (self.sweepPowerTc2, 1, wx.EXPAND)])\r\n\r\n        #set voltage, initial range select\r\n        opt_hbox4_5_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        sweepinitialrangeSt2 = wx.StaticText(self, label='Initial Range (dBm)')\r\n        self.sweepinitialrangeTc2 = wx.TextCtrl(self)\r\n        self.sweepinitialrangeTc2.SetValue('0')\r\n        opt_hbox4_5_2.AddMany([(sweepinitialrangeSt2, 1, wx.EXPAND), (self.sweepinitialrangeTc2, 1, wx.EXPAND)])\r\n\r\n        #set voltage, range decrement select\r\n        opt_hbox4_6_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        rangedecSt2 = wx.StaticText(self, label='Range Decrement (dBm)')\r\n        self.rangedecTc2 = wx.TextCtrl(self)\r\n        self.rangedecTc2.SetValue('0')\r\n        opt_hbox4_6_2.AddMany([(rangedecSt2, 1, wx.EXPAND), (self.rangedecTc2, 1, wx.EXPAND)])\r\n\r\n        #set voltage sweep speed tab\r\n        opt_hbox5_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        st7_2 = wx.StaticText(self, label='Sweep speed')\r\n        sweepSpeedOptions2 = ['80 nm/s', '40 nm/s', '20 nm/s', '10 nm/s', '5 nm/s', '0.5 nm/s', 'auto']\r\n        self.sweepSpeedCb2 = wx.ComboBox(self, choices=sweepSpeedOptions2, style=wx.CB_READONLY, value='auto')\r\n        opt_hbox5_2.AddMany([(st7_2, 1, wx.EXPAND), (self.sweepSpeedCb2, 1, wx.EXPAND)])\r\n\r\n        #set voltage laser output tab\r\n        opt_hbox6_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        st8_2 = wx.StaticText(self, label='Laser output')\r\n        laserOutputOptions2 = ['High power', 'Low SSE']\r\n        self.laserOutputCb2 = wx.ComboBox(self, choices=laserOutputOptions2, style=wx.CB_READONLY, value='High power')\r\n        opt_hbox6_2.AddMany([(st8_2, 1, wx.EXPAND), (self.laserOutputCb2, 1, wx.EXPAND)])\r\n\r\n        #set voltage number of scans tab\r\n        opt_hbox7_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        st9_2 = wx.StaticText(self, label='Number of scans')\r\n        numSweepOptions2 = ['1', '2', '3']\r\n        self.numSweepCb2 = wx.ComboBox(self, choices=numSweepOptions2, style=wx.CB_READONLY, value='1')\r\n        opt_hbox7_2.AddMany([(st9_2, 1, wx.EXPAND), (self.numSweepCb2, 1, wx.EXPAND)])\r\n\r\n        #set voltage, voltage selection\r\n        opt_hbox8_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        voltagesetst = wx.StaticText(self, label='Voltages (V)')\r\n        self.voltagesetTc2 = wx.TextCtrl(self)\r\n        self.voltagesetTc2.SetValue('0')\r\n        opt_hbox8_2.AddMany([(voltagesetst, 1, wx.EXPAND), (self.voltagesetTc2, 1, wx.EXPAND)])\r\n\r\n        #set voltage SMU channel selection checkboxes\r\n        opt_hbox9_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        sq9_2 = wx.StaticText(self, label='Select SMU Channel: ')\r\n        self.Asel3 = wx.CheckBox(self, label='A', pos=(20, 20))\r\n        self.Asel3.SetValue(False)\r\n        self.Bsel3 = wx.CheckBox(self, label='B', pos=(20, 20))\r\n        self.Bsel3.SetValue(False)\r\n        self.Asel3.Bind(wx.EVT_CHECKBOX, self.trueorfalse)\r\n        self.Bsel3.Bind(wx.EVT_CHECKBOX, self.trueorfalse)\r\n        opt_hbox9_2.AddMany([(sq9_2, 1, wx.EXPAND), (self.Asel3, 1, wx.EXPAND), (self.Bsel3, 1, wx.EXPAND)])\r\n\r\n        #set voltage save button\r\n        opt_hbox10_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        self.setvsave = wx.Button(self, label='Save', size=(120, 25))\r\n        self.setvsave.Bind(wx.EVT_BUTTON, self.routinesavesetv)\r\n        opt_hbox10_2.AddMany([((1, 1), 1), (self.setvsave, 0, wx.EXPAND)])\r\n\r\n        #format set voltage sizers\r\n        opvbox_2.AddMany([(opt_hbox_2, 1, wx.EXPAND), (opt_hbox2_2, 1, wx.EXPAND), (opt_hbox3_2, 1, wx.EXPAND), (opt_hbox4_2, 1, wx.EXPAND), (opt_hbox4_5_2, 1, wx.EXPAND)])\r\n        opvbox2_2.AddMany([(opt_hbox5_2, 1, wx.EXPAND), (opt_hbox6_2, 1, wx.EXPAND), (opt_hbox7_2, 1, wx.EXPAND), (opt_hbox8_2, 0, wx.EXPAND), (opt_hbox4_6_2, 0, wx.EXPAND)])\r\n        ophbox_2.AddMany([(opvbox_2, 1, wx.EXPAND), (opvbox2_2, 1, wx.EXPAND)])\r\n        ophbox_2_2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        ophbox_2_2.AddMany([(hbox0_2_2, 1, wx.EXPAND)])\r\n        opticvbox_2.AddMany([(ophbox_2_2, 0, wx.EXPAND), (ophbox_2, 0, wx.EXPAND), (opt_hbox9_2, 0, wx.EXPAND), (opt_hbox10_2, 0, wx.EXPAND)])\r\n\r\n        #format all sizers\r\n        tophbox.AddMany([(elecvbox, 0, wx.EXPAND), (opticvbox, 1, wx.EXPAND)])\r\n        tophbox2.AddMany([(elecvbox2, 0, wx.EXPAND), (opticvbox_2, 1, wx.EXPAND)])\r\n        highestvbox = wx.BoxSizer(wx.VERTICAL)\r\n        #highesthbox = wx.BoxSizer(wx.HORIZONTAL)\r\n        highestvbox.AddMany([(tophbox, 1, wx.EXPAND), (tophbox2, 1, wx.EXPAND)])\r\n        #highesthbox.AddMany([(routineselect, 0, wx.EXPAND), (highestvbox, 1, wx.EXPAND)])\r\n        self.SetSizer(highestvbox)\r\n\r\n\r\n    def cleartext(self, event):\r\n        \"\"\"\r\n        Clears the text in the textctrl boxes on user clicking the box\r\n        Parameters\r\n        ----------\r\n        event : The event triggered when the user clicks the textctrl box\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n        e = event.GetEventObject()\r\n        if e.GetValue() == 'mA' or e.GetValue() == 'mV' or e.GetValue() == 'V':\r\n            e.SetValue('')\r\n            e.SetForegroundColour(wx.Colour(0, 0, 0))\r\n        if e.GetValue() == '':\r\n            e.SetForegroundColour(wx.Colour(0, 0, 0))\r\n        event.Skip()\r\n\r\n\r\n    def setnumroutine(self, event):\r\n        \"\"\"\r\n\r\n        :param event:\r\n        :type event:\r\n        :return:\r\n        :rtype:\r\n        \"\"\"\r\n        c = event.GetEventObject()\r\n\r\n        optionsblank = []\r\n        #if c == self.elecroutine:\r\n\r\n        if c.GetValue() != '':\r\n            options = []\r\n            for x in range(int(c.GetValue())):\r\n                x = x + 1\r\n                options.append(str(x))\r\n\r\n            print(c.name)\r\n            if c.name == 'elecroutine':\r\n                self.routineselectelec.SetItems(options)\r\n                self.elecvolt = [''] * int(c.GetValue())\r\n                self.eleccurrent = [''] * int(c.GetValue())\r\n                self.elecvmax = [''] * int(c.GetValue())\r\n                self.elecvmin = ['']* int(c.GetValue())\r\n                self.elecimin = [''] * int(c.GetValue())\r\n                self.elecimax = [''] * int(c.GetValue())\r\n                self.elecires = [''] * int(c.GetValue())\r\n                self.elecvres = [''] * int(c.GetValue())\r\n                self.eleciv = [''] * int(c.GetValue())\r\n                self.elecrv = [''] * int(c.GetValue())\r\n                self.elecpv = [''] * int(c.GetValue())\r\n                self.elecchannelA = [''] * int(c.GetValue())\r\n                self.elecchannelB = [''] * int(c.GetValue())\r\n                self.elecflagholder = [''] * int(c.GetValue())\r\n\r\n            if c.name == 'optroutine':\r\n                self.routineselectopt.SetItems(options)\r\n                self.start = [''] * int(c.GetValue())\r\n                self.stop = [''] * int(c.GetValue())\r\n                self.step = [''] * int(c.GetValue())\r\n                self.sweeppow = [''] * int(c.GetValue())\r\n                self.sweepsped = [''] * int(c.GetValue())\r\n                self.laserout = [''] * int(c.GetValue())\r\n                self.numscans = [''] * int(c.GetValue())\r\n                self.initialran = [''] * int(c.GetValue())\r\n                self.rangedecre = [''] * int(c.GetValue())\r\n                self.opticflagholder = [''] * int(c.GetValue())\r\n\r\n            if c.name == 'setwroutine':\r\n                self.routineselectsetw.SetItems(options)\r\n                self.setwvolt = [''] * int(c.GetValue())\r\n                self.setwcurrent = [''] * int(c.GetValue())\r\n                self.setwvmax = [''] * int(c.GetValue())\r\n                self.setwvmin = [''] * int(c.GetValue())\r\n                self.setwimin = [''] * int(c.GetValue())\r\n                self.setwimax = [''] * int(c.GetValue())\r\n                self.setwires = [''] * int(c.GetValue())\r\n                self.setwvres = [''] * int(c.GetValue())\r\n                self.setwiv = [''] * int(c.GetValue())\r\n                self.setwrv = [''] * int(c.GetValue())\r\n                self.setwpv = [''] * int(c.GetValue())\r\n                self.setwchannelA = [''] * int(c.GetValue())\r\n                self.setwchannelB = [''] * int(c.GetValue())\r\n                self.setwwavelengths = [''] * int(c.GetValue())\r\n                self.setwflagholder = [''] * int(c.GetValue())\r\n\r\n            if c.name == 'setvroutine':\r\n                self.routineselectsetv.SetItems(options)\r\n                self.setvstart = [''] * int(c.GetValue())\r\n                self.setvstop = [''] * int(c.GetValue())\r\n                self.setvstep = [''] * int(c.GetValue())\r\n                self.setvsweeppow = [''] * int(c.GetValue())\r\n                self.setvsweepsped = [''] * int(c.GetValue())\r\n                self.setvlaserout = [''] * int(c.GetValue())\r\n                self.setvnumscans = [''] * int(c.GetValue())\r\n                self.setvinitialran = [''] * int(c.GetValue())\r\n                self.setvrangedecre = [''] * int(c.GetValue())\r\n                self.setvchannelA = [''] * int(c.GetValue())\r\n                self.setvchannelB = [''] * int(c.GetValue())\r\n                self.setvvoltages = [''] * int(c.GetValue())\r\n                self.setvflagholder = [''] * int(c.GetValue())\r\n\r\n        if c.GetValue() == '':\r\n            if c.name == 'elecroutine':\r\n                self.routineselectelec.SetItems(optionsblank)\r\n            if c.name == 'optroutine':\r\n                self.routineselectopt.SetItems(optionsblank)\r\n            if c.name == 'setwroutine':\r\n                self.routineselectsetw.SetItems(optionsblank)\r\n            if c.name == 'setvroutine':\r\n                self.routineselectsetv.SetItems(optionsblank)\r\n\r\n\r\n    def trueorfalse(self, event):\r\n        \"\"\"\r\n        For selections that can only be one or the other this function deselects the other option on the selection of one of the parameters\r\n        Parameters\r\n        ----------\r\n        event : event triggered by any one of the parameters that are exclusive\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n        e = event.GetEventObject()\r\n\r\n        if e == self.Asel and self.Asel.GetValue() == True:\r\n            self.Bsel.SetValue(False)\r\n\r\n        if e == self.Asel2 and self.Asel2.GetValue() == True:\r\n            self.Bsel2.SetValue(False)\r\n\r\n        if e == self.Asel3 and self.Asel3.GetValue() == True:\r\n            self.Bsel3.SetValue(False)\r\n\r\n        if e == self.Bsel and self.Bsel.GetValue() == True:\r\n            self.Asel.SetValue(False)\r\n\r\n        if e == self.Bsel2 and self.Bsel2.GetValue() == True:\r\n            self.Asel2.SetValue(False)\r\n\r\n        if e == self.Bsel3 and self.Bsel3.GetValue() == True:\r\n            self.Asel3.SetValue(False)\r\n\r\n        if e == self.voltsel and self.voltsel.GetValue() == True:\r\n            self.currentsel.SetValue(False)\r\n\r\n        if e == self.currentsel and self.currentsel.GetValue() == True:\r\n            self.voltsel.SetValue(False)\r\n\r\n        if e == self.voltsel2 and self.voltsel2.GetValue() == True:\r\n            self.currentsel2.SetValue(False)\r\n\r\n        if e == self.currentsel2 and self.currentsel2.GetValue() == True:\r\n            self.voltsel2.SetValue(False)\r\n\r\n        event.Skip()\r\n\r\n\r\n    def routinesaveelec(self, event):\r\n        \"\"\"\r\n        When the user hits the electrical panel save button this function saves the data in the panel to a list with a size equal to the number of routines\r\n        Parameters\r\n        ----------\r\n        event : the event triggered by user clicking the save button in the electrical panel\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n        if self.routineselectelec.GetValue() != '':\r\n            value = int(self.routineselectelec.GetValue()) - 1\r\n            self.elecvolt[value] = self.voltsel.GetValue()\r\n            self.eleccurrent[value] = self.currentsel.GetValue()\r\n            self.elecvmax[value] = self.maxsetvoltage.GetValue()\r\n            self.elecvmin[value] = self.minsetvoltage.GetValue()\r\n            self.elecimin[value] = self.minsetcurrent.GetValue()\r\n            self.elecimax[value] = self.maxsetcurrent.GetValue()\r\n            self.elecires[value] = self.resocurrent.GetValue()\r\n            self.elecvres[value] = self.resovoltage.GetValue()\r\n            self.eleciv[value] = self.typesel.GetValue()\r\n            self.elecrv[value] = self.type2sel.GetValue()\r\n            self.elecpv[value] = self.type3sel.GetValue()\r\n            self.elecchannelA[value] = self.Asel.GetValue()\r\n            self.elecchannelB[value] = self.Bsel.GetValue()\r\n            self.elecflagholder[value] = True\r\n            print('Electrical routines temporarily saved')\r\n\r\n\r\n    def routinesaveopt(self, event):\r\n        \"\"\"\r\n        When the user hits the optical panel save button this function saves the data in the panel to a list with a size equal to the number of routines\r\n        Parameters\r\n        ----------\r\n        event : event triggered by user clicking the save button in the optical panel\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n        if self.routineselectopt.GetValue() != '':\r\n            value = int(self.routineselectopt.GetValue()) - 1\r\n            self.start[value] = self.startWvlTc.GetValue()\r\n            self.stop[value] = self.stopWvlTc.GetValue()\r\n            self.step[value] = self.stepWvlTc.GetValue()\r\n            self.sweeppow[value] = self.sweepPowerTc.GetValue()\r\n            self.sweepsped[value] = self.sweepSpeedCb.GetValue()\r\n            self.laserout[value] = self.laserOutputCb.GetValue()\r\n            self.numscans[value] = self.numSweepCb.GetValue()\r\n            self.initialran[value] = self.sweepinitialrangeTc.GetValue()\r\n            self.rangedecre[value] = self.rangedecTc.GetValue()\r\n            self.opticflagholder[value] = True\r\n            print('Optical routines temporarily saved')\r\n\r\n\r\n    def routinesavesetw(self, event):\r\n        \"\"\"\r\n        When the user hits the set wavelength, voltage sweep panel save button this function saves the data in the\r\n        panel to a list with a size equal to the number of routines\r\n        Parameters\r\n        ----------\r\n        event : event triggered by user clicking the save button in the set wavelength, voltage sweep panel\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n\r\n        if self.routineselectsetw.GetValue() != '':\r\n            value = int(self.routineselectsetw.GetValue()) - 1\r\n            self.setwvolt[value] = self.voltsel2.GetValue()\r\n            self.setwcurrent[value] = self.currentsel2.GetValue()\r\n            self.setwvmax[value] = self.maxsetvoltage2.GetValue()\r\n            self.setwvmin[value] = self.minsetvoltage2.GetValue()\r\n            self.setwimin[value] = self.minsetcurrent2.GetValue()\r\n            self.setwimax[value] = self.maxsetcurrent2.GetValue()\r\n            self.setwires[value] = self.resocurrent2.GetValue()\r\n            self.setwvres[value] = self.resovoltage2.GetValue()\r\n            self.setwiv[value] = self.typesel2.GetValue()\r\n            self.setwrv[value] = self.type2sel2.GetValue()\r\n            self.setwpv[value] = self.type3sel2.GetValue()\r\n            self.setwchannelA[value] = self.Asel2.GetValue()\r\n            self.setwchannelB[value] = self.Bsel2.GetValue()\r\n            self.setwwavelengths[value] = self.wavesetTc2.GetValue()\r\n            self.setwflagholder[value] = True\r\n            print('Set wavelength, voltage sweep routines temporarily saved')\r\n\r\n\r\n    def routinesavesetv(self, event):\r\n        \"\"\"\r\n        When the user hits the set voltage, wavelength sweep panel save button this function saves the data in the\r\n        panel to a list with a size equal to the number of routines\r\n        Parameters\r\n        ----------\r\n        event : event triggered by user clicking the save button in the set voltage, wavelength sweep panel\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n\r\n        if self.routineselectsetv.GetValue() != '':\r\n            value = int(self.routineselectsetv.GetValue()) - 1\r\n            self.setvstart[value] = self.startWvlTc2.GetValue()\r\n            self.setvstop[value] = self.stopWvlTc2.GetValue()\r\n            self.setvstep[value] = self.stepWvlTc2.GetValue()\r\n            self.setvsweeppow[value] = self.sweepPowerTc2.GetValue()\r\n            self.setvsweepsped[value] = self.sweepSpeedCb2.GetValue()\r\n            self.setvlaserout[value] = self.laserOutputCb2.GetValue()\r\n            self.setvnumscans[value] = self.numSweepCb2.GetValue()\r\n            self.setvinitialran[value] = self.sweepinitialrangeTc2.GetValue()\r\n            self.setvrangedecre[value] = self.rangedecTc2.GetValue()\r\n            self.setvvoltages[value] = self.voltagesetTc2.GetValue()\r\n            self.setvchannelA[value] = self.Asel3.GetValue()\r\n            self.setvchannelB[value] = self.Bsel3.GetValue()\r\n            self.setvflagholder[value] = True\r\n            print('Set voltage, wavelength sweep routines temporarily saved')\r\n\r\n\r\n    def routinepanel(self, event):\r\n        \"\"\"\r\n        When the user opens the routine select dropdown this function saves the data in the panel to a list with a size\r\n        equal to the number of routines\r\n        Parameters\r\n        ----------\r\n        event : the event triggered by the user opening the dropdown selection on any of the panels\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n        e = event.GetEventObject()\r\n        name = e.name\r\n\r\n\r\n        if name == 'routineselectelec':\r\n\r\n            if self.routineselectelec.GetValue() != '':\r\n                value = int(self.routineselectelec.GetValue()) - 1\r\n                self.elecvolt[value] = self.voltsel.GetValue()\r\n                self.eleccurrent[value] = self.currentsel.GetValue()\r\n                self.elecvmax[value] = self.maxsetvoltage.GetValue()\r\n                self.elecvmin[value] = self.minsetvoltage.GetValue()\r\n                self.elecimin[value] = self.minsetcurrent.GetValue()\r\n                self.elecimax[value] = self.maxsetcurrent.GetValue()\r\n                self.elecires[value] = self.resocurrent.GetValue()\r\n                self.elecvres[value] = self.resovoltage.GetValue()\r\n                self.eleciv[value] = self.typesel.GetValue()\r\n                self.elecrv[value] = self.type2sel.GetValue()\r\n                self.elecpv[value] = self.type3sel.GetValue()\r\n                self.elecchannelA[value] = self.Asel.GetValue()\r\n                self.elecchannelB[value] = self.Bsel.GetValue()\r\n                self.elecflagholder[value] = True\r\n\r\n        if name == 'routineselectopt':\r\n\r\n            if self.routineselectopt.GetValue() != '':\r\n                value = int(self.routineselectopt.GetValue()) - 1\r\n                self.start[value] = self.startWvlTc.GetValue()\r\n                self.stop[value] = self.stopWvlTc.GetValue()\r\n                self.step[value] = self.stepWvlTc.GetValue()\r\n                self.sweeppow[value] = self.sweepPowerTc.GetValue()\r\n                self.sweepsped[value] = self.sweepSpeedCb.GetValue()\r\n                self.laserout[value] = self.laserOutputCb.GetValue()\r\n                self.numscans[value] = self.numSweepCb.GetValue()\r\n                self.initialran[value] = self.sweepinitialrangeTc.GetValue()\r\n                self.rangedecre[value] = self.rangedecTc.GetValue()\r\n                self.opticflagholder[value] = True\r\n\r\n\r\n        if name == 'routineselectsetw':\r\n\r\n            if self.routineselectsetw.GetValue() != '':\r\n                value = int(self.routineselectsetw.GetValue()) - 1\r\n                self.setwvolt[value] = self.voltsel2.GetValue()\r\n                self.setwcurrent[value] = self.currentsel2.GetValue()\r\n                self.setwvmax[value] = self.maxsetvoltage2.GetValue()\r\n                self.setwvmin[value] = self.minsetvoltage2.GetValue()\r\n                self.setwimin[value] = self.minsetcurrent2.GetValue()\r\n                self.setwimax[value] = self.maxsetcurrent2.GetValue()\r\n                self.setwires[value] = self.resocurrent2.GetValue()\r\n                self.setwvres[value] = self.resovoltage2.GetValue()\r\n                self.setwiv[value] = self.typesel2.GetValue()\r\n                self.setwrv[value] = self.type2sel2.GetValue()\r\n                self.setwpv[value] = self.type3sel2.GetValue()\r\n                self.setwchannelA[value] = self.Asel2.GetValue()\r\n                self.setwchannelB[value] = self.Bsel2.GetValue()\r\n                self.setwwavelengths[value] = self.wavesetTc2.GetValue()\r\n                self.setwflagholder[value] = True\r\n\r\n        if name == 'routineselectsetv':\r\n\r\n            if self.routineselectsetv.GetValue() != '':\r\n                value = int(self.routineselectsetv.GetValue()) - 1\r\n                self.setvstart[value] = self.startWvlTc2.GetValue()\r\n                self.setvstop[value] = self.stopWvlTc2.GetValue()\r\n                self.setvstep[value] = self.stepWvlTc2.GetValue()\r\n                self.setvsweeppow[value] = self.sweepPowerTc2.GetValue()\r\n                self.setvsweepsped[value] = self.sweepSpeedCb2.GetValue()\r\n                self.setvlaserout[value] = self.laserOutputCb2.GetValue()\r\n                self.setvnumscans[value] = self.numSweepCb2.GetValue()\r\n                self.setvinitialran[value] = self.sweepinitialrangeTc2.GetValue()\r\n                self.setvrangedecre[value] = self.rangedecTc2.GetValue()\r\n                self.setvvoltages[value] = self.voltagesetTc2.GetValue()\r\n                self.setvchannelA[value] = self.Asel3.GetValue()\r\n                self.setvchannelB[value] = self.Bsel3.GetValue()\r\n                self.setvflagholder[value] = True\r\n\r\n        event.Skip()\r\n\r\n\r\n    def swaproutine(self, event):\r\n        \"\"\"\r\n        When the user selects a new routine number in the dropdown menu of the routine panels, this function swaps the\r\n        saved routine values shown\r\n        Parameters\r\n        ----------\r\n        event : the event triggered by the user opening the dropdown selection on any of the panels\r\n\r\n        Returns\r\n        -------\r\n\r\n        \"\"\"\r\n        \"\"\"\r\n        When the user selects a new routine number in the dropdown menu of the routine panels, this function swaps the saved routine values shown\r\n        :param event:\r\n        :type event:\r\n        :return:\r\n        :rtype:\r\n        \"\"\"\r\n\r\n        c = event.GetEventObject()\r\n        name = c.name\r\n\r\n        if name == 'routineselectelec':\r\n\r\n            if self.routineselectelec.GetValue() != '':\r\n                value = int(self.routineselectelec.GetValue()) - 1\r\n                self.voltsel.SetValue(bool(self.elecvolt[value]))# = self.elecvolt[value]\r\n                self.currentsel.SetValue(bool(self.eleccurrent[value]))\r\n                self.maxsetvoltage.SetValue(self.elecvmax[value])\r\n                self.minsetvoltage.SetValue(self.elecvmin[value])\r\n                self.minsetcurrent.SetValue(self.elecimin[value])\r\n                self.maxsetcurrent.SetValue(self.elecimax[value])\r\n                self.resocurrent.SetValue(self.elecires[value])\r\n                self.resovoltage.SetValue(self.elecvres[value])\r\n                self.typesel.SetValue(bool(self.eleciv[value]))\r\n                self.type2sel.SetValue(bool(self.elecrv[value]))\r\n                self.type3sel.SetValue(bool(self.elecpv[value]))\r\n                self.Asel.SetValue(bool(self.elecchannelA[value]))\r\n                self.Bsel.SetValue(bool(self.elecchannelB[value]))\r\n\r\n        if name == 'routineselectopt':\r\n\r\n            if self.routineselectopt.GetValue() != '':\r\n                value = int(self.routineselectopt.GetValue()) - 1\r\n                self.startWvlTc.SetValue(self.start[value])\r\n                self.stopWvlTc.SetValue(self.stop[value])\r\n                self.stepWvlTc.SetValue(self.step[value])\r\n                self.sweepPowerTc.SetValue(self.sweeppow[value])\r\n                self.sweepSpeedCb.SetValue(self.sweepsped[value])\r\n                self.laserOutputCb.SetValue(self.laserout[value])\r\n                self.numSweepCb.SetValue(self.numscans[value])\r\n                self.sweepinitialrangeTc.SetValue(self.initialran[value])\r\n                self.rangedecTc.SetValue(self.rangedecre[value])\r\n\r\n        if name == 'routineselectsetw':\r\n\r\n            if self.routineselectsetw.GetValue() != '':\r\n                value = int(self.routineselectsetw.GetValue()) - 1\r\n                self.voltsel2.SetValue(bool(self.setwvolt[value]))\r\n                self.currentsel2.SetValue(bool(self.setwcurrent[value]))\r\n                self.maxsetvoltage2.SetValue(self.setwvmax[value])\r\n                self.minsetvoltage2.SetValue(self.setwvmin[value])\r\n                self.minsetcurrent2.SetValue(self.setwimin[value])\r\n                self.maxsetcurrent2.SetValue(self.setwimax[value])\r\n                self.resocurrent2.SetValue(self.setwires[value])\r\n                self.resovoltage2.SetValue(self.setwvres[value])\r\n                self.typesel2.SetValue(bool(self.setwiv[value]))\r\n                self.type2sel2.SetValue(bool(self.setwrv[value]))\r\n                self.type3sel2.SetValue(bool(self.setwpv[value]))\r\n                self.Asel2.SetValue(bool(self.setwchannelA[value]))\r\n                self.Bsel2.SetValue(bool(self.setwchannelB[value]))\r\n                self.wavesetTc2.SetValue(self.setwwavelengths[value])\r\n\r\n        if name == 'routineselectsetv':\r\n\r\n            if self.routineselectsetv.GetValue() != '':\r\n                value = int(self.routineselectsetv.GetValue()) - 1\r\n                self.startWvlTc2.SetValue(self.setvstart[value])\r\n                self.stopWvlTc2.SetValue(self.setvstop[value])\r\n                self.stepWvlTc2.SetValue(self.setvstep[value])\r\n                self.sweepPowerTc2.SetValue(self.setvsweeppow[value])\r\n                self.sweepSpeedCb2.SetValue(self.setvsweepsped[value])\r\n                self.laserOutputCb2.SetValue(self.setvlaserout[value])\r\n                self.numSweepCb2.SetValue(self.setvnumscans[value])\r\n                self.sweepinitialrangeTc2.SetValue(self.setvinitialran[value])\r\n                self.rangedecTc2.SetValue(self.setvrangedecre[value])\r\n                self.Asel3.SetValue(bool(self.setvchannelA[value]))\r\n                self.Bsel3.SetValue(bool(self.setvchannelB[value]))\r\n                self.voltagesetTc2.SetValue(self.setvvoltages[value])\r\n\r\n\r\n\r\nclass autoMeasure(object):\r\n\r\n    def __init__(self):\r\n        self.saveFolder = os.getcwd()\r\n\r\n    def readCoordFile(self, fileName):\r\n\r\n        with open(fileName, 'r') as f:\r\n            data = f.readlines()\r\n\r\n        # Remove the first line since it is the header and remove newline char\r\n        dataStrip = [line.strip() for line in data[1:]]\r\n        dataStrip2 = []\r\n        for x in dataStrip:\r\n            j = x.replace(\" \", \"\")\r\n            dataStrip2.append(j)\r\n        # x,y,polarization,wavelength,type,deviceid,params\r\n        reg = re.compile(r'(.*),(.*),(.*),([0-9]+),(.+),(.+),(.*)')\r\n        # x,y,deviceid,padname,params\r\n        regElec = re.compile(r'(.*),(.*),(.+),(.*),(.*)')\r\n\r\n        self.devices = []\r\n\r\n        # Parse the data in each line and put it into a list of devices\r\n        for ii, line in enumerate(dataStrip2):\r\n            if reg.match(line):\r\n                matchRes = reg.findall(line)[0]\r\n                devName = matchRes[5]\r\n                device = ElectroOpticDevice(devName, matchRes[3], matchRes[2], float(matchRes[0]), float(matchRes[1]),\r\n                                            matchRes[4])\r\n                self.devices.append(device)\r\n            else:\r\n                if regElec.match(line):\r\n                    matchRes = reg.findall(line)[0]\r\n                    devName = matchRes[2]\r\n                    for device in self.devices:\r\n                        if device.getDeviceID() == devName:\r\n                            device.addElectricalCoordinates(matchRes[3], float(matchRes[0]), float(matchRes[1]))\r\n                else:\r\n                    print('Warning: The entry\\n%s\\nis not formatted correctly.' % line)\r\n\r\n\r\nif __name__ == '__main__':\r\n    app = wx.App(redirect=False)\r\n    testParameters()\r\n    app.MainLoop()\r\n    app.Destroy()\r\n    del app
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TestParameters.py b/TestParameters.py
--- a/TestParameters.py	(revision abd26e7fa73a137f488f4dfbf10def44bc04de2c)
+++ b/TestParameters.py	(date 1663700690083)
@@ -2488,29 +2488,37 @@
             j = x.replace(" ", "")
             dataStrip2.append(j)
         # x,y,polarization,wavelength,type,deviceid,params
-        reg = re.compile(r'(.*),(.*),(.*),([0-9]+),(.+),(.+),(.*)')
-        # x,y,deviceid,padname,params
-        regElec = re.compile(r'(.*),(.*),(.+),(.*),(.*)')
+        reg = re.compile(r'([0-9]+),([0-9]+),(T(E|M)),([0-9]+),(.+?),(.+),(.*)')
+        # x, y, deviceid, padname, params
+        regElec = re.compile(r'([0-9]+),([0-9]+),(.+),(.+),(.*)')
 
         self.devices = []
+        self.devSet = set()
 
         # Parse the data in each line and put it into a list of devices
         for ii, line in enumerate(dataStrip2):
             if reg.match(line):
                 matchRes = reg.findall(line)[0]
-                devName = matchRes[5]
+                devName = matchRes[6]
+                if devName in self.devSet:
+                    devName = "X:"+matchRes[0]+"Y:"+matchRes[1]+devName
+                self.devSet.add(devName)
                 device = ElectroOpticDevice(devName, matchRes[3], matchRes[2], float(matchRes[0]), float(matchRes[1]),
-                                            matchRes[4])
+                                            matchRes[5])
                 self.devices.append(device)
             else:
                 if regElec.match(line):
+                    print(line)
                     matchRes = reg.findall(line)[0]
                     devName = matchRes[2]
                     for device in self.devices:
                         if device.getDeviceID() == devName:
                             device.addElectricalCoordinates(matchRes[3], float(matchRes[0]), float(matchRes[1]))
                 else:
-                    print('Warning: The entry\n%s\nis not formatted correctly.' % line)
+                    if line == "" or line == "%X-coord,Y-coord,deviceID,padName,params":
+                        pass
+                    else:
+                        print('Warning: The entry\n%s\nis not formatted correctly.' % line)
 
 
 if __name__ == '__main__':
Index: autoMeasureTestSuite.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\nfrom autoMeasure import *\r\nimport unittest\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\nimport dummyMotorParameters\r\nimport dummyLaserParameters\r\nimport SMUParameters\r\nimport fineAlign\r\n\r\n\r\nclass TestTransformMatrix(unittest.TestCase):\r\n\r\n    def __init__(self, parent):\r\n        super(TestTransformMatrix, self).__init__(parent)\r\n        laser = dummyLaserParameters\r\n        motor = dummyMotorParameters\r\n        smu = SMUParameters\r\n        fineA = fineAlign\r\n        self.motorCoords = [[-10, 10, 300], [-10, -10, 1000], [10, -10, 10]]\r\n        self.gdsCoords = [[-10, 10, 1], [-10, -10, 1], [10, -10, 1]]\r\n\r\n        self.autoMeasure = autoMeasure(laser, motor, motor, smu, fineA)\r\n        self.TestMatrix1 = self.autoMeasure.findCoordinateTransformOpt(self.motorCoords, self.gdsCoords)\r\n\r\n    def test_Matrix_Redo(self):\r\n        plt.rcParams[\"figure.figsize\"] = [7.00, 3.50]\r\n        plt.rcParams[\"figure.autolayout\"] = True\r\n\r\n        # gds plane\r\n        A = [self.gdsCoords[0][0], self.gdsCoords[0][1], self.gdsCoords[0][2]]\r\n        B = [self.gdsCoords[1][0], self.gdsCoords[1][1], self.gdsCoords[1][2]]\r\n        C = [self.gdsCoords[2][0], self.gdsCoords[2][1], self.gdsCoords[2][2]]\r\n        v1 = [B[0] - A[0], B[1] - A[1], B[2] - A[2]]\r\n        v2 = [C[0] - A[0], C[1] - A[1], C[2] - A[2]]\r\n        n1 = np.cross(v1, v2)\r\n        n1 = -n1 / n1[2]\r\n        k1 = -(n1[0] * A[0] + n1[1] * A[1] + n1[2] * A[2])\r\n\r\n        # motor plane\r\n        D = [self.motorCoords[0][0], self.motorCoords[0][1], self.motorCoords[0][2]]\r\n        E = [self.motorCoords[1][0], self.motorCoords[1][1], self.motorCoords[1][2]]\r\n        F = [self.motorCoords[2][0], self.motorCoords[2][1], self.motorCoords[2][2]]\r\n        v3 = [E[0] - D[0], E[1] - D[1], E[2] - D[2]]\r\n        v4 = [F[0] - D[0], F[1] - D[1], F[2] - D[2]]\r\n        n2 = np.cross(v3, v4)\r\n        n2 = -n2 / n2[2]\r\n        k2 = -(n2[0] * D[0] + n2[1] * D[1] + n2[2] * D[2])\r\n\r\n        x = np.linspace(-10, 10, 100)\r\n        y = np.linspace(-10, 10, 100)\r\n\r\n        x, y = np.meshgrid(x, y)\r\n\r\n        eq1 = n1[0] * x + n1[1] * y + k1\r\n        eq2 = n2[0] * x + n2[1] * y + k2\r\n\r\n        T = self.autoMeasure.coordinate_transform_matrix(self.motorCoords, self.gdsCoords)\r\n        print(T)\r\n        oldCoords = self.gdsCoords[0]\r\n        newCoords = self.autoMeasure.perform_transform(oldCoords)\r\n\r\n        fig = plt.figure()\r\n\r\n        ax = fig.gca(projection='3d')\r\n\r\n        ax.plot_surface(x, y, eq1)\r\n        ax.plot_surface(x, y, eq2)\r\n        ax.scatter(oldCoords[0], oldCoords[1], 1, color='green')\r\n        ax.scatter(newCoords[0], newCoords[1], newCoords[2], color='red')\r\n        print(oldCoords)\r\n        print(newCoords)\r\n\r\n        plt.show()\r\n\r\n    def test_in_plane(self):\r\n\r\n        # motor plane\r\n        D = [self.motorCoords[0][0], self.motorCoords[0][1], self.motorCoords[0][2]]\r\n        E = [self.motorCoords[1][0], self.motorCoords[1][1], self.motorCoords[1][2]]\r\n        F = [self.motorCoords[2][0], self.motorCoords[2][1], self.motorCoords[2][2]]\r\n        v3 = [E[0] - D[0], E[1] - D[1], E[2] - D[2]]\r\n        v4 = [F[0] - D[0], F[1] - D[1], F[2] - D[2]]\r\n        n2 = np.cross(v3, v4)\r\n        k2 = (n2[0] * D[0] + n2[1] * D[1] + n2[2] * D[2])\r\n\r\n        T = self.autoMeasure.coordinate_transform_matrix(self.motorCoords, self.gdsCoords)\r\n        print(T)\r\n        oldCoords = self.gdsCoords[0]\r\n        newCoords = self.autoMeasure.perform_transform(oldCoords)\r\n\r\n        newEq = n2[0]*newCoords[0]+n2[1]*newCoords[1]+n2[2]*newCoords[2]\r\n        self.assertEqual(k2, newEq)\r\n\r\n    def test_new_vs_old(self):\r\n        T = self.autoMeasure.coordinate_transform_matrix(self.motorCoords, self.gdsCoords)\r\n        newCoords = self.autoMeasure.perform_transform(self.gdsCoords[0])\r\n        print(newCoords)\r\n        S = self.autoMeasure.findCoordinateTransform(self.motorCoords, self.gdsCoords)\r\n        oldCoords = self.autoMeasure.gdsToMotor(self.gdsCoords[0])\r\n        print(oldCoords)\r\n        self.assertEqual(newCoords[0][0], oldCoords[0])\r\n        self.assertAlmostEqual(newCoords[1][0], oldCoords[1], 10)\r\n\r\n\r\nif __name__ == '__main__':\r\n    unittest.main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/autoMeasureTestSuite.py b/autoMeasureTestSuite.py
--- a/autoMeasureTestSuite.py	(revision abd26e7fa73a137f488f4dfbf10def44bc04de2c)
+++ b/autoMeasureTestSuite.py	(date 1663700690099)
@@ -13,18 +13,29 @@
 class TestTransformMatrix(unittest.TestCase):
 
     def __init__(self, parent):
+        """
+        Set up for testing accuracy of transform matrix calculations.
+        Args:
+            parent: unittest.TestCase
+        """
         super(TestTransformMatrix, self).__init__(parent)
         laser = dummyLaserParameters
         motor = dummyMotorParameters
         smu = SMUParameters
         fineA = fineAlign
+        # Setting up test motor and gds coordinates
         self.motorCoords = [[-10, 10, 300], [-10, -10, 1000], [10, -10, 10]]
         self.gdsCoords = [[-10, 10, 1], [-10, -10, 1], [10, -10, 1]]
 
+        # Auto measure object used for testing
         self.autoMeasure = autoMeasure(laser, motor, motor, smu, fineA)
+
+        # Create test matrix
         self.TestMatrix1 = self.autoMeasure.findCoordinateTransformOpt(self.motorCoords, self.gdsCoords)
 
     def test_Matrix_Redo(self):
+        """Plots the motor and gds plane as well as the given and transformed point."""
+
         plt.rcParams["figure.figsize"] = [7.00, 3.50]
         plt.rcParams["figure.autolayout"] = True
 
@@ -75,6 +86,7 @@
         plt.show()
 
     def test_in_plane(self):
+        """Check whether the transformed point is within the motor plane."""
 
         # motor plane
         D = [self.motorCoords[0][0], self.motorCoords[0][1], self.motorCoords[0][2]]
@@ -94,6 +106,7 @@
         self.assertEqual(k2, newEq)
 
     def test_new_vs_old(self):
+        """Check the x and y coordinates for the motor against those calculated using the old method."""
         T = self.autoMeasure.coordinate_transform_matrix(self.motorCoords, self.gdsCoords)
         newCoords = self.autoMeasure.perform_transform(self.gdsCoords[0])
         print(newCoords)
Index: autoMeasure.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># The MIT License (MIT)\r\n\r\n\r\n# Copyright (c) 2015 Michael Caverley\r\n\r\n# Permission is hereby granted, free of charge, to any person obtaining a copy\r\n# of this software and associated documentation files (the \"Software\"), to deal\r\n# in the Software without restriction, including without limitation the rights\r\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n# copies of the Software, and to permit persons to whom the Software is\r\n# furnished to do so, subject to the following conditions:\r\n\r\n# The above copyright notice and this permission notice shall be included in\r\n# all copies or substantial portions of the Software.\r\n\r\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n# THE SOFTWARE.\r\nimport wx\r\nfrom numpy import *\r\nimport re\r\nimport os\r\nimport numpy as np\r\nfrom scipy.io import savemat\r\nimport time\r\nimport matplotlib.pyplot as plt\r\nfrom ElectroOpticDevice import ElectroOpticDevice\r\nfrom measurementRoutines import measurementRoutines\r\nfrom datetime import datetime\r\n\r\n\r\nclass autoMeasure(object):\r\n\r\n    def __init__(self, laser, motorOpt, motorElec, smu, fineAlign):\r\n        \"\"\"\r\n        Creates an autoMeasure object which is used to coordinate motors and perform automated\r\n        measurements.\r\n        Args:\r\n            laser: laser object\r\n            motorOpt: motor object controlling the chip stage\r\n            motorElec: motor object controlling the wedge probe stage\r\n            smu: smu object controls SMU\r\n            fineAlign:\r\n        \"\"\"\r\n        self.laser = laser\r\n        self.motorOpt = motorOpt\r\n        self.motorElec = motorElec\r\n        self.smu = smu\r\n        self.fineAlign = fineAlign\r\n        self.saveFolder = os.getcwd()\r\n\r\n    def readCoordFile(self, fileName):\r\n        \"\"\"\r\n        Reads a coordinate file generated using the automated coordinate extraction in k-layout.\r\n        Stores all data as a list of ElectroOpticDevice objects, self.devices.\r\n        Args:\r\n            fileName: Path to desired text file, a string\r\n        \"\"\"\r\n        with open(fileName, 'r') as f:\r\n            data = f.readlines()\r\n\r\n        # Remove the first line since it is the header and remove newline char  \r\n        dataStrip = [line.strip() for line in data[1:]]\r\n        dataStrip2 = []\r\n        for x in dataStrip:\r\n            j = x.replace(\" \", \"\")\r\n            dataStrip2.append(j)\r\n        # x,y,polarization,wavelength,type,deviceid,params\r\n        reg = re.compile(r'([0-9]+),([0-9]+),(T(E|M)),([0-9]+),(.+?),(.+),(.*)')\r\n        # x, y, deviceid, padname, params\r\n        regElec = re.compile(r'([0-9]+),([0-9]+),(.+),(.+),(.*)')\r\n\r\n        self.devices = []\r\n        self.devSet = set()\r\n\r\n        # Parse the data in each line and put it into a list of devices\r\n        for ii, line in enumerate(dataStrip2):\r\n            if reg.match(line):\r\n                matchRes = reg.findall(line)[0]\r\n                devName = matchRes[6]\r\n                if devName in self.devSet:\r\n                    devName = \"X:\"+matchRes[0]+\"Y:\"+matchRes[1]+devName\r\n                self.devSet.add(devName)\r\n                device = ElectroOpticDevice(devName, matchRes[3], matchRes[2], float(matchRes[0]), float(matchRes[1]),\r\n                                            matchRes[5])\r\n                self.devices.append(device)\r\n            else:\r\n                if regElec.match(line):\r\n                    print(line)\r\n                    matchRes = reg.findall(line)[0]\r\n                    devName = matchRes[2]\r\n                    for device in self.devices:\r\n                        if device.getDeviceID() == devName:\r\n                            device.addElectricalCoordinates(matchRes[3], float(matchRes[0]), float(matchRes[1]))\r\n                else:\r\n                    if line == \"\" or line == \"%X-coord,Y-coord,deviceID,padName,params\":\r\n                        pass\r\n                    else:\r\n                        print('Warning: The entry\\n%s\\nis not formatted correctly.' % line)\r\n\r\n    def findCoordinateTransform(self, motorCoords, gdsCoords):\r\n        \"\"\" Finds the best fit affine transform which maps the GDS coordinates to motor coordinates.\"\"\"\r\n\r\n        if len(motorCoords) != len(gdsCoords):\r\n            raise CoordinateTransformException('You must have the same number of motor coordinates and GDS coordinates')\r\n\r\n        if len(motorCoords) < 3:\r\n            raise CoordinateTransformException('You must have at least 3 coordinate pairs.')\r\n\r\n        numPairs = len(motorCoords)\r\n\r\n        X = mat(zeros((2 * numPairs, 2 * numPairs)))\r\n        Xp = mat(zeros((2 * numPairs, 1)))\r\n\r\n        for ii, motorCoord, gdsCoord in zip(range(numPairs), motorCoords, gdsCoords):\r\n            X[2 * ii, 0:3] = mat([gdsCoord[0], gdsCoord[1], 1])\r\n            X[2 * ii + 1, 3:6] = mat([gdsCoord[0], gdsCoord[1], 1])\r\n            Xp[2 * ii:2 * ii + 2] = mat([[motorCoord[0]], [motorCoord[1]]])\r\n\r\n        # Do least squares fitting\r\n        a = linalg.lstsq(X, Xp)\r\n\r\n        A = vstack((a[0][0:3].T, a[0][3:6].T, mat([0, 0, 1])))\r\n\r\n        self.transformMatrix = A\r\n\r\n        return A\r\n\r\n    def gdsToMotor(self, gdsCoords):\r\n        \"\"\" Uses the calculated affine transform to map a GDS coordinate to a motor coordinate.\"\"\"\r\n        gdsCoordVec = mat([[gdsCoords[0]], [gdsCoords[1]], [1]])\r\n        motorCoordVec = self.transformMatrix*gdsCoordVec\r\n        motorCoords = (float(motorCoordVec[0]), float(motorCoordVec[1]))\r\n        return motorCoords\r\n\r\n    def coordinate_transform_matrix(self, motorCoords, gdsCoords):\r\n\r\n        motorMatrix = np.array([[motorCoords[0][0], motorCoords[1][0], motorCoords[2][0]],\r\n                                [motorCoords[0][1], motorCoords[1][1], motorCoords[2][1]],\r\n                                [motorCoords[0][2], motorCoords[1][2], motorCoords[2][2]]])\r\n\r\n        gdsMatrix = np.array([[gdsCoords[0][0], gdsCoords[1][0], gdsCoords[2][0]],\r\n                              [gdsCoords[0][1], gdsCoords[1][1], gdsCoords[2][1]],\r\n                              [1, 1, 1]])\r\n\r\n\r\n        transpose = gdsMatrix.T\r\n\r\n        row1 = np.linalg.solve(transpose, motorMatrix[0])\r\n        row2 = np.linalg.solve(transpose, motorMatrix[1])\r\n        row3 = np.linalg.solve(transpose, motorMatrix[2])\r\n\r\n        self.T = vstack((row1, row2, row3))\r\n\r\n        print(self.T)\r\n        return self.T\r\n\r\n    def perform_transform(self, gdsCoords):\r\n\r\n        gdsVector = np.array([[gdsCoords[0]], [gdsCoords[1]], [1]])\r\n\r\n        newMotorCoords = self.T@gdsVector\r\n\r\n        return newMotorCoords\r\n\r\n    def findCoordinateTransformOpt(self, motorCoords, gdsCoords):\r\n        \"\"\" Finds the best fit affine transform which maps the GDS coordinates to motor coordinates\r\n        for the motors controlling the chip stage.\r\n\r\n        Args:\r\n            motorCoords: \r\n            gdsCoords: \r\n\r\n        Returns:\r\n            M: a matrix used to map gds coordinates to motor coordinates.\r\n        \"\"\"\r\n        motorMatrix = np.array([[motorCoords[0][0], motorCoords[1][0], motorCoords[2][0]],\r\n                                [motorCoords[0][1], motorCoords[1][1], motorCoords[2][1]],\r\n                                [motorCoords[0][2], motorCoords[1][2], motorCoords[2][2]]])\r\n\r\n        gdsMatrix = np.array([[gdsCoords[0][0], gdsCoords[1][0], gdsCoords[2][0]],\r\n                              [gdsCoords[0][1], gdsCoords[1][1], gdsCoords[2][1]],\r\n                              [1, 1, 1]])\r\n\r\n\r\n        transpose = gdsMatrix.T\r\n\r\n        row1 = np.linalg.solve(transpose, motorMatrix[0])\r\n        row2 = np.linalg.solve(transpose, motorMatrix[1])\r\n        row3 = np.linalg.solve(transpose, motorMatrix[2])\r\n\r\n        self.TMopt = vstack((row1, row2, row3))\r\n\r\n        print(self.TMopt)\r\n        return self.TMopt\r\n\r\n    def findCoordinateTransformElec(self, motorCoords, gdsCoords):\r\n        \"\"\" Finds the best fit affine transform which maps the GDS coordinates to motor coordinates\r\n        for the motors controlling the wedge probe stage.\r\n\r\n        Args:\r\n            motorCoords: \r\n            gdsCoords: \r\n\r\n        Returns:\r\n            M: a matrix used to map gds coordinates to motor coordinates.\r\n        \"\"\"\r\n        motorMatrix = np.array([[motorCoords[0][0], motorCoords[1][0], motorCoords[2][0]],\r\n                                [motorCoords[0][1], motorCoords[1][1], motorCoords[2][1]],\r\n                                [motorCoords[0][2], motorCoords[1][2], motorCoords[2][2]]])\r\n\r\n        gdsMatrix = np.array([[gdsCoords[0][0], gdsCoords[1][0], gdsCoords[2][0]],\r\n                              [gdsCoords[0][1], gdsCoords[1][1], gdsCoords[2][1]],\r\n                              [1, 1, 1]])\r\n\r\n\r\n        transpose = gdsMatrix.T\r\n\r\n        row1 = np.linalg.solve(transpose, motorMatrix[0])\r\n        row2 = np.linalg.solve(transpose, motorMatrix[1])\r\n        row3 = np.linalg.solve(transpose, motorMatrix[2])\r\n\r\n        self.TMelec = vstack((row1, row2, row3))\r\n\r\n        print(self.TMelec)\r\n        return self.TMelec\r\n\r\n    def gdsToMotorCoordsOpt(self, gdsCoords):\r\n        \"\"\" Uses the calculated affine transform to map a GDS coordinate to a motor coordinate.\r\n\r\n        Args:\r\n            gdsCoords: \r\n\r\n        Returns:\r\n            motorCoords: the motor coordinates for the chip stage that correspond to given gds\r\n            coordinates.\r\n        \"\"\"\r\n        gdsVector = np.array([[gdsCoords[0]], [gdsCoords[1]], [1]])\r\n\r\n        newMotorCoords = self.TMopt@gdsVector\r\n\r\n        return newMotorCoords\r\n\r\n    def gdsToMotorCoordsElec(self, gdsCoords):\r\n        \"\"\" Uses the calculated affine transform to map a GDS coordinate to a motor coordinate.\r\n\r\n        Args:\r\n            gdsCoords: \r\n\r\n        Returns:\r\n            object: \r\n        \"\"\"\r\n        gdsVector = np.array([[gdsCoords[0]], [gdsCoords[1]], [1]])\r\n\r\n        newMotorCoords = self.TMelec@gdsVector\r\n\r\n        return newMotorCoords\r\n\r\n    def beginMeasure(self, devices, testingParameters, checkList, abortFunction=None, updateFunction=None,\r\n                     updateGraph=True):\r\n        \"\"\" Runs an automated measurement. For each device, wedge probe is moved out of the way, chip stage is moved\r\n        so laser in aligned, wedge probe is moved to position. Various tests are performed depending on the contents\r\n        of the testing parameters file.\r\n\r\n        The sweep results, and metadata associated with the sweep are stored in a data file which is saved to the folder specified\r\n        in self.saveFolder. An optional abort function can be specified which is called to determine if the measurement process should\r\n        be stopped. Also, an update function is called which can be used to update UI elements about the measurement progress.\r\n\r\n        Args:\r\n            devices: \r\n            testingParameters: \r\n            abortFunction: \r\n            updateFunction: \r\n            updateGraph:\r\n\r\n        Returns:\r\n            object: \"\"\"\r\n\r\n        self.checkList = checkList\r\n        chipdatetimestart = datetime.now()\r\n        for i, d in enumerate(testingParameters['device']):\r\n            for device in devices:\r\n                if device.getDeviceID == d:\r\n\r\n                    gdsCoordOpt = (device.getOpticalCoordinates[0], device.getOpticalCoordinates[1])\r\n                    motorCoordOpt = self.gdsToMotorCoordsOpt(gdsCoordOpt)\r\n                    gdsCoordElec = (device.getElectricalCoordinates[0], device.getElectricalicalCoordinates[1])\r\n                    motorCoordElec = self.gdsToMotorCoordsElec(gdsCoordElec)\r\n\r\n                    # move wedge probe out of the way\r\n                    self.motorElec.moveRelativeXYZElec(motorCoordElec[0], -2000, 2000)\r\n                    # move chip stage\r\n                    x = motorCoordOpt[0] - self.motorOpt.getPosition[0]\r\n                    y = motorCoordOpt[1] - self.motorOpt.getPosition[1]\r\n                    z = motorCoordOpt[2] - self.motorOpt.getPosition[2]\r\n                    self.motorOpt.moveAbsoluteXYZOpt(motorCoordOpt[0], motorCoordOpt[1], motorCoordOpt[2])\r\n                    # Move wedge probe and compensate for movement of chip stage\r\n                    self.motorElec.moveAbsoluteXYZElec(motorCoordElec[0] + x, motorCoordElec[1] + y,\r\n                                                       motorCoordElec[2] + z)\r\n\r\n                    res, completed = self.fineAlign.doFineAlign()\r\n                    if completed is False:\r\n                        for ii in range(self.checkList.GetItemCount()):\r\n                            if self.devices[self.checkList.GetItemData(ii)].getDeviceID() == device.getDeviceID:\r\n                                self.checkList.SetItemTextColour(ii, wx.Colour(255, 0, 0))\r\n\r\n                    if testingParameters['ELECflag'][i] is True:\r\n                        elecdatetimestart = datetime.now()\r\n                        measurementRoutines('ELEC', testingParameters, i, self.smu, self.laser)\r\n                        elecdatetimeend = datetime.now()\r\n                    if testingParameters['OPTICflag'][i] is True:\r\n                        opticdatetimestart = datetime.now()\r\n                        measurementRoutines('OPT', testingParameters, i, self.smu, self.laser)\r\n                        opticdatetimeend = datetime.now()\r\n                    if testingParameters['setwflag'] is True:\r\n                        setwdatetimestart = datetime.now()\r\n                        measurementRoutines('FIXWAVIV', testingParameters, i, self.smu, self.laser)\r\n                        setwdatetimeend = datetime.now()\r\n                    if testingParameters['setvflag'] is True:\r\n                        setvdatetimestart = datetime.now()\r\n                        measurementRoutines('BIASVOPT', testingParameters, i, self.smu, self.laser)\r\n                        setvdatetimeend = datetime.now()\r\n\r\n                    print('GDS: (%g,%g) Motor: (%g,%g,%g)' % (gdsCoordOpt[0], gdsCoordOpt[1], gdsCoordOpt[2],\r\n                                                              motorCoordOpt[0], motorCoordOpt[1]))\r\n                    matFileName = os.path.join(self.saveFolder, d + '.mat')\r\n\r\n                    # Save sweep data and metadata to the mat file\r\n                    matDict = dict()\r\n                    matDict['scandata'] = dict()\r\n                    matDict['metadata'] = dict()\r\n                    matDict['scandata']['wavelength'] = testingParameters['Wavelengths'][i] #fix this\r\n                    matDict['scandata']['power'] = testingParameters['Sweeppower'][i] #fix this\r\n                    matDict['metadata']['device'] = d\r\n                    matDict['metadata']['gds_x_coord'] = device.getOpticalCoordinates[0]\r\n                    matDict['metadata']['gds_y_coord'] = device.getOpticalCoordinates[1]\r\n                    matDict['metadata']['motor_x_coord'] = motorCoordOpt[0]\r\n                    matDict['metadata']['motor_y_coord'] = motorCoordOpt[1]\r\n                    matDict['metadata']['motor_z_coord'] = motorCoordOpt[2]\r\n                    matDict['metadata']['measured_device_number'] = i\r\n                    timeSeconds = time.time()\r\n                    matDict['metadata']['time_seconds'] = timeSeconds\r\n                    matDict['metadata']['time_str'] = time.ctime(timeSeconds)\r\n\r\n                    savemat(matFileName, matDict)\r\n\r\n                    pdfFileName = os.path.join(self.saveFolder, d + '.pdf')\r\n                    plt.figure()\r\n                    plt.plot(testingParameters['Wavelengths'][i] * 1e9, testingParameters['Sweeppower'][i])\r\n                    plt.xlabel('Wavelength (nm)')\r\n                    plt.ylabel('Power (dBm)')\r\n                    plt.savefig(pdfFileName)\r\n                    plt.close()\r\n\r\n\r\n                    if testingParameters['ELECflag'][i] == True:\r\n\r\n                        if testingParameters['IV'] == True:\r\n\r\n                            if testingParameters['Voltsel'] == True:\r\n                                length = (testingParameters['VoltageMax'][i] - testingParameters['VoltageMin'][i]) / testingParameters['VoltRes'][i]\r\n                                dependentarray = []\r\n                                w = testingParameters['VoltageMin'][i]\r\n                                for x in range(length):\r\n                                    dependentarray.append(w)\r\n                                    w = w + testingParameters['VoltRes'][i]\r\n\r\n                                independentarray = []\r\n\r\n                                pdfFileName = os.path.join(self.saveFolder, d + '_IV_elec.pdf')\r\n                                plt.figure()\r\n                                plt.plot(dependentarray, testingParameters['Sweeppower'][i]) #####fix\r\n                                plt.xlabel('Voltage (V)')\r\n                                plt.ylabel('Current (mA)')\r\n                                plt.savefig(pdfFileName)\r\n\r\n                            if testingParameters['Currentsel'] == True:\r\n\r\n                                length = (testingParameters['CurrentMax'][i] - testingParameters['CurrentMin'][i]) / \\\r\n                                         testingParameters['CurrentRes'][i]\r\n                                dependentarray = []\r\n                                w = testingParameters['CurrentMin'][i]\r\n                                for x in range(length):\r\n                                    dependentarray.append(w)\r\n                                    w = w + testingParameters['CurrentRes'][i]\r\n\r\n                                independentarray = []\r\n\r\n                                pdfFileName = os.path.join(self.saveFolder, d + '_IV_elec.pdf')\r\n                                plt.figure()\r\n                                plt.plot(dependentarray, testingParameters['Sweeppower'][i])  ####fix\r\n                                plt.xlabel('Current (mA)')\r\n                                plt.ylabel('Voltage (V)')\r\n                                plt.savefig(pdfFileName)\r\n\r\n                            csvFileName = os.path.join(self.saveFolder, d + '_IV_elec.csv')\r\n                            ax = plt.gca()\r\n                            line = ax.lines[0]\r\n                            x = line.get_xdata()\r\n                            y = line.get_ydata()\r\n                            plt.close()\r\n\r\n                            with open(csvFileName, 'w', newline='') as f:\r\n                                f.write('#Test: Electrical Sweep')\r\n                                f.write('#User:')\r\n                                f.write('#Start:' + str(elecdatetimestart) + '\\n')\r\n                                f.write('#Finish:' + str(elecdatetimeend) + '\\n')\r\n                                f.write('#Device ID:' + str(testingParameters['device'][i]) + '\\n')\r\n                                f.write('#Device Coordinates (gds):\\n')\r\n                                f.write('#Device Coordinates (motor):\\n')\r\n                                f.write('#Chip test start:' + str(chipdatetimestart) + '\\n')\r\n\r\n                                f.write('#Settings:\\n')\r\n                                f.write('#Laser:\\n')\r\n                                f.write('#Detector:' + '\\n')\r\n                                f.write('#Sweep speed: N/A' + '\\n')\r\n                                f.write('#Number of datasets:\\n')\r\n                                f.write('#Laser Power: N/A' + '\\n')\r\n                                f.write('#Wavelength step-size: N/A' + '\\n')\r\n                                f.write('#Start Wavelength: N/A' + '\\n')\r\n                                f.write('#Stop Wavelength: N/A' + '\\n')\r\n                                f.write('#Stitch count:' + '\\n')\r\n                                f.write('#Init Range:\\n')\r\n                                f.write('#New sweep plot behaviour:\\n')\r\n                                f.write('#Turn off laser when done:\\n')\r\n                                f.write('#Metric Tag:\\n')\r\n                                f.write('#wavelength:\\n')\r\n                                f.write('#channel_1:\\n')\r\n                                f.write('#channel_2:\\n')\r\n                                f.write('#channel_3:\\n')\r\n                                f.write('#channel_4:\\n')\r\n\r\n                        if testingParameters['RV'] == True:\r\n\r\n                            if testingParameters['Voltsel'] == True:\r\n\r\n                                length = (testingParameters['VoltageMax'][i] - testingParameters['VoltageMin'][i]) / \\\r\n                                         testingParameters['VoltRes'][i]\r\n                                dependentarray = []\r\n                                w = testingParameters['VoltageMin'][i]\r\n                                for x in range(length):\r\n                                    dependentarray.append(w)\r\n                                    w = w + testingParameters['VoltRes'][i]\r\n\r\n                                independentarray = []\r\n\r\n                                pdfFileName = os.path.join(self.saveFolder, d + '_RV_elec.pdf')\r\n                                plt.figure()\r\n                                plt.plot(dependentarray, testingParameters['Sweeppower'][i])  #####fix\r\n                                plt.xlabel('Voltage (V)')\r\n                                plt.ylabel('Resistance (mA)')\r\n                                plt.savefig(pdfFileName)\r\n\r\n                            if testingParameters['Currentsel'] == True:\r\n\r\n                                length = (testingParameters['CurrentMax'][i] - testingParameters['CurrentMin'][i]) / \\\r\n                                         testingParameters['CurrentRes'][i]\r\n                                dependentarray = []\r\n                                w = testingParameters['CurrentMin'][i]\r\n                                for x in range(length):\r\n                                    dependentarray.append(w)\r\n                                    w = w + testingParameters['CurrentRes'][i]\r\n\r\n                                independentarray = []\r\n\r\n                                pdfFileName = os.path.join(self.saveFolder, d + '_RV_elec.pdf')\r\n                                plt.figure()\r\n                                plt.plot(dependentarray, testingParameters['Sweeppower'][i])  #####fix\r\n                                plt.xlabel('Current (mA)')\r\n                                plt.ylabel('Resistance (mA)')\r\n                                plt.savefig(pdfFileName)\r\n\r\n                            csvFileName = os.path.join(self.saveFolder, d + 'elec.csv')\r\n                            ax = plt.gca()\r\n                            line = ax.lines[0]\r\n                            x = line.get_xdata()\r\n                            y = line.get_ydata()\r\n\r\n                            plt.close()\r\n\r\n                            with open(csvFileName, 'w', newline='') as f:\r\n                                f.write('#Test: Electrical Sweep')\r\n                                f.write('#User:')\r\n                                f.write('#Start:' + str(elecdatetimestart) + '\\n')\r\n                                f.write('#Finish:' + str(elecdatetimeend) + '\\n')\r\n                                f.write('#Device ID:' + str(testingParameters['device'][i]) + '\\n')\r\n                                f.write('#Device Coordinates (gds):\\n')\r\n                                f.write('#Device Coordinates (motor):\\n')\r\n                                f.write('#Chip test start:' + str(chipdatetimestart) + '\\n')\r\n\r\n                                f.write('#Settings:\\n')\r\n                                f.write('#Laser:\\n')\r\n                                f.write('#Detector:' + '\\n')\r\n                                f.write('#Sweep speed: N/A' + '\\n')\r\n                                f.write('#Number of datasets:\\n')\r\n                                f.write('#Laser Power: NA' + '\\n')\r\n                                f.write('#Wavelength step-size: NA' + '\\n')\r\n                                f.write('#Start Wavelength: N/A' + '\\n')\r\n                                f.write('#Stop Wavelength: N/A' + '\\n')\r\n                                f.write('#Stitch count:' + '\\n')\r\n                                f.write('#Init Range:\\n')\r\n                                f.write('#New sweep plot behaviour:\\n')\r\n                                f.write('#Turn off laser when done:\\n')\r\n                                f.write('#Metric Tag:\\n')\r\n                                f.write('#wavelength:\\n')\r\n                                f.write('#channel_1:\\n')\r\n                                f.write('#channel_2:\\n')\r\n                                f.write('#channel_3:\\n')\r\n                                f.write('#channel_4:\\n')\r\n\r\n                        if testingParameters['PV'] == True:\r\n\r\n                            if testingParameters['Voltsel'] == True:\r\n\r\n                                length = (testingParameters['VoltageMax'][i] - testingParameters['VoltageMin'][i]) / \\\r\n                                         testingParameters['VoltRes'][i]\r\n                                dependentarray = []\r\n                                w = testingParameters['VoltageMin'][i]\r\n                                for x in range(length):\r\n                                    dependentarray.append(w)\r\n                                    w = w + testingParameters['VoltRes'][i]\r\n\r\n                                independentarray = []\r\n\r\n                                pdfFileName = os.path.join(self.saveFolder, d + '_PV_elec.pdf')\r\n                                plt.figure()\r\n                                plt.plot(dependentarray, testingParameters['Sweeppower'][i])  #####fix\r\n                                plt.xlabel('Voltage (V)')\r\n                                plt.ylabel('Power (mW)')\r\n                                plt.savefig(pdfFileName)\r\n\r\n                            if testingParameters['Currentsel'] == True:\r\n\r\n                                length = (testingParameters['CurrentMax'][i] - testingParameters['CurrentMin'][i]) / \\\r\n                                         testingParameters['CurrentRes'][i]\r\n                                dependentarray = []\r\n                                w = testingParameters['CurrentMin'][i]\r\n                                for x in range(length):\r\n                                    dependentarray.append(w)\r\n                                    w = w + testingParameters['CurrentRes'][i]\r\n\r\n                                independentarray = []\r\n\r\n                                pdfFileName = os.path.join(self.saveFolder, d + '_PV_elec.pdf')\r\n                                plt.figure()\r\n                                plt.plot(dependentarray, testingParameters['Sweeppower'][i])  #####fix\r\n                                plt.xlabel('Current (mA)')\r\n                                plt.ylabel('Power (mW)')\r\n                                plt.savefig(pdfFileName)\r\n\r\n                            pdfFileName = os.path.join(self.saveFolder, d + 'PV_elec.pdf')\r\n                            plt.figure()\r\n                            plt.plot(testingParameters['Wavelengths'][i] * 1e9, testingParameters['Sweeppower'][i])\r\n                            plt.xlabel('Wavelength (nm)')\r\n                            plt.ylabel('Power (dBm)')\r\n                            plt.savefig(pdfFileName)\r\n\r\n                            csvFileName = os.path.join(self.saveFolder, d + 'PV_elec.csv')\r\n                            ax = plt.gca()\r\n                            line = ax.lines[0]\r\n                            x = line.get_xdata()\r\n                            y = line.get_ydata()\r\n\r\n                            plt.close()\r\n\r\n                            with open(csvFileName, 'w', newline='') as f:\r\n                                f.write('#Test: Electrical Sweep')\r\n                                f.write('#User:')\r\n                                f.write('#Start:' + str(elecdatetimestart) + '\\n')\r\n                                f.write('#Finish:' + str(elecdatetimeend) + '\\n')\r\n                                f.write('#Device ID:' + str(testingParameters['device'][i]) + '\\n')\r\n                                f.write('#Device Coordinates (gds):\\n')\r\n                                f.write('#Device Coordinates (motor):\\n')\r\n                                f.write('#Chip test start:' + str(chipdatetimestart) + '\\n')\r\n\r\n                                f.write('#Settings:\\n')\r\n                                f.write('#Laser:\\n')\r\n                                f.write('#Detector:' + '\\n')\r\n                                f.write('#Sweep speed: N/A' + '\\n')\r\n                                f.write('#Number of datasets:\\n')\r\n                                f.write('#Laser Power: NA' + '\\n')\r\n                                f.write('#Wavelength step-size: NA' + '\\n')\r\n                                f.write('#Start Wavelength: N/A' + '\\n')\r\n                                f.write('#Stop Wavelength: N/A' + '\\n')\r\n                                f.write('#Stitch count:' + '\\n')\r\n                                f.write('#Init Range:\\n')\r\n                                f.write('#New sweep plot behaviour:\\n')\r\n                                f.write('#Turn off laser when done:\\n')\r\n                                f.write('#Metric Tag:\\n')\r\n                                f.write('#wavelength:\\n')\r\n                                f.write('#channel_1:\\n')\r\n                                f.write('#channel_2:\\n')\r\n                                f.write('#channel_3:\\n')\r\n                                f.write('#channel_4:\\n')\r\n\r\n\r\n                    if testingParameters['OPTICflag'][i] == True:\r\n\r\n                        opticwavelengtharray = []\r\n                        length = (testingParameters['Stop'][i] - testingParameters['Start'][i]) / \\\r\n                                 testingParameters['Stepsize'][i]\r\n                        c = testingParameters['Start'][i]\r\n\r\n                        for x in range(length):\r\n                            opticwavelengtharray.append(c)\r\n                            c = c + testingParameters['Stepsize']\r\n\r\n                        pdfFileName = os.path.join(self.saveFolder, d + '_optic.pdf')\r\n                        plt.figure()\r\n                        plt.plot(testingParameters['Wavelengths'][i] * 1e9, testingParameters['Sweeppower'][i])# fix\r\n                        plt.xlabel('Wavelength (nm)')\r\n                        plt.ylabel('Power (dBm)')\r\n                        plt.savefig(pdfFileName)\r\n\r\n                        csvFileName = os.path.join(self.saveFolder, d + '_optic.csv')\r\n                        ax = plt.gca()\r\n                        line = ax.lines[0]\r\n                        x = line.get_xdata()\r\n                        y = line.get_ydata()\r\n\r\n                        with open(csvFileName, 'w', newline='') as f:\r\n\r\n                            f.write('#Test: Optical Sweep' )\r\n                            f.write('#User:')\r\n                            f.write('#Start:' + str(opticdatetimestart) + '\\n')\r\n                            f.write('#Finish:' + str(opticdatetimeend) + '\\n')\r\n                            f.write('#Device ID:' + str(testingParameters['device'][i]) + '\\n')\r\n                            f.write('#Device Coordinates (gds):\\n')\r\n                            f.write('#Device Coordinates (motor):\\n')\r\n                            f.write('#Chip test start:' + str(chipdatetimestart) + '\\n')\r\n\r\n                            f.write('#Settings:\\n')\r\n                            f.write('#Laser:\\n')\r\n                            f.write('#Detector:')\r\n                            f.write('#Sweep speed:' + testingParameters['Sweepspeed'] + '\\n')\r\n                            f.write('#Number of datasets:\\n')\r\n                            f.write('#Laser Power:' + testingParameters['Sweeppower'])\r\n                            f.write('#Wavelength step-size:' + testingParameters['setvStepsize'] + '\\n')\r\n                            f.write('#Start Wavelength:' + testingParameters['Start'][i] + '\\n')\r\n                            f.write('#Stop Wavelength:' + testingParameters['Stop'][i] + '\\n')\r\n                            f.write('#Stitch count:')\r\n                            f.write('#Init Range:\\n')\r\n                            f.write('#New sweep plot behaviour:\\n')\r\n                            f.write('#Turn off laser when done:\\n')\r\n                            f.write('#Metric Tag:\\n')\r\n\r\n                            f.write('#wavelength:')\r\n                            for x in opticwavelengtharray:\r\n                                f.write(str(x) + ',')\r\n                            f.write('#channel_1:\\n')\r\n                            f.write('#channel_2:\\n')\r\n                            f.write('#channel_3:\\n')\r\n                            f.write('#channel_4:\\n')\r\n\r\n                    if testingParameters['setwflag'][i] == True:\r\n\r\n                        pdfFileName = os.path.join(self.saveFolder, d + '_setw.pdf')\r\n                        plt.figure()\r\n                        plt.plot(testingParameters['Wavelengths'][i] * 1e9, testingParameters['Sweeppower'][i])\r\n                        plt.xlabel('Wavelength (nm)')\r\n                        plt.ylabel('Power (dBm)')\r\n                        plt.savefig(pdfFileName)\r\n\r\n                        csvFileName = os.path.join(self.saveFolder, d + 'setw.csv')\r\n                        ax = plt.gca()\r\n                        line = ax.lines[0]\r\n                        x = line.get_xdata()\r\n                        y = line.get_ydata()\r\n\r\n                        with open(csvFileName, 'w', newline='') as f:\r\n\r\n\r\n                            f.write('#Test: Set wavelength, voltage sweep' + '\\n')\r\n                            f.write('#User:')\r\n                            f.write('#Start:' + str(setwdatetimestart) + '\\n')\r\n                            f.write('#Finish:' + str(setwdatetimeend) + '\\n')\r\n                            f.write('#Device ID:' + str(testingParameters['device'][i]) + '\\n')\r\n                            f.write('#Device Coordinates (gds):\\n')\r\n                            f.write('#Device Coordinates (motor):\\n')\r\n                            f.write('#Chip test start:' + str(chipdatetimestart) + '\\n')\r\n\r\n                            f.write('#Settings:\\n')\r\n                            f.write('#Laser:\\n')\r\n                            f.write('#Detector:\\n')\r\n                            f.write('#Sweep speed:\\n')\r\n                            f.write('#Number of datasets:\\n')\r\n                            f.write('#Laser Power:\\n')\r\n                            f.write('#Wavelength step-size:' + testingParameters['setwVoltres'] + '\\n')\r\n                            f.write('#Start Wavelength:' + testingParameters['setvStart'][i] + '\\n')\r\n                            f.write('#Stop Wavelength:' + testingParameters['setvStart'][i] + '\\n')\r\n                            f.write('#Stitch count:\\n')\r\n                            f.write('#Init Range:\\n')\r\n                            f.write('#New sweep plot behaviour:\\n')\r\n                            f.write('#Turn off laser when done:\\n')\r\n                            f.write('#Metric Tag:\\n')\r\n                            f.write('#wavelength:\\n')\r\n                            f.write('#channel_1:\\n')\r\n                            f.write('#channel_2:\\n')\r\n                            f.write('#channel_3:\\n')\r\n                            f.write('#channel_4:\\n')\r\n\r\n                    if testingParameters['setvflag'][i] == True:\r\n\r\n                        setvwavelengtharray = []\r\n                        length = (testingParameters['setvstop'][i] - testingParameters['setvstart'][i]) / testingParameters['setvStepsize']\r\n                        c = testingParameters['setvstart']\r\n\r\n                        for x in range(length):\r\n                            setvwavelengtharray.append(c)\r\n                            c = c + testingParameters['setvStepsize']\r\n\r\n\r\n\r\n                        pdfFileName = os.path.join(self.saveFolder, d + '_setv.pdf')\r\n                        plt.figure()\r\n                        plt.plot(setvwavelengtharray, power) #fix this\r\n                        plt.xlabel('Wavelength (nm)')\r\n                        plt.ylabel('Power (dBm)')\r\n                        plt.savefig(pdfFileName)\r\n\r\n\r\n                        csvFileName = os.path.join(self.saveFolder, d + 'setv.csv')\r\n                        ax = plt.gca()\r\n                        line = ax.lines[0]\r\n                        x = line.get_xdata()\r\n                        y = line.get_ydata()\r\n\r\n                        with open(csvFileName, 'w', newline='') as f:\r\n\r\n                            f.write('#Test: Set Voltage wavelength Sweep' + '\\n')\r\n                            f.write('#User:')\r\n                            f.write('#Start:' + str(setvdatetimestart) + '\\n')\r\n                            f.write('#Finish:' + str(setvdatetimeend) + '\\n')\r\n                            f.write('#Device ID:' + str(testingParameters['device'][i]) + '\\n')\r\n                            f.write('#Device Coordinates (gds):\\n')\r\n                            f.write('#Device Coordinates (motor):\\n')\r\n                            f.write('#Chip test start:')\r\n                            f.write('#Settings:\\n')\r\n                            f.write('#Laser:\\n')\r\n                            f.write('#Detector:')\r\n                            f.write('#Sweep speed:' + testingParameters['setvSweepspeed'] + '\\n')\r\n                            f.write('#Number of datasets:\\n')\r\n                            f.write('#Laser Power:' + testingParameters['setvStepsize'] + '\\n')\r\n                            f.write('#Wavelength step-size:' + testingParameters['setvStepsize'] + '\\n')\r\n                            f.write('#Start Wavelength:' + testingParameters['setvStart'][i] + '\\n')\r\n                            f.write('#Stop Wavelength:' + testingParameters['setvStart'][i] + '\\n')\r\n                            f.write('#Stitch count:')\r\n                            f.write('#Init Range:\\n')\r\n                            f.write('#New sweep plot behaviour:\\n')\r\n                            f.write('#Turn off laser when done:\\n')\r\n                            f.write('#Metric Tag:\\n')\r\n                            f.write('#wavelength:\\n')\r\n                            f.write('#channel_1:\\n')\r\n                            f.write('#channel_2:\\n')\r\n                            f.write('#channel_3:\\n')\r\n                            f.write('#channel_4:\\n')\r\n\r\n\r\n\r\n\r\n\r\n\r\n            if abortFunction is not None and abortFunction():\r\n                print('Aborted')\r\n                return\r\n            if updateFunction is not None:\r\n                updateFunction(i)\r\n\r\n\r\nclass CoordinateTransformException(Exception):\r\n    pass\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/autoMeasure.py b/autoMeasure.py
--- a/autoMeasure.py	(revision abd26e7fa73a137f488f4dfbf10def44bc04de2c)
+++ b/autoMeasure.py	(date 1663700850141)
@@ -44,7 +44,7 @@
             motorOpt: motor object controlling the chip stage
             motorElec: motor object controlling the wedge probe stage
             smu: smu object controls SMU
-            fineAlign:
+            fineAlign: fineAlign object
         """
         self.laser = laser
         self.motorOpt = motorOpt
@@ -103,7 +103,8 @@
                         print('Warning: The entry\n%s\nis not formatted correctly.' % line)
 
     def findCoordinateTransform(self, motorCoords, gdsCoords):
-        """ Finds the best fit affine transform which maps the GDS coordinates to motor coordinates."""
+        ## OLD METHOD: USED FOR TESTING
+        """ Finds the affine transform matrix which maps the GDS coordinates to motor coordinates."""
 
         if len(motorCoords) != len(gdsCoords):
             raise CoordinateTransformException('You must have the same number of motor coordinates and GDS coordinates')
@@ -131,6 +132,7 @@
         return A
 
     def gdsToMotor(self, gdsCoords):
+        ## OLD METHOD: USED FOR TESTING
         """ Uses the calculated affine transform to map a GDS coordinate to a motor coordinate."""
         gdsCoordVec = mat([[gdsCoords[0]], [gdsCoords[1]], [1]])
         motorCoordVec = self.transformMatrix*gdsCoordVec
@@ -138,7 +140,8 @@
         return motorCoords
 
     def coordinate_transform_matrix(self, motorCoords, gdsCoords):
-
+        ## FOR TESTING PURPOSES
+        """ Finds the affine transform matrix which maps the GDS coordinates to motor coordinates."""
         motorMatrix = np.array([[motorCoords[0][0], motorCoords[1][0], motorCoords[2][0]],
                                 [motorCoords[0][1], motorCoords[1][1], motorCoords[2][1]],
                                 [motorCoords[0][2], motorCoords[1][2], motorCoords[2][2]]])
@@ -160,7 +163,8 @@
         return self.T
 
     def perform_transform(self, gdsCoords):
-
+        ## FOR TESTING PURPOSES
+        """ Uses the calculated affine transform to map a GDS coordinate to a motor coordinate."""
         gdsVector = np.array([[gdsCoords[0]], [gdsCoords[1]], [1]])
 
         newMotorCoords = self.T@gdsVector
@@ -172,8 +176,8 @@
         for the motors controlling the chip stage.
 
         Args:
-            motorCoords: 
-            gdsCoords: 
+            motorCoords: A list of motor coordinates from the three devices used for alignment
+            gdsCoords: A list of gds coordinates from the three devices used for alignment
 
         Returns:
             M: a matrix used to map gds coordinates to motor coordinates.
@@ -203,8 +207,8 @@
         for the motors controlling the wedge probe stage.
 
         Args:
-            motorCoords: 
-            gdsCoords: 
+            motorCoords: A list of motor coordinates from the three devices used for alignment
+            gdsCoords: A list of gds coordinates from the three devices used for alignment
 
         Returns:
             M: a matrix used to map gds coordinates to motor coordinates.
@@ -233,7 +237,7 @@
         """ Uses the calculated affine transform to map a GDS coordinate to a motor coordinate.
 
         Args:
-            gdsCoords: 
+            gdsCoords: The gds coordinates of a device
 
         Returns:
             motorCoords: the motor coordinates for the chip stage that correspond to given gds
@@ -249,10 +253,11 @@
         """ Uses the calculated affine transform to map a GDS coordinate to a motor coordinate.
 
         Args:
-            gdsCoords: 
+            gdsCoords: The gds coordinates of a device
 
         Returns:
-            object: 
+            object: the motor coordinates for the wedge probe stage that correspond to given gds
+            coordinates.
         """
         gdsVector = np.array([[gdsCoords[0]], [gdsCoords[1]], [1]])
 
@@ -271,16 +276,16 @@
         be stopped. Also, an update function is called which can be used to update UI elements about the measurement progress.
 
         Args:
-            devices: 
-            testingParameters: 
-            abortFunction: 
-            updateFunction: 
-            updateGraph:
-
-        Returns:
-            object: """
+            devices: list of device ids for devices to be tested
+            testingParameters: testing parameters dictionary created from testing parameters tab or csv upload
+            checkList: checklist object from autoMeasurePanel
+            abortFunction: optional function used to determine when to stop measurement
+            updateFunction: optional function can be used to update UI elements
+            updateGraph: Whether to update the graph in the autoMeasurePanel with each measurement."""
 
         self.checkList = checkList
+
+        # For each device
         chipdatetimestart = datetime.now()
         for i, d in enumerate(testingParameters['device']):
             for device in devices:
@@ -293,21 +298,27 @@
 
                     # move wedge probe out of the way
                     self.motorElec.moveRelativeXYZElec(motorCoordElec[0], -2000, 2000)
+
                     # move chip stage
                     x = motorCoordOpt[0] - self.motorOpt.getPosition[0]
                     y = motorCoordOpt[1] - self.motorOpt.getPosition[1]
                     z = motorCoordOpt[2] - self.motorOpt.getPosition[2]
                     self.motorOpt.moveAbsoluteXYZOpt(motorCoordOpt[0], motorCoordOpt[1], motorCoordOpt[2])
+
                     # Move wedge probe and compensate for movement of chip stage
                     self.motorElec.moveAbsoluteXYZElec(motorCoordElec[0] + x, motorCoordElec[1] + y,
                                                        motorCoordElec[2] + z)
 
+                    # Fine align to device
                     res, completed = self.fineAlign.doFineAlign()
+
+                    # If fine align fails change text colour of device to red in the checklist
                     if completed is False:
                         for ii in range(self.checkList.GetItemCount()):
                             if self.devices[self.checkList.GetItemData(ii)].getDeviceID() == device.getDeviceID:
                                 self.checkList.SetItemTextColour(ii, wx.Colour(255, 0, 0))
 
+                    # Check which type of measurement is to be completed
                     if testingParameters['ELECflag'][i] is True:
                         elecdatetimestart = datetime.now()
                         measurementRoutines('ELEC', testingParameters, i, self.smu, self.laser)
@@ -327,6 +338,8 @@
 
                     print('GDS: (%g,%g) Motor: (%g,%g,%g)' % (gdsCoordOpt[0], gdsCoordOpt[1], gdsCoordOpt[2],
                                                               motorCoordOpt[0], motorCoordOpt[1]))
+
+                    # Create matlab file
                     matFileName = os.path.join(self.saveFolder, d + '.mat')
 
                     # Save sweep data and metadata to the mat file
@@ -348,6 +361,7 @@
 
                     savemat(matFileName, matDict)
 
+                    # Create pdf file
                     pdfFileName = os.path.join(self.saveFolder, d + '.pdf')
                     plt.figure()
                     plt.plot(testingParameters['Wavelengths'][i] * 1e9, testingParameters['Sweeppower'][i])
Index: instrumentFrame_withtabs.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># The MIT License (MIT)\r\n\r\n# Copyright (c) 2015 Michael Caverley\r\n\r\n# Permission is hereby granted, free of charge, to any person obtaining a copy\r\n# of this software and associated documentation files (the \"Software\"), to deal\r\n# in the Software without restriction, including without limitation the rights\r\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n# copies of the Software, and to permit persons to whom the Software is\r\n# furnished to do so, subject to the following conditions:\r\n\r\n# The above copyright notice and this permission notice shall be included in\r\n# all copies or substantial portions of the Software.\r\n\r\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n# THE SOFTWARE.\r\n\r\nimport wx\r\nfrom outputlogPanel import outputlogPanel\r\nimport sys\r\nfrom fineAlign import fineAlign\r\nfrom fineAlignPanel import fineAlignPanel\r\nimport traceback\r\nfrom logWriter import logWriter, logWriterError\r\nfrom autoMeasurePanel import autoMeasurePanel\r\nfrom autoMeasure import autoMeasure\r\nimport laserPanel\r\nfrom laserPanel import detectorPanel\r\nfrom laserPanel import tlsPanel\r\nfrom hp816x_N77Det_instr import hp816x_N77Det\r\nimport myMatplotlibPanel\r\nimport pyvisa as visa\r\nfrom TestParameters import testParameters\r\nfrom TestParameters import TopPanel\r\n\r\n\r\n# Define the tab content as classes:\r\nclass HomeTab(wx.Panel):\r\n    def __init__(self, parent, instList):\r\n        \"\"\"\r\n\r\n        Args:\r\n            parent:\r\n            instList:\r\n        \"\"\"\r\n        wx.Panel.__init__(self, parent)\r\n        self.instList = instList\r\n        vbox = wx.BoxSizer(wx.VERTICAL)\r\n        hbox = wx.BoxSizer(wx.HORIZONTAL)\r\n        homeVbox = wx.BoxSizer(wx.VERTICAL)\r\n\r\n        self.graph = myMatplotlibPanel.myMatplotlibPanel(self)  # use for regular mymatplotlib file\r\n        hbox.Add(self.graph, flag=wx.EXPAND, border=0, proportion=1)\r\n\r\n        for inst in self.instList:\r\n            # if inst.isSMU:\r\n            # panel = inst.panelClass(self)\r\n            # else:\r\n            if inst.isDetect:\r\n                panel = inst.panelClass(self, inst, True, False)\r\n            elif inst.isLaser:\r\n                panel = inst.panelClass(self, inst, True, True)\r\n            else:\r\n                panel = inst.panelClass(self, inst)\r\n\r\n            # homeVbox = wx.BoxSizer(wx.VERTICAL)\r\n\r\n            if inst.isMotor:\r\n                homeVbox.Add(panel, proportion=0, border=0, flag=wx.EXPAND)\r\n                self.fineAlign = fineAlign(self.getLasers()[0], self.getMotors()[0])\r\n                try:\r\n                    self.fineAlignPanel = fineAlignPanel(self, self.fineAlign)\r\n                except Exception as e:\r\n                    dial = wx.MessageDialog(None, 'Could not initiate instrument control. ' + traceback.format_exc(),\r\n                                            'Error', wx.ICON_ERROR)\r\n                    dial.ShowModal()\r\n                homeVbox.Add(self.fineAlignPanel, proportion=0, flag=wx.EXPAND)\r\n                # if self.motorFound():\r\n                #   hbox.Add(homeVbox)\r\n            if inst.isDetect:\r\n                homeVbox.Add(panel, proportion=0, border=0, flag=wx.EXPAND)\r\n                # self.detectorPanel = detectorPanel(panel, inst.getNumPWMChannels(), inst)\r\n                # detectVbox.Add(self.detectorPanel, proportion=0, border=0, flag=wx.EXPAND)\r\n                # hbox.Add(homeVbox, flag=wx.EXPAND)\r\n            # if inst.isQontrol:\r\n\r\n            # self.laser = hp816x_N77Det()\r\n            #  detectVbox = wx.BoxSizer(wx.VERTICAL)\r\n            #  detPanel = detectorPanel(tlsPanel, self.laser.getNumPWMChannels(), self.laser)\r\n            #  detectVbox.Add(detPanel, proportion=0, border=0, flag=wx.EXPAND)\r\n            #  hbox.Add(detectVbox)\r\n            # else:\r\n            #   hbox.Add(panel, proportion=1, border=0, flag=wx.EXPAND)\r\n        hbox.Add(homeVbox)\r\n        vbox.Add(hbox, 3, wx.EXPAND)\r\n        # self.log = outputlogPanel(self)\r\n        # vbox.Add(self.log, 1, wx.EXPAND)\r\n        self.SetSizer(vbox)\r\n        self.Layout()\r\n        self.Show()\r\n\r\n    def motorFound(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        motorFound = False\r\n        for inst in self.instList:\r\n            motorFound = motorFound | inst.isMotor\r\n        return motorFound\r\n\r\n    def laserFound(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        laserFound = False\r\n        for inst in self.instList:\r\n            laserFound = laserFound | inst.isLaser\r\n        return laserFound\r\n\r\n    def getLasers(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        laserList = []\r\n        for inst in self.instList:\r\n            if inst.isLaser:\r\n                laserList.append(inst)\r\n        return laserList\r\n\r\n    def getMotors(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        motorList = []\r\n        for inst in self.instList:\r\n            if inst.isMotor:\r\n                motorList.append(inst)\r\n        return motorList\r\n\r\n    def OnExitApp(self, event):\r\n        \"\"\"\r\n\r\n        Args:\r\n            event:\r\n        \"\"\"\r\n        for inst in self.instList:\r\n            inst.disconnect()\r\n        self.Destroy()\r\n\r\n\r\nclass ElectricalTab(wx.Panel):\r\n    def __init__(self, parent, instList):\r\n        \"\"\"\r\n\r\n        Args:\r\n            parent:\r\n            instList:\r\n        \"\"\"\r\n        wx.Panel.__init__(self, parent)\r\n        self.instList = instList\r\n        vbox = wx.BoxSizer(wx.VERTICAL)\r\n        hbox = wx.BoxSizer(wx.HORIZONTAL)\r\n\r\n        for inst in self.instList:\r\n            # if inst.isSMU:\r\n            # panel = inst.panelClass(self, str(self.para1tc.GetValue()))\r\n            # else:\r\n\r\n            if inst.isDetect:\r\n                panel = inst.panelClass(self, inst, True, True)\r\n            elif inst.isLaser:\r\n                panel = inst.panelClass(self, inst, True, True)\r\n            else:\r\n                panel = inst.panelClass(self, inst)\r\n\r\n            if inst.isSMU:\r\n                hbox.Add(panel, proportion=1, border=0, flag=wx.EXPAND)\r\n            # else:\r\n            #  hbox.Add(panel, proportion=1, border=0, flag=wx.EXPAND)\r\n\r\n        vbox.Add(hbox, 3, wx.EXPAND)\r\n        # self.log = outputlogPanel(self)\r\n        # vbox.Add(self.log, 1, wx.EXPAND)\r\n        self.SetSizer(vbox)\r\n        self.Layout()\r\n        self.Show()\r\n\r\n    def motorFound(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        motorFound = False\r\n        for inst in self.instList:\r\n            motorFound = motorFound | inst.isMotor\r\n        return motorFound\r\n\r\n    def laserFound(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        laserFound = False\r\n        for inst in self.instList:\r\n            laserFound = laserFound | inst.isLaser\r\n        return laserFound\r\n\r\n    def getLasers(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        laserList = []\r\n        for inst in self.instList:\r\n            if inst.isLaser:\r\n                laserList.append(inst)\r\n        return laserList\r\n\r\n    def getMotors(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        motorList = []\r\n        for inst in self.instList:\r\n            if inst.isMotor:\r\n                motorList.append(inst)\r\n        return motorList\r\n\r\n    def OnExitApp(self, event):\r\n        \"\"\"\r\n\r\n        Args:\r\n            event:\r\n        \"\"\"\r\n        for inst in self.instList:\r\n            inst.disconnect()\r\n        self.Destroy()\r\n\r\n\r\nclass OpticalTab(wx.Panel):\r\n    def __init__(self, parent, instList):\r\n        \"\"\"\r\n\r\n        Args:\r\n            parent:\r\n            instList:\r\n        \"\"\"\r\n        wx.Panel.__init__(self, parent)\r\n        self.instList = instList\r\n        vbox = wx.BoxSizer(wx.VERTICAL)\r\n        hbox = wx.BoxSizer(wx.HORIZONTAL)\r\n        self.instList = instList\r\n\r\n        for inst in instList:\r\n            if inst.isLaser:\r\n                panel = inst.panelClass(self, inst, False, True)\r\n            else:\r\n                panel = inst.panelClass(self, inst)\r\n\r\n            if inst.isLaser:\r\n                laserVbox = wx.BoxSizer(wx.VERTICAL)\r\n                laserVbox.Add(panel, proportion=0, border=0, flag=wx.EXPAND)\r\n                hbox.Add(laserVbox)\r\n            # else:\r\n            #   hbox.Add(panel, proportion=1, border=0, flag=wx.EXPAND)\r\n\r\n        vbox.Add(hbox, 3, wx.EXPAND)\r\n        # self.log = outputlogPanel(self)\r\n        # vbox.Add(self.log, 1, wx.EXPAND)\r\n        self.SetSizer(vbox)\r\n        self.Layout()\r\n        self.Show()\r\n\r\n    def motorFound(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        motorFound = False\r\n        for inst in self.instList:\r\n            motorFound = motorFound | inst.isMotor\r\n        return motorFound\r\n\r\n    def laserFound(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        laserFound = False\r\n        for inst in self.instList:\r\n            laserFound = laserFound | inst.isLaser\r\n        return laserFound\r\n\r\n    def getLasers(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        laserList = []\r\n        for inst in self.instList:\r\n            if inst.isLaser:\r\n                laserList.append(inst)\r\n        return laserList\r\n\r\n    def getMotors(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        motorList = []\r\n        for inst in self.instList:\r\n            if inst.isMotor:\r\n                motorList.append(inst)\r\n        return motorList\r\n\r\n    def OnExitApp(self, event):\r\n        \"\"\"\r\n\r\n        Args:\r\n            event:\r\n        \"\"\"\r\n        for inst in self.instList:\r\n            inst.disconnect()\r\n        self.Destroy()\r\n\r\n\r\nclass AutoMeasureTab(wx.Panel):\r\n    def __init__(self, parent, instList):\r\n        \"\"\"\r\n\r\n        Args:\r\n            parent:\r\n            instList:\r\n        \"\"\"\r\n        wx.Panel.__init__(self, parent)\r\n        self.instList = instList\r\n        vbox = wx.BoxSizer(wx.VERTICAL)\r\n        hbox = wx.BoxSizer(wx.HORIZONTAL)\r\n\r\n        self.fineAlign = fineAlign(self.getLasers(), self.getMotorsOpt())\r\n        try:\r\n            self.fineAlignPanel = fineAlignPanel(self, self.fineAlign)\r\n        except Exception as e:\r\n            dial = wx.MessageDialog(None, 'Could not initiate instrument control. ' + traceback.format_exc(),\r\n                                    'Error', wx.ICON_ERROR)\r\n            dial.ShowModal()\r\n\r\n        self.autoMeasure = autoMeasure(self.getLasers(), self.getMotorsOpt(), self.getMotorsElec(), self.getSMUs(),\r\n                                       self.fineAlign)\r\n\r\n        self.autoMeasurePanel = autoMeasurePanel(self, self.autoMeasure)\r\n\r\n        vbox.Add(self.autoMeasurePanel, proportion=0, flag=wx.EXPAND)\r\n\r\n        vbox.Add(hbox, 3, wx.EXPAND)\r\n        # self.log = outputlogPanel(self)\r\n        # vbox.Add(self.log, 1, wx.EXPAND)\r\n        self.SetSizer(vbox)\r\n\r\n        # sys.stdout = logWriter(self.log)\r\n        # sys.stderr = logWriterError(self.log)\r\n\r\n    def motorFound(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        motorFound = False\r\n        for inst in self.instList:\r\n            motorFound = motorFound | inst.isMotor\r\n        return motorFound\r\n\r\n    def laserFound(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        laserFound = False\r\n        for inst in self.instList:\r\n            laserFound = laserFound | inst.isLaser\r\n        return laserFound\r\n\r\n    def getLasers(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        laserList = []\r\n        for inst in self.instList:\r\n            if inst.isLaser:\r\n                laserList.append(inst)\r\n        return laserList\r\n\r\n    def getMotorsOpt(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        motorList = []\r\n        for inst in self.instList:\r\n            if inst.isMotor and inst.isOpt:\r\n                motorList.append(inst)\r\n        return motorList\r\n\r\n    def getMotorsElec(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        motorList = []\r\n        for inst in self.instList:\r\n            if inst.isMotor and inst.isElec:\r\n                motorList.append(inst)\r\n        return motorList\r\n\r\n    def getSMUs(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        SMUList = []\r\n        for inst in self.instList:\r\n            if inst.isSMU:\r\n                SMUList.append(inst)\r\n        return SMUList\r\n\r\n    def OnExitApp(self, event):\r\n        \"\"\"\r\n\r\n        Args:\r\n            event:\r\n        \"\"\"\r\n        for inst in self.instList:\r\n            inst.disconnect()\r\n        self.Destroy()\r\n\r\n\r\nclass TestingparametersTab(wx.Panel):\r\n    def __init__(self, parent, instList):\r\n        \"\"\"\r\n\r\n        Args:\r\n            parent:\r\n            instList:\r\n        \"\"\"\r\n        wx.Panel.__init__(self, parent)\r\n        self.instList = instList\r\n        vbox = wx.BoxSizer(wx.VERTICAL)\r\n        hbox = wx.BoxSizer(wx.HORIZONTAL)\r\n\r\n        self.testingParameters = TopPanel(self)\r\n\r\n        vbox.Add(self.testingParameters, proportion=0, flag=wx.EXPAND)\r\n\r\n        #vbox.Add(hbox, 3, wx.EXPAND)\r\n        # self.log = outputlogPanel(self)\r\n        # vbox.Add(self.log, 1, wx.EXPAND)\r\n        self.SetSizer(vbox)\r\n\r\n        # sys.stdout = logWriter(self.log)\r\n        # sys.stderr = logWriterError(self.log)\r\n\r\n    def motorFound(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        motorFound = False\r\n        for inst in self.instList:\r\n            motorFound = motorFound | inst.isMotor\r\n        return motorFound\r\n\r\n    def laserFound(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        laserFound = False\r\n        for inst in self.instList:\r\n            laserFound = laserFound | inst.isLaser\r\n        return laserFound\r\n\r\n    def getLasers(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        laserList = []\r\n        for inst in self.instList:\r\n            if inst.isLaser:\r\n                laserList.append(inst)\r\n        return laserList\r\n\r\n    def getMotors(self):\r\n        \"\"\"\r\n\r\n        Returns:\r\n\r\n        \"\"\"\r\n        motorList = []\r\n        for inst in self.instList:\r\n            if inst.isMotor:\r\n                motorList.append(inst)\r\n        return motorList\r\n\r\n    def OnExitApp(self, event):\r\n        \"\"\"\r\n\r\n        Args:\r\n            event:\r\n        \"\"\"\r\n        for inst in self.instList:\r\n            inst.disconnect()\r\n        self.Destroy()\r\n\r\n\r\nclass instrumentFrame_withtabs(wx.Frame):\r\n\r\n    def __init__(self, parent, instList):\r\n        \"\"\"\r\n\r\n        Args:\r\n            parent:\r\n            instList:\r\n        \"\"\"\r\n        displaySize = wx.DisplaySize()\r\n        super(instrumentFrame_withtabs, self).__init__(parent, title='Instrument Control',\r\n                                                       size=(displaySize[0] * 5 / 8.0, displaySize[1] * 3 / 4.0))\r\n\r\n        self.instList = instList\r\n        try:\r\n            self.InitUI()\r\n        except Exception as e:\r\n            for inst in instList:\r\n                inst.disconnect()\r\n            self.Destroy()\r\n            raise\r\n        self.Centre()\r\n        self.Show()\r\n\r\n    def InitUI(self):\r\n        \"\"\"\r\n\r\n        \"\"\"\r\n        self.Bind(wx.EVT_CLOSE, self.OnExitApp)\r\n\r\n        # c = wx.Panel(self)\r\n        self.p = wx.Panel(self)\r\n        nb = wx.Notebook(self.p)\r\n\r\n        # Create the tab windows\r\n        tab1 = HomeTab(nb, self.instList)\r\n        tab2 = ElectricalTab(nb, self.instList)\r\n        tab3 = OpticalTab(nb, self.instList)\r\n        tab4 = AutoMeasureTab(nb, self.instList)\r\n        tab5 = TestingparametersTab(nb, self.instList)\r\n\r\n        # Add the windows to tabs and name them.\r\n        nb.AddPage(tab1, \"Home\")\r\n        nb.AddPage(tab2, \"Electrical\")\r\n        nb.AddPage(tab3, \"Optical\")\r\n        nb.AddPage(tab4, \"Automated Measurements\")\r\n        nb.AddPage(tab5, \"Testing Parameters\")\r\n\r\n        outputlabel = wx.StaticBox(self, label='SMU Control')\r\n\r\n        output = wx.StaticBoxSizer(outputlabel, wx.VERTICAL)\r\n\r\n        print(self.instList)\r\n\r\n        # Set notebook in a sizer to create the layout\r\n        sizer = wx.BoxSizer(wx.VERTICAL)\r\n        sizer.Add(nb, 1, wx.ALL | wx.EXPAND)\r\n\r\n        self.log = outputlogPanel(self.p)\r\n        sizer.Add(self.log, 1, wx.ALL | wx.EXPAND)\r\n        self.p.SetSizer(sizer)\r\n        sys.stdout = logWriter(self.log)\r\n        sys.stderr = logWriterError(self.log)\r\n\r\n    def OnExitApp(self, event):\r\n        \"\"\"\r\n\r\n        Args:\r\n            event:\r\n        \"\"\"\r\n        for inst in self.instList:\r\n            inst.disconnect()\r\n        self.Destroy()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/instrumentFrame_withtabs.py b/instrumentFrame_withtabs.py
--- a/instrumentFrame_withtabs.py	(revision abd26e7fa73a137f488f4dfbf10def44bc04de2c)
+++ b/instrumentFrame_withtabs.py	(date 1663700690112)
@@ -70,7 +70,7 @@
 
             # homeVbox = wx.BoxSizer(wx.VERTICAL)
 
-            if inst.isMotor:
+            if (inst.isMotor and not inst.isQontrol) and self.laserFound():
                 homeVbox.Add(panel, proportion=0, border=0, flag=wx.EXPAND)
                 self.fineAlign = fineAlign(self.getLasers()[0], self.getMotors()[0])
                 try:
@@ -87,8 +87,8 @@
                 # self.detectorPanel = detectorPanel(panel, inst.getNumPWMChannels(), inst)
                 # detectVbox.Add(self.detectorPanel, proportion=0, border=0, flag=wx.EXPAND)
                 # hbox.Add(homeVbox, flag=wx.EXPAND)
-            # if inst.isQontrol:
-
+            if inst.isQontrol:
+                homeVbox.Add(panel, proportion=0, border=0, flag=wx.EXPAND)
             # self.laser = hp816x_N77Det()
             #  detectVbox = wx.BoxSizer(wx.VERTICAL)
             #  detPanel = detectorPanel(tlsPanel, self.laser.getNumPWMChannels(), self.laser)
Index: autoMeasurePanel.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># The MIT License (MIT)\r\n\r\n# Copyright (c) 2015 Michael Caverley\r\n\r\n# Permission is hereby granted, free of charge, to any person obtaining a copy\r\n# of this software and associated documentation files (the \"Software\"), to deal\r\n# in the Software without restriction, including without limitation the rights\r\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n# copies of the Software, and to permit persons to whom the Software is\r\n# furnished to do so, subject to the following conditions:\r\n\r\n# The above copyright notice and this permission notice shall be included in\r\n# all copies or substantial portions of the Software.\r\n\r\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n# THE SOFTWARE.\r\n\r\nimport traceback\r\nimport wx\r\nimport wx.lib.mixins.listctrl\r\nimport myMatplotlibPanel\r\nfrom autoMeasureProgressDialog import autoMeasureProgressDialog\r\nimport os\r\nimport time\r\nfrom filterFrame import filterFrame\r\nimport csv\r\n\r\nglobal deviceList\r\nglobal deviceListAsObjects\r\nglobal fileLoaded\r\n\r\n\r\nclass coordinateMapPanel(wx.Panel):\r\n    def __init__(self, parent, autoMeasure, numDevices):\r\n        \"\"\"Panel which is used to calculate the transformation from gds coordinates to motor coordinates.\r\n        Three devices must be selected and the respective motor coordinates saved.\r\n\r\n        Args:\r\n            parent:\r\n            autoMeasure:\r\n            numDevices:\r\n\r\n        Returns:\r\n            object: \"\"\"\r\n        super(coordinateMapPanel, self).__init__(parent)\r\n        self.autoMeasure = autoMeasure\r\n        self.numDevices = numDevices\r\n        self.InitUI()\r\n\r\n    def InitUI(self):\r\n        \"\"\"\r\n\r\n        \"\"\"\r\n        gbs = wx.GridBagSizer(0, 0)\r\n\r\n        stMotorCoord = wx.StaticText(self, label='Motor Coordinates')\r\n\r\n        stxMotorCoord = wx.StaticText(self, label='X')\r\n        styMotorCoord = wx.StaticText(self, label='Y')\r\n        stzMotorCoord = wx.StaticText(self, label='Z')\r\n\r\n        gbs.Add(stMotorCoord, pos=(0, 2), span=(1, 2), flag=wx.ALIGN_CENTER)\r\n\r\n        gbs.Add(stxMotorCoord, pos=(1, 2), span=(1, 1), flag=wx.ALIGN_CENTER)\r\n        gbs.Add(styMotorCoord, pos=(1, 3), span=(1, 1), flag=wx.ALIGN_CENTER)\r\n        gbs.Add(stzMotorCoord, pos=(1, 4), span=(1, 1), flag=wx.ALIGN_CENTER)\r\n\r\n        self.stxMotorCoordLst = []\r\n        self.styMotorCoordLst = []\r\n        self.stzMotorCoordLst = []\r\n        self.stxGdsCoordLst = []\r\n        self.styGdsCoordLst = []\r\n        self.elecxGdsCoordLst = []\r\n        self.elecyGdsCoordLst = []\r\n\r\n        self.tbGdsDevice1 = wx.ComboBox(self, size=(80, 20), choices=[], style=wx.CB_DROPDOWN)\r\n        self.tbGdsDevice1.Bind(wx.EVT_COMBOBOX_DROPDOWN, self.on_drop_down)\r\n\r\n        self.tbGdsDevice2 = wx.ComboBox(self, size=(80, 20), choices=[], style=wx.CB_DROPDOWN)\r\n        self.tbGdsDevice2.Bind(wx.EVT_COMBOBOX_DROPDOWN, self.on_drop_down)\r\n\r\n        self.tbGdsDevice3 = wx.ComboBox(self, size=(80, 20), choices=[], style=wx.CB_DROPDOWN)\r\n        self.tbGdsDevice3.Bind(wx.EVT_COMBOBOX_DROPDOWN, self.on_drop_down)\r\n\r\n        self.GDSDevList = [self.tbGdsDevice1, self.tbGdsDevice2, self.tbGdsDevice3]\r\n\r\n        # Get Info of first Device\r\n        stDevice1 = wx.StaticText(self, label='Device %d' % (1))\r\n        self.tbxMotorCoord1 = wx.TextCtrl(self, size=(80, 20))\r\n        self.tbyMotorCoord1 = wx.TextCtrl(self, size=(80, 20))\r\n        self.tbzMotorCoord1 = wx.TextCtrl(self, size=(80, 20))\r\n\r\n        btnGetMotorCoord = wx.Button(self, label='Get Pos.', size=(50, 20))\r\n\r\n        gbs.Add(stDevice1, pos=(2, 0), span=(1, 1))\r\n        gbs.Add(self.tbxMotorCoord1, pos=(2, 2), span=(1, 1))\r\n        gbs.Add(self.tbyMotorCoord1, pos=(2, 3), span=(1, 1))\r\n        gbs.Add(self.tbzMotorCoord1, pos=(2, 4), span=(1, 1))\r\n        gbs.Add(self.GDSDevList[0], pos=(2, 1), span=(1, 1))\r\n        gbs.Add(btnGetMotorCoord, pos=(2, 6), span=(1, 1))\r\n\r\n        # For each button map a function which is called when it is pressed\r\n        btnGetMotorCoord.Bind(wx.EVT_BUTTON,\r\n                              lambda event, xcoord=self.tbxMotorCoord1, ycoord=self.tbyMotorCoord1,\r\n                                     zcoord=self.tbzMotorCoord1: self.Event_OnCoordButton(\r\n                                  event, xcoord, ycoord, zcoord))\r\n\r\n        # Get Info of second Device\r\n        stDevice2 = wx.StaticText(self, label='Device %d' % (2))\r\n        self.tbxMotorCoord2 = wx.TextCtrl(self, size=(80, 20))\r\n        self.tbyMotorCoord2 = wx.TextCtrl(self, size=(80, 20))\r\n        self.tbzMotorCoord2 = wx.TextCtrl(self, size=(80, 20))\r\n\r\n        btnGetMotorCoord = wx.Button(self, label='Get Pos.', size=(50, 20))\r\n\r\n        gbs.Add(stDevice2, pos=(3, 0), span=(1, 1))\r\n        gbs.Add(self.tbxMotorCoord2, pos=(3, 2), span=(1, 1))\r\n        gbs.Add(self.tbyMotorCoord2, pos=(3, 3), span=(1, 1))\r\n        gbs.Add(self.tbzMotorCoord2, pos=(3, 4), span=(1, 1))\r\n        gbs.Add(self.GDSDevList[1], pos=(3, 1), span=(1, 1))\r\n        gbs.Add(btnGetMotorCoord, pos=(3, 6), span=(1, 1))\r\n\r\n        # For each button map a function which is called when it is pressed\r\n        btnGetMotorCoord.Bind(wx.EVT_BUTTON,\r\n                              lambda event, xcoord=self.tbxMotorCoord2, ycoord=self.tbyMotorCoord2,\r\n                                     zcoord=self.tbzMotorCoord2: self.Event_OnCoordButton(\r\n                                  event, xcoord, ycoord, zcoord))\r\n\r\n        stDevice3 = wx.StaticText(self, label='Device %d' % (3))\r\n        self.tbxMotorCoord3 = wx.TextCtrl(self, size=(80, 20))\r\n        self.tbyMotorCoord3 = wx.TextCtrl(self, size=(80, 20))\r\n        self.tbzMotorCoord3 = wx.TextCtrl(self, size=(80, 20))\r\n\r\n        btnGetMotorCoord = wx.Button(self, label='Get Pos.', size=(50, 20))\r\n\r\n        # Get Info of third Device\r\n        gbs.Add(stDevice3, pos=(4, 0), span=(1, 1))\r\n        gbs.Add(self.tbxMotorCoord3, pos=(4, 2), span=(1, 1))\r\n        gbs.Add(self.tbyMotorCoord3, pos=(4, 3), span=(1, 1))\r\n        gbs.Add(self.tbzMotorCoord3, pos=(4, 4), span=(1, 1))\r\n        gbs.Add(self.GDSDevList[2], pos=(4, 1), span=(1, 1))\r\n        gbs.Add(btnGetMotorCoord, pos=(4, 6), span=(1, 1))\r\n\r\n        # For each button map a function which is called when it is pressed\r\n        btnGetMotorCoord.Bind(wx.EVT_BUTTON,\r\n                              lambda event, xcoord=self.tbxMotorCoord3, ycoord=self.tbyMotorCoord3,\r\n                                     zcoord=self.tbzMotorCoord3: self.Event_OnCoordButton(\r\n                                  event, xcoord, ycoord, zcoord))\r\n\r\n        global fileLoaded\r\n        if fileLoaded is True:\r\n\r\n            global deviceListAsObjects\r\n            for dev in deviceListAsObjects:\r\n                if self.GDSDevList[0] == dev.getDeviceID():\r\n                    self.stxGdsCoordLst.append(dev.getOpticalCoordinates()[0])\r\n                    self.styGdsCoordLst.append(dev.getOpticalCoordinates()[1])\r\n                    self.elecxGdsCoordLst.append(dev.getReferenceBondPad()[1])\r\n                    self.elecyGdsCoordLst.append(dev.getReferenceBondPad()[2])\r\n                    self.stxMotorCoordLst.append(self.tbxMotorCoord1)\r\n                    self.styMotorCoordLst.append(self.tbyMotorCoord1)\r\n                    self.stzMotorCoordLst.append(self.tbzMotorCoord1)\r\n\r\n                if self.GDSDevList[1] == dev.getDeviceID():\r\n                    self.stxGdsCoordLst.append(dev.getOpticalCoordinates()[0])\r\n                    self.styGdsCoordLst.append(dev.getOpticalCoordinates()[1])\r\n                    self.elecxGdsCoordLst.append(dev.getReferenceBondPad()[1])\r\n                    self.elecyGdsCoordLst.append(dev.getReferenceBondPad()[2])\r\n                    self.stxMotorCoordLst.append(self.tbxMotorCoord2)\r\n                    self.styMotorCoordLst.append(self.tbyMotorCoord2)\r\n                    self.stzMotorCoordLst.append(self.tbzMotorCoord2)\r\n\r\n                if self.GDSDevList[2] == dev.getDeviceID():\r\n                    self.stxGdsCoordLst.append(dev.getOpticalCoordinates()[0])\r\n                    self.styGdsCoordLst.append(dev.getOpticalCoordinates()[1])\r\n                    self.elecxGdsCoordLst.append(dev.getReferenceBondPad()[1])\r\n                    self.elecyGdsCoordLst.append(dev.getReferenceBondPad()[2])\r\n                    self.stxMotorCoordLst.append(self.tbxMotorCoord3)\r\n                    self.styMotorCoordLst.append(self.tbyMotorCoord3)\r\n                    self.stzMotorCoordLst.append(self.tbzMotorCoord3)\r\n\r\n        gbs.AddGrowableCol(1)\r\n        gbs.AddGrowableCol(2)\r\n        gbs.AddGrowableCol(3)\r\n        gbs.AddGrowableCol(4)\r\n        self.SetSizerAndFit(gbs)\r\n\r\n    def on_drop_down(self, event):\r\n        \"\"\"Populates drop down menu for device selection within the coordinate map panel\"\"\"\r\n        global deviceList\r\n        for GDSDevice in self.GDSDevList:\r\n            for dev in deviceList:\r\n                GDSDevice.Append(dev)\r\n\r\n    def Event_OnCoordButton(self, event, xcoord, ycoord, zcoord):\r\n        \"\"\" Called when the button is pressed to get the current motor coordinates, and put it into the text box. \"\"\"\r\n        motorPosition = self.autoMeasure.motor.getPosition()\r\n        xcoord.SetValue(str(motorPosition[0]))\r\n        ycoord.SetValue(str(motorPosition[1]))\r\n        zcoord.SetValue(str(motorPosition[2]))\r\n\r\n    def getMotorCoords(self):\r\n        \"\"\" Reads the motor coordinates from all completed text fields. \"\"\"\r\n        coordsLst = []\r\n        for tcx, tcy, tcz in zip(self.stxMotorCoordLst, self.styMotorCoordLst, self.stzMotorCoordLst):\r\n            xval = tcx.GetValue()\r\n            yval = tcy.GetValue()\r\n            zval = tcz.GetValue()\r\n            if xval != '' and yval != '' and zval != '':\r\n                coordsLst.append((float(xval), float(yval), float(zval)))\r\n        return coordsLst\r\n\r\n    def getGdsCoordsOpt(self):\r\n        \"\"\" Reads the GDS coordinates from all completed text fields. \"\"\"\r\n        coordsLst = []\r\n        for tcx, tcy in zip(self.stxGdsCoordLst, self.styGdsCoordLst):\r\n            xval = tcx.GetValue()\r\n            yval = tcy.GetValue()\r\n            if xval != '' and yval != '':\r\n                coordsLst.append((float(xval), float(yval)))\r\n        return coordsLst\r\n\r\n    def getGdsCoordsElec(self):\r\n        \"\"\" Reads the GDS coordinates from all completed text fields. \"\"\"\r\n        coordsLst = []\r\n        for tcx, tcy in zip(self.elecxGdsCoordLst, self.elecyGdsCoordLst):\r\n            xval = tcx.GetValue()\r\n            yval = tcy.GetValue()\r\n            if xval != '' and yval != '':\r\n                coordsLst.append((float(xval), float(yval)))\r\n        return coordsLst\r\n\r\n\r\nclass autoMeasurePanel(wx.Panel):\r\n\r\n    def __init__(self, parent, autoMeasure):\r\n        super(autoMeasurePanel, self).__init__(parent)\r\n        self.autoMeasure = autoMeasure\r\n        self.device_list = []\r\n        self.parametersImported = False\r\n        self.dataimport = {'index': [], 'device': [], 'ELECflag': [], 'OPTICflag': [], 'setwflag': [], 'setvflag': [],\r\n                           'Voltsel': [],\r\n                           'Currentsel': [], 'VoltMin': [], 'VoltMax': [], 'CurrentMin': [], 'CurrentMax': [],\r\n                           'VoltRes': [], 'CurrentRes': [], 'IV': [], 'RV': [], 'PV': [], 'ChannelA': [],\r\n                           'ChannelB': [],\r\n                           'Start': [], 'Stop': [], 'Stepsize': [], 'Sweeppower': [], 'Sweepspeed': [],\r\n                           'Laseroutput': [],\r\n                           'Numscans': [], 'InitialRange': [], 'RangeDec': [], 'setwVoltsel': [], 'setwCurrentsel': [],\r\n                           'setwVoltMin': [], 'setwVoltMax': [], 'setwCurrentMin': [], 'setwCurrentMax': [],\r\n                           'setwVoltRes': [], 'setwCurrentRes': [], 'setwIV': [], 'setwRV': [], 'setwPV': [],\r\n                           'setwChannelA': [], 'setwChannelB': [], 'Wavelengths': [], 'setvStart': [], 'setvStop': [],\r\n                           'setvStepsize': [], 'setvSweeppower': [], 'setvSweepspeed': [], 'setvLaseroutput': [],\r\n                           'setvNumscans': [], 'setvInitialRange': [], 'setvRangeDec': [], 'setvChannelA': [],\r\n                           'setvChannelB': [], 'Voltages': [], 'RoutineNumber': []}\r\n        self.InitUI()\r\n\r\n    def InitUI(self):\r\n\r\n        global fileLoaded\r\n        fileLoaded = False  # list of devices is currently empty\r\n        global deviceListAsObjects\r\n        deviceListAsObjects = []\r\n\r\n        # Create Automated Measurements Panel\r\n        sbOuter = wx.StaticBox(self, label='Automated Measurements')\r\n        vboxOuter = wx.StaticBoxSizer(sbOuter, wx.VERTICAL)\r\n\r\n        # Create File Upload Box\r\n        sbUpload = wx.StaticBox(self, label='File Upload')\r\n        vboxUpload = wx.StaticBoxSizer(sbUpload, wx.VERTICAL)\r\n\r\n        # Create Opical Alignment Box\r\n        sbOptical = wx.StaticBox(self, label='Optical Alignment')\r\n        vboxOptical = wx.StaticBoxSizer(sbOptical, wx.VERTICAL)\r\n\r\n        # Create Electrical Alignment Box\r\n        sbElectrical = wx.StaticBox(self, label='Electrical Alignment')\r\n        vboxElectrical = wx.StaticBoxSizer(sbElectrical, wx.VERTICAL)\r\n\r\n        # Create Electrical Optic Measurement Box\r\n        sbMeasurement = wx.StaticBox(self, label='Electro-Optic Measurements')\r\n        vboxMeasurement = wx.StaticBoxSizer(sbMeasurement, wx.VERTICAL)\r\n\r\n        # Add MatPlotLib Panel\r\n        matPlotBox = wx.BoxSizer(wx.HORIZONTAL)\r\n        self.graph = myMatplotlibPanel.myMatplotlibPanel(self)  # use for regular mymatplotlib file\r\n        matPlotBox.Add(self.graph, flag=wx.EXPAND, border=0, proportion=1)\r\n\r\n        # Add Coordinate file label\r\n        st1 = wx.StaticText(self, label='Coordinate file:')\r\n        fileLabelBox = wx.BoxSizer(wx.HORIZONTAL)\r\n        fileLabelBox.Add(st1, proportion=1, flag=wx.EXPAND)\r\n\r\n        # Allow File Selection\r\n        self.coordFileTb = wx.TextCtrl(self, style=wx.TE_READONLY)\r\n        self.coordFileTb.SetValue('No file selected')\r\n        self.coordFileSelectBtn = wx.Button(self, wx.ID_OPEN, size=(50, 20))\r\n        self.coordFileSelectBtn.Bind(wx.EVT_BUTTON, self.OnButton_ChooseCoordFile)\r\n        fileLoadBox = wx.BoxSizer(wx.HORIZONTAL)\r\n        fileLoadBox.AddMany([(self.coordFileTb, 1, wx.EXPAND), (self.coordFileSelectBtn, 0, wx.EXPAND)])\r\n\r\n        # Add Selection Buttons and Filter\r\n        self.checkAllBtn = wx.Button(self, label='Select All', size=(80, 20))\r\n        self.checkAllBtn.Bind(wx.EVT_BUTTON, self.OnButton_CheckAll)\r\n        self.uncheckAllBtn = wx.Button(self, label='Unselect All', size=(80, 20))\r\n        self.uncheckAllBtn.Bind(wx.EVT_BUTTON, self.OnButton_UncheckAll)\r\n        self.filterBtn = wx.Button(self, label='Filter', size=(70, 20))\r\n        self.filterBtn.Bind(wx.EVT_BUTTON, self.OnButton_Filter)\r\n\r\n        # Add devices checklist\r\n        self.checkList = wx.ListCtrl(self, -1, style=wx.LC_REPORT)\r\n        self.checkList.InsertColumn(0, 'Device', width=100)\r\n        checkListBox = wx.BoxSizer(wx.HORIZONTAL)\r\n        checkListBox.Add(self.checkList, proportion=1, flag=wx.EXPAND)\r\n\r\n        # Add Optical Alignment set up\r\n        self.coordMapPanelOpt = coordinateMapPanel(self, self.autoMeasure, 3)\r\n        opticalBox = wx.BoxSizer(wx.HORIZONTAL)\r\n        opticalBox.Add(self.coordMapPanelOpt, proportion=1, flag=wx.EXPAND)\r\n\r\n        # Add Electrical Alignment set up\r\n        self.coordMapPanelElec = coordinateMapPanel(self, self.autoMeasure, 3)\r\n        electricalBox = wx.BoxSizer(wx.HORIZONTAL)\r\n        electricalBox.Add(self.coordMapPanelElec, proportion=1, flag=wx.EXPAND)\r\n\r\n        # Add Measurement Buttons\r\n        self.calculateBtnO = wx.Button(self, label='Calculate', size=(70, 20))\r\n        self.calculateBtnO.Bind(wx.EVT_BUTTON, self.OnButton_CalculateOpt)\r\n        optButtonBox = wx.BoxSizer(wx.HORIZONTAL)\r\n        optButtonBox.AddMany([(self.calculateBtnO, 0, wx.EXPAND)])\r\n\r\n        # Add Measurement Buttons\r\n        self.calculateBtnE = wx.Button(self, label='Calculate', size=(70, 20))\r\n        self.calculateBtnE.Bind(wx.EVT_BUTTON, self.OnButton_CalculateElec)\r\n        elecButtonBox = wx.BoxSizer(wx.HORIZONTAL)\r\n        elecButtonBox.AddMany([(self.calculateBtnE, 0, wx.EXPAND)])\r\n\r\n        self.startBtn = wx.Button(self, label='Start Measurements', size=(120, 20))\r\n        self.startBtn.Bind(wx.EVT_BUTTON, self.OnButton_Start)\r\n        self.saveBtn = wx.Button(self, label='Save Alignment', size=(120, 20))\r\n        self.saveBtn.Bind(wx.EVT_BUTTON, self.OnButton_Save)\r\n        self.importBtn = wx.Button(self, label='Import Alignment', size=(120, 20))\r\n        self.importBtn.Bind(wx.EVT_BUTTON, self.OnButton_Import)\r\n\r\n        self.importBtnCSV = wx.Button(self, label='Import Testing Parameters', size=(150, 20))\r\n        self.importBtnCSV.Bind(wx.EVT_BUTTON, self.OnButton_ImportTestingParameters)\r\n\r\n        selectBox = wx.BoxSizer(wx.HORIZONTAL)\r\n        selectBox.AddMany([(self.checkAllBtn, 0, wx.EXPAND), (self.uncheckAllBtn, 0, wx.EXPAND),\r\n                           (self.filterBtn, 0, wx.EXPAND), (self.importBtnCSV, 0, wx.EXPAND)])\r\n\r\n        selectBox2 = wx.BoxSizer(wx.HORIZONTAL)\r\n        selectBox2.AddMany([(self.saveBtn, 0, wx.EXPAND),\r\n                            (self.importBtn, 0, wx.EXPAND), (self.startBtn, 0, wx.EXPAND)])\r\n\r\n        # Add Save folder label\r\n        st2 = wx.StaticText(self, label='Save folder:')\r\n        saveLabelBox = wx.BoxSizer(wx.HORIZONTAL)\r\n        saveLabelBox.Add(st2, proportion=1, flag=wx.EXPAND)\r\n\r\n        # Add Save folder Option\r\n        self.outputFolderTb = wx.TextCtrl(self, style=wx.TE_READONLY)\r\n        self.outputFolderBtn = wx.Button(self, wx.ID_OPEN, size=(50, 20))\r\n        self.outputFolderBtn.Bind(wx.EVT_BUTTON, self.OnButton_SelectOutputFolder)\r\n        saveBox = wx.BoxSizer(wx.HORIZONTAL)\r\n        saveBox.AddMany([(self.outputFolderTb, 1, wx.EXPAND), (self.outputFolderBtn, 0, wx.EXPAND)])\r\n\r\n        # Add \"Align Laser\" label\r\n        st3 = wx.StaticText(self, label='Align Laser')\r\n        moveLabelBox = wx.BoxSizer(wx.HORIZONTAL)\r\n        moveLabelBox.Add(st3, proportion=1, flag=wx.EXPAND)\r\n\r\n        # Add \"Align Electrical Probe\" label\r\n        st = wx.StaticText(self, label='Align Electrical Probe')\r\n        moveElecLabelBox = wx.BoxSizer(wx.HORIZONTAL)\r\n        moveElecLabelBox.Add(st, proportion=1, flag=wx.EXPAND)\r\n\r\n        # Add Measurement Buttons\r\n        self.devSelectCbOpt = wx.ComboBox(self, style=wx.CB_READONLY, size=(200, 20))\r\n        self.gotoDevBtnOpt = wx.Button(self, label='Go', size=(70, 20))\r\n        self.gotoDevBtnOpt.Bind(wx.EVT_BUTTON, self.OnButton_GotoDeviceOpt)\r\n        goBoxOpt = wx.BoxSizer(wx.HORIZONTAL)\r\n        goBoxOpt.AddMany([(self.devSelectCbOpt, 1, wx.EXPAND), (self.gotoDevBtnOpt, 0, wx.EXPAND)])\r\n\r\n        # Add Measurement Buttons\r\n        self.devSelectCb = wx.ComboBox(self, style=wx.CB_READONLY, size=(200, 20))\r\n        self.gotoDevBtn = wx.Button(self, label='Go', size=(70, 20))\r\n        self.gotoDevBtn.Bind(wx.EVT_BUTTON, self.OnButton_GotoDeviceElec)\r\n        goBoxElec = wx.BoxSizer(wx.HORIZONTAL)\r\n        goBoxElec.AddMany([(self.devSelectCb, 1, wx.EXPAND), (self.gotoDevBtn, 0, wx.EXPAND)])\r\n\r\n        # Populate File Upload Box with file upload, save folder selection and device checklist\r\n        vboxUpload.AddMany([(fileLabelBox, 0, wx.EXPAND), (fileLoadBox, 0, wx.EXPAND),\r\n                            (saveLabelBox, 0, wx.EXPAND), (saveBox, 0, wx.EXPAND)])\r\n\r\n        # Populate Optical Box with alignment and buttons\r\n        vboxOptical.AddMany([(opticalBox, 0, wx.EXPAND)])\r\n\r\n        # Populate Electrical Box with alignment and buttons\r\n        vboxElectrical.AddMany([(electricalBox, 0, wx.EXPAND)])\r\n\r\n        # Populate Measurement Box with drop down menu and go button\r\n        vboxMeasurement.AddMany(\r\n            [(moveLabelBox, 0, wx.EXPAND), (goBoxOpt, 0, wx.EXPAND),\r\n             (moveElecLabelBox, 0, wx.EXPAND), (goBoxElec, 0, wx.EXPAND)])\r\n\r\n        topBox = wx.BoxSizer(wx.HORIZONTAL)\r\n        topBox.AddMany([(vboxUpload, 0, wx.EXPAND), (vboxMeasurement, 0, wx.EXPAND)])\r\n\r\n        checkBox = wx.BoxSizer(wx.VERTICAL)\r\n        checkBox.AddMany([(checkListBox, 0, wx.EXPAND), (selectBox, 0, wx.EXPAND), (selectBox2, 0, wx.EXPAND)])\r\n\r\n        # Add all boxes to outer box\r\n        vboxOuter.AddMany([(topBox, 0, wx.EXPAND), (checkBox, 0, wx.EXPAND), (vboxOptical, 0, wx.EXPAND),\r\n                           (vboxElectrical, 0, wx.EXPAND)])\r\n        matPlotBox.Add(vboxOuter, flag=wx.LEFT | wx.TOP | wx.ALIGN_LEFT, border=0, proportion=0)\r\n\r\n        self.SetSizer(matPlotBox)\r\n\r\n    def checkListSort(self, item1, item2):\r\n        # Items are the client data associated with each entry\r\n        if item2 < item2:\r\n            return -1\r\n        elif item1 > item2:\r\n            return 1\r\n        else:\r\n            return 0\r\n\r\n    def createFilterFrame(self):\r\n        \"\"\"Opens up a frame to facilitate filtering of devices within the checklist.\"\"\"\r\n        try:\r\n            filterFrame(None, self.checkList, self.device_list)\r\n\r\n        except Exception as e:\r\n            dial = wx.MessageDialog(None, 'Could not initiate filter. ' + traceback.format_exc(),\r\n                                    'Error', wx.ICON_ERROR)\r\n            dial.ShowModal()\r\n\r\n    def OnButton_ChooseCoordFile(self, event):\r\n        \"\"\" Opens a file dialog to select a coordinate file. \"\"\"\r\n        fileDlg = wx.FileDialog(self, \"Open\", \"\", \"\",\r\n                                \"Text Files (*.txt)|*.txt\",\r\n                                wx.FD_OPEN | wx.FD_FILE_MUST_EXIST)\r\n        fileDlg.ShowModal()\r\n        self.coordFileTb.SetValue(fileDlg.GetFilenames()[0])\r\n        self.coordFilePath = fileDlg.GetPath()\r\n        self.parseCoordFile(self.coordFilePath)\r\n\r\n    def parseCoordFile(self, coordFilePath):\r\n        \"\"\"Parses given coordinate files and stores all info as a list of electro-Optic Device\r\n        as well as a list of device ids and populates checklist of devices\"\"\"\r\n        self.autoMeasure.readCoordFile(coordFilePath)\r\n        global deviceListAsObjects\r\n        deviceListAsObjects = self.autoMeasure.devices\r\n        self.device_list = deviceListAsObjects\r\n        global deviceList\r\n        deviceList = []\r\n        for device in deviceListAsObjects:\r\n            deviceList.append(device.getDeviceID())\r\n        self.devSelectCb.Clear()\r\n        self.devSelectCb.AppendItems(deviceList)\r\n        self.devSelectCbOpt.Clear()\r\n        self.devSelectCbOpt.AppendItems(deviceList)\r\n        # Adds items to the check list\r\n        self.checkList.DeleteAllItems()\r\n        for ii, device in enumerate(deviceList):\r\n            self.checkList.InsertItem(ii, device)\r\n            for dev in deviceListAsObjects:\r\n                if dev.getDeviceID() == device:\r\n                    index = deviceListAsObjects.index(dev)  # Stores index of device in list\r\n                    self.checkList.SetItemData(ii, index)\r\n        self.checkList.SortItems(self.checkListSort)  # Make sure items in list are sorted\r\n        self.checkList.EnableCheckBoxes()\r\n        global fileLoaded\r\n        fileLoaded = True\r\n        self.Refresh()\r\n\r\n    def OnButton_Import(self, event):\r\n        \"\"\" Opens a file dialog to select a csv alignment file and populates all position fields\"\"\"\r\n        fileDlg = wx.FileDialog(self, \"Open\", \"\", \"\",\r\n                                \"Text Files (*.csv)|*.csv\",\r\n                                wx.FD_OPEN | wx.FD_FILE_MUST_EXIST)\r\n        fileDlg.ShowModal()\r\n        filePath = fileDlg.GetPath()\r\n        f = open(filePath, 'r', newline='')\r\n        reader = csv.reader(f)\r\n        textCoordPath = next(reader)\r\n        self.parseCoordFile(textCoordPath[0])\r\n        next(reader)\r\n        next(reader)\r\n        optDev1 = next(reader)\r\n        optDev1 = optDev1  # [dev name, x motor coord, y motor coord, z motor coord]\r\n        self.coordMapPanelOpt.tbGdsDevice1.SetValue(optDev1[0])\r\n        self.coordMapPanelOpt.tbxMotorCoord1.SetValue(optDev1[1])\r\n        self.coordMapPanelOpt.tbyMotorCoord1.SetValue(optDev1[2])\r\n        self.coordMapPanelOpt.tbzMotorCoord1.SetValue(optDev1[3])\r\n        optDev2 = next(reader)\r\n        optDev2 = optDev2\r\n        self.coordMapPanelOpt.tbGdsDevice2.SetValue(optDev2[0])\r\n        self.coordMapPanelOpt.tbxMotorCoord2.SetValue(optDev2[1])\r\n        self.coordMapPanelOpt.tbyMotorCoord2.SetValue(optDev2[2])\r\n        self.coordMapPanelOpt.tbzMotorCoord2.SetValue(optDev2[3])\r\n        optDev3 = next(reader)\r\n        optDev3 = optDev3\r\n        self.coordMapPanelOpt.tbGdsDevice3.SetValue(optDev3[0])\r\n        self.coordMapPanelOpt.tbxMotorCoord3.SetValue(optDev3[1])\r\n        self.coordMapPanelOpt.tbyMotorCoord3.SetValue(optDev3[2])\r\n        self.coordMapPanelOpt.tbzMotorCoord3.SetValue(optDev3[3])\r\n        next(reader)\r\n        next(reader)\r\n        elecDev1 = next(reader)\r\n        elecDev1 = elecDev1\r\n        self.coordMapPanelElec.tbGdsDevice1.SetValue(elecDev1[0])\r\n        self.coordMapPanelElec.tbxMotorCoord1.SetValue(elecDev1[1])\r\n        self.coordMapPanelElec.tbyMotorCoord1.SetValue(elecDev1[2])\r\n        self.coordMapPanelElec.tbzMotorCoord1.SetValue(elecDev1[3])\r\n        elecDev2 = next(reader)\r\n        elecDev2 = elecDev2\r\n        self.coordMapPanelElec.tbGdsDevice2.SetValue(elecDev2[0])\r\n        self.coordMapPanelElec.tbxMotorCoord2.SetValue(elecDev2[1])\r\n        self.coordMapPanelElec.tbyMotorCoord2.SetValue(elecDev2[2])\r\n        self.coordMapPanelElec.tbzMotorCoord2.SetValue(elecDev2[3])\r\n        elecDev3 = next(reader)\r\n        elecDev3 = elecDev3\r\n        self.coordMapPanelElec.tbGdsDevice3.SetValue(elecDev3[0])\r\n        self.coordMapPanelElec.tbxMotorCoord3.SetValue(elecDev3[1])\r\n        self.coordMapPanelElec.tbyMotorCoord3.SetValue(elecDev3[2])\r\n        self.coordMapPanelElec.tbzMotorCoord3.SetValue(elecDev3[3])\r\n\r\n    def OnButton_ImportTestingParameters(self, event):\r\n        \"\"\"Imports a testing parameters file and stores data as a dictionary\"\"\"\r\n\r\n        fileDlg = wx.FileDialog(self, \"Open\", \"\", \"\",\r\n                                \"CSV Files (*.csv)|*.csv\",\r\n                                wx.FD_OPEN | wx.FD_FILE_MUST_EXIST)\r\n        fileDlg.ShowModal()\r\n        originalFile = fileDlg.GetPath()\r\n\r\n        if originalFile == '':\r\n            print('Please select a file to import')\r\n            return\r\n\r\n        self.readCSV(originalFile)\r\n        self.parametersImported = True\r\n\r\n    def readCSV(self, originalFile):\r\n        \"\"\"Reads a csv testing parameters file and stores the information in a dictionary to be used for\r\n        automated measurements.\"\"\"\r\n        with open(originalFile, 'r') as file:\r\n            rows = []\r\n            for row in file:\r\n                rows.append(row)\r\n\r\n            rows.pop(2)\r\n            rows.pop(1)\r\n            rows.pop(0)\r\n\r\n            for c in range(len(rows)):\r\n                x = rows[c].split(',')\r\n\r\n                self.dataimport['device'].append(x[0])\r\n                self.dataimport['ELECflag'].append(x[1])\r\n                self.dataimport['OPTICflag'].append(x[2])\r\n                self.dataimport['setwflag'].append(x[3])\r\n                self.dataimport['setvflag'].append(x[4])\r\n                self.dataimport['Voltsel'].append(x[5])\r\n                self.dataimport['Currentsel'].append(x[6])\r\n                self.dataimport['VoltMin'].append(x[7])\r\n                self.dataimport['VoltMax'].append(x[8])\r\n                self.dataimport['CurrentMin'].append(x[9])\r\n                self.dataimport['CurrentMax'].append(x[10])\r\n                self.dataimport['VoltRes'].append(x[11])\r\n                self.dataimport['CurrentRes'].append(x[12])\r\n                self.dataimport['IV'].append(x[13])\r\n                self.dataimport['RV'].append(x[14])\r\n                self.dataimport['PV'].append(x[15])\r\n                self.dataimport['ChannelA'].append(x[16])\r\n                self.dataimport['ChannelB'].append(x[17])\r\n                self.dataimport['Start'].append(x[18])\r\n                self.dataimport['Stop'].append(x[19])\r\n                self.dataimport['Stepsize'].append(x[20])\r\n                self.dataimport['Sweeppower'].append(x[21])\r\n                self.dataimport['Sweepspeed'].append(x[22])\r\n                self.dataimport['Laseroutput'].append(x[23])\r\n                self.dataimport['Numscans'].append(x[24])\r\n                self.dataimport['InitialRange'].append(x[25])\r\n                self.dataimport['RangeDec'].append(x[26])\r\n                self.dataimport['setwVoltsel'].append(x[27])\r\n                self.dataimport['setwCurrentsel'].append(x[28])\r\n                self.dataimport['setwVoltMin'].append(x[29])\r\n                self.dataimport['setwVoltMax'].append(x[30])\r\n                self.dataimport['setwCurrentMin'].append(x[31])\r\n                self.dataimport['setwCurrentMax'].append(x[32])\r\n                self.dataimport['setwVoltRes'].append(x[33])\r\n                self.dataimport['setwCurrentRes'].append(x[34])\r\n                self.dataimport['setwIV'].append(x[35])\r\n                self.dataimport['setwRV'].append(x[36])\r\n                self.dataimport['setwPV'].append(x[37])\r\n                self.dataimport['setwChannelA'].append(x[38])\r\n                self.dataimport['setwChannelB'].append(x[39])\r\n                self.dataimport['Wavelengths'].append(x[40])\r\n                self.dataimport['setvStart'].append(x[41])\r\n                self.dataimport['setvStop'].append(x[42])\r\n                self.dataimport['setvStepsize'].append(x[43])\r\n                self.dataimport['setvSweeppower'].append(x[44])\r\n                self.dataimport['setvSweepspeed'].append(x[45])\r\n                self.dataimport['setvLaseroutput'].append(x[46])\r\n                self.dataimport['setvNumscans'].append(x[47])\r\n                self.dataimport['setvInitialRange'].append(x[48])\r\n                self.dataimport['setvRangeDec'].append(x[49])\r\n                self.dataimport['setvChannelA'].append(x[50])\r\n                self.dataimport['setvChannelB'].append(x[51])\r\n                self.dataimport['Voltages'].append(x[52])\r\n\r\n        for keys, values in self.dataimport.items():\r\n            print(keys)\r\n            print(values)\r\n\r\n        # self.checkList.DeleteAllItems()\r\n        # devicelist = []\r\n        # for c in range(len(self.dataimport['Device'])):\r\n        #   devicelist.append(self.dataimport['Device'][c])\r\n\r\n        # print(devicelist)\r\n\r\n    def OnButton_CheckAll(self, event):\r\n        \"\"\"Selects all items in the devices check list\"\"\"\r\n        for ii in range(self.checkList.GetItemCount()):\r\n            self.checkList.CheckItem(ii, True)\r\n\r\n    # TODO: Modify to move probe out of the way and keep track of chip stage movement\r\n    def OnButton_GotoDeviceOpt(self, event):\r\n        \"\"\"Moves laser to selected device\"\"\"\r\n        selectedDevice = self.devSelectCb.GetValue()\r\n        global deviceListAsObjects\r\n        for device in deviceListAsObjects:\r\n            if device.getDeviceID == selectedDevice:\r\n                gdsCoord = (device.getOpticalCoordinates[0], device.getOpticalCoordinates[1])\r\n                motorCoord = self.autoMeasure.gdsToMotorCoordsOpt(gdsCoord)\r\n                self.autoMeasure.motorOpt.moveAbsoluteXYZ(motorCoord[0], motorCoord[1], motorCoord[2])\r\n\r\n    # TODO: Modify to move laser out of the way\r\n    def OnButton_GotoDeviceElec(self, event):\r\n        \"\"\"Move probe to selected device\"\"\"\r\n        selectedDevice = self.devSelectCb.GetValue()\r\n        global deviceListAsObjects\r\n        for device in deviceListAsObjects:\r\n            if device.getDeviceID == selectedDevice:\r\n                gdsCoord = (device.getReferenceBondPad[1], device.getReferenceBondPad[2])\r\n                motorCoord = self.autoMeasure.gdsToMotorCoordsElec(gdsCoord)\r\n                self.autoMeasure.motorElec.moveAbsoluteXYZ(motorCoord[0], motorCoord[1], motorCoord[2])\r\n\r\n    def OnButton_UncheckAll(self, event):\r\n        \"\"\"Deselects all items in the devices checklist\"\"\"\r\n        for ii in range(self.checkList.GetItemCount()):\r\n            self.checkList.CheckItem(ii, False)\r\n\r\n    def OnButton_SelectOutputFolder(self, event):\r\n        \"\"\" Opens a file dialog to select an output directory for automatic measurement. \"\"\"\r\n        dirDlg = wx.DirDialog(self, \"Open\", \"\", wx.DD_DEFAULT_STYLE)\r\n        dirDlg.ShowModal()\r\n        self.outputFolderTb.SetValue(dirDlg.GetPath())\r\n        dirDlg.Destroy()\r\n\r\n    def OnButton_CalculateOpt(self, event):\r\n        \"\"\" Computes the optical coordinate transformation matrix. \"\"\"\r\n        A = self.autoMeasure.findCoordinateTransformOpt(self.coordMapPanelOpt.getMotorCoords(),\r\n                                                        self.coordMapPanelOpt.getGdsCoordsOpt())\r\n        print('Coordinate transform matrix')\r\n        print(A)\r\n\r\n    def OnButton_CalculateElec(self, event):\r\n        \"\"\" Computes the electrical coordinate transformation matrix. \"\"\"\r\n        A = self.autoMeasure.findCoordinateTransformElec(self.coordMapPanelElec.getMotorCoords(),\r\n                                                         self.coordMapPanelElec.getGdsCoordsElec())\r\n        print('Coordinate transform matrix')\r\n        print(A)\r\n\r\n    def OnButton_Start(self, event):\r\n        \"\"\" Starts an automatic measurement. \"\"\"\r\n\r\n        if self.parametersImported is False:\r\n\r\n            path = os.path.realpath(__file__)\r\n            originalFile = os.path.join(path, 'pyOptomip', 'TestingParameters.csv')\r\n            self.readCSV(originalFile)\r\n\r\n        # Disable detector auto measurement\r\n        self.autoMeasure.laser.ctrlPanel.laserPanel.laserPanel.haltDetTimer()\r\n\r\n        # Make a folder with the current time\r\n        timeStr = time.strftime(\"%d_%b_%Y_%H_%M_%S\", time.localtime())\r\n        self.autoMeasure.saveFolder = os.path.join(self.outputFolderTb.GetValue(), timeStr)\r\n        if not os.path.exists(self.autoMeasure.saveFolder):\r\n            os.makedirs(self.autoMeasure.saveFolder)\r\n\r\n        checkedDevices = []\r\n        for device in self.device_list:\r\n            if self.checkList.IsItemChecked(device.getDeviceID):\r\n                checkedDevices.append(device)\r\n\r\n        self.autoMeasure.beginMeasure(checkedDevices, self.dataimport, self.checkList)\r\n\r\n\r\n        # Copy settings from laser panel\r\n        self.autoMeasure.laser.ctrlPanel.laserPanel.laserPanel.copySweepSettings()\r\n        # Create a measurement progress dialog.\r\n        autoMeasureDlg = autoMeasureProgressDialog(self, title='Automatic measurement')\r\n        autoMeasureDlg.runMeasurement(checkedDevices, self.autoMeasure)\r\n\r\n        # Enable detector auto measurement\r\n        self.autoMeasure.laser.ctrlPanel.laserPanel.laserPanel.startDetTimer()\r\n\r\n    def OnButton_Filter(self, event):\r\n        \"\"\"Creates filter frame when filter button is pressed\"\"\"\r\n        self.createFilterFrame()\r\n        self.Refresh()\r\n\r\n    def OnButton_Save(self, event):\r\n        \"\"\"Saves the gds devices used for alignment as well as motor positions\"\"\"\r\n        A = self.autoMeasure.findCoordinateTransformOpt(self.coordMapPanelOpt.getMotorCoords(),\r\n                                                        self.coordMapPanelOpt.getGdsCoordsOpt())\r\n\r\n        B = self.autoMeasure.findCoordinateTransformElec(self.coordMapPanelElec.getMotorCoords(),\r\n                                                         self.coordMapPanelElec.getGdsCoordsElec())\r\n\r\n        # Make a folder with the current time\r\n        fileName = self.coordFileTb.GetValue()\r\n        timeStr = time.strftime(\"%d_%b_%Y_%H_%M_%S\", time.localtime())\r\n        csvFileName = os.path.join(self.outputFolderTb.GetValue(), timeStr + '_{}.csv'.format(fileName))\r\n\r\n        f = open(csvFileName, 'w', newline='')\r\n        writer = csv.writer(f)\r\n        textFilePath = [self.coordFilePath]\r\n        writer.writerow(textFilePath)\r\n        optCoords = self.coordMapPanelOpt.getMotorCoords()\r\n        Opt = ['Optical Alignment']\r\n        writer.writerow(Opt)\r\n        Opt = ['Device', 'Motor x', 'Motor y', 'Motor z']\r\n        writer.writerow(Opt)\r\n        dev1 = [self.coordMapPanelOpt.tbGdsDevice1.GetValue(),\r\n                optCoords[0][0], optCoords[0][1], optCoords[0][2]]\r\n        writer.writerow(dev1)\r\n        dev2 = [self.coordMapPanelOpt.tbGdsDevice2.GetValue(),\r\n                optCoords[1][0], optCoords[1][1], optCoords[1][2]]\r\n        writer.writerow(dev2)\r\n        dev3 = [self.coordMapPanelOpt.tbGdsDevice3.GetValue(),\r\n                optCoords[2][0], optCoords[2][1], optCoords[2][2]]\r\n        writer.writerow(dev3)\r\n        elecCoords = self.coordMapPanelElec.getMotorCoords()\r\n        Elec = ['Electrical Alignment']\r\n        writer.writerow(Elec)\r\n        elec = ['Device', 'Motor x', 'Motor y', 'Motor z']\r\n        writer.writerow(elec)\r\n        dev1 = [self.coordMapPanelElec.tbGdsDevice1.GetValue(),\r\n                elecCoords[0][0], elecCoords[0][1], elecCoords[0][2]]\r\n        writer.writerow(dev1)\r\n        dev2 = [self.coordMapPanelElec.tbGdsDevice2.GetValue(),\r\n                elecCoords[1][0], elecCoords[1][1], elecCoords[1][2]]\r\n        writer.writerow(dev2)\r\n        dev3 = [self.coordMapPanelElec.tbGdsDevice3.GetValue(),\r\n                elecCoords[2][0], elecCoords[2][1], elecCoords[2][2]]\r\n        writer.writerow(dev3)\r\n        f.close()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/autoMeasurePanel.py b/autoMeasurePanel.py
--- a/autoMeasurePanel.py	(revision abd26e7fa73a137f488f4dfbf10def44bc04de2c)
+++ b/autoMeasurePanel.py	(date 1663700690095)
@@ -32,44 +32,43 @@
 
 global deviceList
 global deviceListAsObjects
-global fileLoaded
 
 
 class coordinateMapPanel(wx.Panel):
-    def __init__(self, parent, autoMeasure, numDevices):
-        """Panel which is used to calculate the transformation from gds coordinates to motor coordinates.
-        Three devices must be selected and the respective motor coordinates saved.
+    def __init__(self, parent, autoMeasure):
+        """Panel which is used to obtain the necessary parameters to calculate the transformation from
+        gds coordinates to motor coordinates. Three devices must be selected and the respective motor
+        coordinates saved.
 
         Args:
-            parent:
-            autoMeasure:
-            numDevices:
+            parent: wx Panel
+            autoMeasure: The automeasure object used for the automeasure panel"""
 
-        Returns:
-            object: """
         super(coordinateMapPanel, self).__init__(parent)
         self.autoMeasure = autoMeasure
-        self.numDevices = numDevices
         self.InitUI()
 
     def InitUI(self):
         """
-
+        Sets up the layout for the coordinate map panel.
         """
         gbs = wx.GridBagSizer(0, 0)
 
+        # Create text labels for the panel
         stMotorCoord = wx.StaticText(self, label='Motor Coordinates')
 
         stxMotorCoord = wx.StaticText(self, label='X')
         styMotorCoord = wx.StaticText(self, label='Y')
         stzMotorCoord = wx.StaticText(self, label='Z')
 
+        # Add text labels into grid bag sizer
         gbs.Add(stMotorCoord, pos=(0, 2), span=(1, 2), flag=wx.ALIGN_CENTER)
 
         gbs.Add(stxMotorCoord, pos=(1, 2), span=(1, 1), flag=wx.ALIGN_CENTER)
         gbs.Add(styMotorCoord, pos=(1, 3), span=(1, 1), flag=wx.ALIGN_CENTER)
         gbs.Add(stzMotorCoord, pos=(1, 4), span=(1, 1), flag=wx.ALIGN_CENTER)
 
+        # Create empty lists to store all necessary coordinates
         self.stxMotorCoordLst = []
         self.styMotorCoordLst = []
         self.stzMotorCoordLst = []
@@ -78,18 +77,20 @@
         self.elecxGdsCoordLst = []
         self.elecyGdsCoordLst = []
 
-        self.tbGdsDevice1 = wx.ComboBox(self, size=(80, 20), choices=[], style=wx.CB_DROPDOWN)
-        self.tbGdsDevice1.Bind(wx.EVT_COMBOBOX_DROPDOWN, self.on_drop_down)
+        # Create drop down menus to select devices
+        self.tbGdsDevice1 = wx.Choice(self, size=(150, 20), choices=[])
+        self.tbGdsDevice1.Bind(wx.EVT_CHOICE, self.on_drop_down1)
 
-        self.tbGdsDevice2 = wx.ComboBox(self, size=(80, 20), choices=[], style=wx.CB_DROPDOWN)
-        self.tbGdsDevice2.Bind(wx.EVT_COMBOBOX_DROPDOWN, self.on_drop_down)
+        self.tbGdsDevice2 = wx.Choice(self, size=(150, 20), choices=[])
+        self.tbGdsDevice2.Bind(wx.EVT_CHOICE, self.on_drop_down2)
 
-        self.tbGdsDevice3 = wx.ComboBox(self, size=(80, 20), choices=[], style=wx.CB_DROPDOWN)
-        self.tbGdsDevice3.Bind(wx.EVT_COMBOBOX_DROPDOWN, self.on_drop_down)
+        self.tbGdsDevice3 = wx.Choice(self, size=(150, 20), choices=[])
+        self.tbGdsDevice3.Bind(wx.EVT_CHOICE, self.on_drop_down3)
 
+        # List of all drop down menus
         self.GDSDevList = [self.tbGdsDevice1, self.tbGdsDevice2, self.tbGdsDevice3]
 
-        # Get Info of first Device
+        # Get motor coordinates of first device from text box
         stDevice1 = wx.StaticText(self, label='Device %d' % (1))
         self.tbxMotorCoord1 = wx.TextCtrl(self, size=(80, 20))
         self.tbyMotorCoord1 = wx.TextCtrl(self, size=(80, 20))
@@ -97,6 +98,7 @@
 
         btnGetMotorCoord = wx.Button(self, label='Get Pos.', size=(50, 20))
 
+        # Add text boxes to grid bag sizer
         gbs.Add(stDevice1, pos=(2, 0), span=(1, 1))
         gbs.Add(self.tbxMotorCoord1, pos=(2, 2), span=(1, 1))
         gbs.Add(self.tbyMotorCoord1, pos=(2, 3), span=(1, 1))
@@ -104,13 +106,13 @@
         gbs.Add(self.GDSDevList[0], pos=(2, 1), span=(1, 1))
         gbs.Add(btnGetMotorCoord, pos=(2, 6), span=(1, 1))
 
-        # For each button map a function which is called when it is pressed
+        # For "Get Position" button map a function which is called when it is pressed
         btnGetMotorCoord.Bind(wx.EVT_BUTTON,
                               lambda event, xcoord=self.tbxMotorCoord1, ycoord=self.tbyMotorCoord1,
                                      zcoord=self.tbzMotorCoord1: self.Event_OnCoordButton(
                                   event, xcoord, ycoord, zcoord))
 
-        # Get Info of second Device
+        # Get motor coordinates of second device from text box
         stDevice2 = wx.StaticText(self, label='Device %d' % (2))
         self.tbxMotorCoord2 = wx.TextCtrl(self, size=(80, 20))
         self.tbyMotorCoord2 = wx.TextCtrl(self, size=(80, 20))
@@ -118,6 +120,7 @@
 
         btnGetMotorCoord = wx.Button(self, label='Get Pos.', size=(50, 20))
 
+        # Add text boxes to grid bag sizer
         gbs.Add(stDevice2, pos=(3, 0), span=(1, 1))
         gbs.Add(self.tbxMotorCoord2, pos=(3, 2), span=(1, 1))
         gbs.Add(self.tbyMotorCoord2, pos=(3, 3), span=(1, 1))
@@ -125,12 +128,13 @@
         gbs.Add(self.GDSDevList[1], pos=(3, 1), span=(1, 1))
         gbs.Add(btnGetMotorCoord, pos=(3, 6), span=(1, 1))
 
-        # For each button map a function which is called when it is pressed
+        # For "Get Position" button map a function which is called when it is pressed
         btnGetMotorCoord.Bind(wx.EVT_BUTTON,
                               lambda event, xcoord=self.tbxMotorCoord2, ycoord=self.tbyMotorCoord2,
                                      zcoord=self.tbzMotorCoord2: self.Event_OnCoordButton(
                                   event, xcoord, ycoord, zcoord))
 
+        # Get motor coordinates of first device from text box
         stDevice3 = wx.StaticText(self, label='Device %d' % (3))
         self.tbxMotorCoord3 = wx.TextCtrl(self, size=(80, 20))
         self.tbyMotorCoord3 = wx.TextCtrl(self, size=(80, 20))
@@ -138,7 +142,7 @@
 
         btnGetMotorCoord = wx.Button(self, label='Get Pos.', size=(50, 20))
 
-        # Get Info of third Device
+        # Add text boxes to grid bag sizer
         gbs.Add(stDevice3, pos=(4, 0), span=(1, 1))
         gbs.Add(self.tbxMotorCoord3, pos=(4, 2), span=(1, 1))
         gbs.Add(self.tbyMotorCoord3, pos=(4, 3), span=(1, 1))
@@ -146,57 +150,57 @@
         gbs.Add(self.GDSDevList[2], pos=(4, 1), span=(1, 1))
         gbs.Add(btnGetMotorCoord, pos=(4, 6), span=(1, 1))
 
-        # For each button map a function which is called when it is pressed
+        # For "Get Position" button map a function which is called when it is pressed
         btnGetMotorCoord.Bind(wx.EVT_BUTTON,
                               lambda event, xcoord=self.tbxMotorCoord3, ycoord=self.tbyMotorCoord3,
                                      zcoord=self.tbzMotorCoord3: self.Event_OnCoordButton(
                                   event, xcoord, ycoord, zcoord))
 
-        global fileLoaded
-        if fileLoaded is True:
+        gbs.AddGrowableCol(1)
+        gbs.AddGrowableCol(2)
+        gbs.AddGrowableCol(3)
+        gbs.AddGrowableCol(4)
+        self.SetSizerAndFit(gbs)
 
-            global deviceListAsObjects
-            for dev in deviceListAsObjects:
-                if self.GDSDevList[0] == dev.getDeviceID():
-                    self.stxGdsCoordLst.append(dev.getOpticalCoordinates()[0])
-                    self.styGdsCoordLst.append(dev.getOpticalCoordinates()[1])
-                    self.elecxGdsCoordLst.append(dev.getReferenceBondPad()[1])
-                    self.elecyGdsCoordLst.append(dev.getReferenceBondPad()[2])
-                    self.stxMotorCoordLst.append(self.tbxMotorCoord1)
-                    self.styMotorCoordLst.append(self.tbyMotorCoord1)
-                    self.stzMotorCoordLst.append(self.tbzMotorCoord1)
+    def on_drop_down1(self, event):
+        """Drop down menu for the first device. When a device is selected, its coordinates are added to the
+        gds coordinates list and associated motor coordinates are added to the motor coordinates list"""
+        for dev in deviceListAsObjects:
+            if self.GDSDevList[0].GetSelection() == dev.getDeviceID():
+                self.stxGdsCoordLst.append(dev.getOpticalCoordinates()[0])
+                self.styGdsCoordLst.append(dev.getOpticalCoordinates()[1])
+                self.elecxGdsCoordLst.append(dev.getReferenceBondPad()[1])
+                self.elecyGdsCoordLst.append(dev.getReferenceBondPad()[2])
+                self.stxMotorCoordLst.append(self.tbxMotorCoord1)
+                self.styMotorCoordLst.append(self.tbyMotorCoord1)
+                self.stzMotorCoordLst.append(self.tbzMotorCoord1)
 
-                if self.GDSDevList[1] == dev.getDeviceID():
-                    self.stxGdsCoordLst.append(dev.getOpticalCoordinates()[0])
-                    self.styGdsCoordLst.append(dev.getOpticalCoordinates()[1])
-                    self.elecxGdsCoordLst.append(dev.getReferenceBondPad()[1])
-                    self.elecyGdsCoordLst.append(dev.getReferenceBondPad()[2])
-                    self.stxMotorCoordLst.append(self.tbxMotorCoord2)
-                    self.styMotorCoordLst.append(self.tbyMotorCoord2)
-                    self.stzMotorCoordLst.append(self.tbzMotorCoord2)
+    def on_drop_down2(self, event):
+        """Drop down menu for the second device. When a device is selected, its coordinates are added to the
+        gds coordinates list and associated motor coordinates are added to the motor coordinates list"""
+        for dev in deviceListAsObjects:
+            if self.GDSDevList[1].GetSelection() == dev.getDeviceID():
+                self.stxGdsCoordLst.append(dev.getOpticalCoordinates()[0])
+                self.styGdsCoordLst.append(dev.getOpticalCoordinates()[1])
+                self.elecxGdsCoordLst.append(dev.getReferenceBondPad()[1])
+                self.elecyGdsCoordLst.append(dev.getReferenceBondPad()[2])
+                self.stxMotorCoordLst.append(self.tbxMotorCoord2)
+                self.styMotorCoordLst.append(self.tbyMotorCoord2)
+                self.stzMotorCoordLst.append(self.tbzMotorCoord2)
 
-                if self.GDSDevList[2] == dev.getDeviceID():
-                    self.stxGdsCoordLst.append(dev.getOpticalCoordinates()[0])
-                    self.styGdsCoordLst.append(dev.getOpticalCoordinates()[1])
-                    self.elecxGdsCoordLst.append(dev.getReferenceBondPad()[1])
-                    self.elecyGdsCoordLst.append(dev.getReferenceBondPad()[2])
-                    self.stxMotorCoordLst.append(self.tbxMotorCoord3)
-                    self.styMotorCoordLst.append(self.tbyMotorCoord3)
-                    self.stzMotorCoordLst.append(self.tbzMotorCoord3)
+    def on_drop_down3(self, event):
+        """Drop down menu for the third device. When a device is selected, its coordinates are added to the
+        gds coordinates list and associated motor coordinates are added to the motor coordinates list"""
+        for dev in deviceListAsObjects:
+            if self.GDSDevList[2].GetSelection() == dev.getDeviceID():
+                self.stxGdsCoordLst.append(dev.getOpticalCoordinates()[0])
+                self.styGdsCoordLst.append(dev.getOpticalCoordinates()[1])
+                self.elecxGdsCoordLst.append(dev.getReferenceBondPad()[1])
+                self.elecyGdsCoordLst.append(dev.getReferenceBondPad()[2])
+                self.stxMotorCoordLst.append(self.tbxMotorCoord3)
+                self.styMotorCoordLst.append(self.tbyMotorCoord3)
+                self.stzMotorCoordLst.append(self.tbzMotorCoord3)
 
-        gbs.AddGrowableCol(1)
-        gbs.AddGrowableCol(2)
-        gbs.AddGrowableCol(3)
-        gbs.AddGrowableCol(4)
-        self.SetSizerAndFit(gbs)
-
-    def on_drop_down(self, event):
-        """Populates drop down menu for device selection within the coordinate map panel"""
-        global deviceList
-        for GDSDevice in self.GDSDevList:
-            for dev in deviceList:
-                GDSDevice.Append(dev)
-
     def Event_OnCoordButton(self, event, xcoord, ycoord, zcoord):
         """ Called when the button is pressed to get the current motor coordinates, and put it into the text box. """
         motorPosition = self.autoMeasure.motor.getPosition()
@@ -205,7 +209,7 @@
         zcoord.SetValue(str(motorPosition[2]))
 
     def getMotorCoords(self):
-        """ Reads the motor coordinates from all completed text fields. """
+        """ Returns a list of motor coordinates for each entered device. """
         coordsLst = []
         for tcx, tcy, tcz in zip(self.stxMotorCoordLst, self.styMotorCoordLst, self.stzMotorCoordLst):
             xval = tcx.GetValue()
@@ -216,7 +220,8 @@
         return coordsLst
 
     def getGdsCoordsOpt(self):
-        """ Reads the GDS coordinates from all completed text fields. """
+        """ Returns a list of the GDS coordinates where the laser is to be aligned for each entered
+        device. """
         coordsLst = []
         for tcx, tcy in zip(self.stxGdsCoordLst, self.styGdsCoordLst):
             xval = tcx.GetValue()
@@ -226,7 +231,8 @@
         return coordsLst
 
     def getGdsCoordsElec(self):
-        """ Reads the GDS coordinates from all completed text fields. """
+        """ Returns a list of the GDS coordinates of the left-most bond pad for each entered
+        device.  """
         coordsLst = []
         for tcx, tcy in zip(self.elecxGdsCoordLst, self.elecyGdsCoordLst):
             xval = tcx.GetValue()
@@ -235,14 +241,48 @@
                 coordsLst.append((float(xval), float(yval)))
         return coordsLst
 
+    def PopulateDropDowns(self):
+        """Populates drop down menu for device selection within the coordinate map panel"""
+        global deviceList
+        for GDSDevice in self.GDSDevList:
+            GDSDevice.AppendItems(deviceList)
+
+
+def checkListSort(item1, item2):
+    """Used for sorting the checklist of devices on the chip"""
+    # Items are the client data associated with each entry
+    if item2 < item2:
+        return -1
+    elif item1 > item2:
+        return 1
+    else:
+        return 0
+
 
 class autoMeasurePanel(wx.Panel):
 
     def __init__(self, parent, autoMeasure):
+        """
+        Creates the panel used to automate measurement of chips. Users must upload a text file created
+        using the automated coordinate extraction from the Si-EPIC tools k-layout package. Then, three devices
+        must be used to create a transform matrix which allows automatic location of specific devices. This
+        involves selecting the device from a drop-down menu as well as aligning with the device and recording
+        the motor coordinates. Finally, a testing parameters file must either be uploaded or created in the
+        testing parameters tab after which automatic measurements can begin.
+
+        Args:
+            parent: wx Panel
+            autoMeasure: The automeasure object to be used for this panel.
+        """
         super(autoMeasurePanel, self).__init__(parent)
+        # autoMeasure object used to upload the coordinate file, calculate transform matrices and perform
+        # automated measurements
         self.autoMeasure = autoMeasure
+        # List of all the names of devices on the chip
         self.device_list = []
+        # No testing parameters have been uploaded
         self.parametersImported = False
+        # Parameters to be imported from the testing parameters tab or uploaded file
         self.dataimport = {'index': [], 'device': [], 'ELECflag': [], 'OPTICflag': [], 'setwflag': [], 'setvflag': [],
                            'Voltsel': [],
                            'Currentsel': [], 'VoltMin': [], 'VoltMax': [], 'CurrentMin': [], 'CurrentMax': [],
@@ -260,9 +300,9 @@
         self.InitUI()
 
     def InitUI(self):
+        """Sets up the layout for the autoMeasurePanel"""
 
-        global fileLoaded
-        fileLoaded = False  # list of devices is currently empty
+        # List of devices as ElectroOpticDevice objects
         global deviceListAsObjects
         deviceListAsObjects = []
 
@@ -314,17 +354,17 @@
 
         # Add devices checklist
         self.checkList = wx.ListCtrl(self, -1, style=wx.LC_REPORT)
-        self.checkList.InsertColumn(0, 'Device', width=100)
+        self.checkList.InsertColumn(0, 'Device', width=500)
         checkListBox = wx.BoxSizer(wx.HORIZONTAL)
         checkListBox.Add(self.checkList, proportion=1, flag=wx.EXPAND)
 
         # Add Optical Alignment set up
-        self.coordMapPanelOpt = coordinateMapPanel(self, self.autoMeasure, 3)
+        self.coordMapPanelOpt = coordinateMapPanel(self, self.autoMeasure)
         opticalBox = wx.BoxSizer(wx.HORIZONTAL)
         opticalBox.Add(self.coordMapPanelOpt, proportion=1, flag=wx.EXPAND)
 
         # Add Electrical Alignment set up
-        self.coordMapPanelElec = coordinateMapPanel(self, self.autoMeasure, 3)
+        self.coordMapPanelElec = coordinateMapPanel(self, self.autoMeasure)
         electricalBox = wx.BoxSizer(wx.HORIZONTAL)
         electricalBox.Add(self.coordMapPanelElec, proportion=1, flag=wx.EXPAND)
 
@@ -422,15 +462,6 @@
 
         self.SetSizer(matPlotBox)
 
-    def checkListSort(self, item1, item2):
-        # Items are the client data associated with each entry
-        if item2 < item2:
-            return -1
-        elif item1 > item2:
-            return 1
-        else:
-            return 0
-
     def createFilterFrame(self):
         """Opens up a frame to facilitate filtering of devices within the checklist."""
         try:
@@ -441,6 +472,11 @@
                                     'Error', wx.ICON_ERROR)
             dial.ShowModal()
 
+    def OnButton_Filter(self, event):
+        """Creates filter frame when filter button is pressed"""
+        self.createFilterFrame()
+        self.Refresh()
+
     def OnButton_ChooseCoordFile(self, event):
         """ Opens a file dialog to select a coordinate file. """
         fileDlg = wx.FileDialog(self, "Open", "", "",
@@ -452,7 +488,7 @@
         self.parseCoordFile(self.coordFilePath)
 
     def parseCoordFile(self, coordFilePath):
-        """Parses given coordinate files and stores all info as a list of electro-Optic Device
+        """Parses given coordinate files and stores all info as a list of electro-Optic Devices
         as well as a list of device ids and populates checklist of devices"""
         self.autoMeasure.readCoordFile(coordFilePath)
         global deviceListAsObjects
@@ -474,11 +510,57 @@
                 if dev.getDeviceID() == device:
                     index = deviceListAsObjects.index(dev)  # Stores index of device in list
                     self.checkList.SetItemData(ii, index)
-        self.checkList.SortItems(self.checkListSort)  # Make sure items in list are sorted
+        self.checkList.SortItems(checkListSort)  # Make sure items in list are sorted
         self.checkList.EnableCheckBoxes()
-        global fileLoaded
-        fileLoaded = True
-        self.Refresh()
+        self.coordMapPanelOpt.PopulateDropDowns()
+        self.coordMapPanelElec.PopulateDropDowns()
+
+    def OnButton_Save(self, event):
+        """Saves the gds devices used for alignment as well as motor positions to a csv file"""
+        A = self.autoMeasure.findCoordinateTransformOpt(self.coordMapPanelOpt.getMotorCoords(),
+                                                        self.coordMapPanelOpt.getGdsCoordsOpt())
+
+        B = self.autoMeasure.findCoordinateTransformElec(self.coordMapPanelElec.getMotorCoords(),
+                                                         self.coordMapPanelElec.getGdsCoordsElec())
+
+        # Make a folder with the current time
+        fileName = self.coordFileTb.GetValue()
+        timeStr = time.strftime("%d_%b_%Y_%H_%M_%S", time.localtime())
+        csvFileName = os.path.join(self.outputFolderTb.GetValue(), timeStr + '_{}.csv'.format(fileName))
+
+        f = open(csvFileName, 'w', newline='')
+        writer = csv.writer(f)
+        textFilePath = [self.coordFilePath]
+        writer.writerow(textFilePath)
+        optCoords = self.coordMapPanelOpt.getMotorCoords()
+        Opt = ['Optical Alignment']
+        writer.writerow(Opt)
+        Opt = ['Device', 'Motor x', 'Motor y', 'Motor z']
+        writer.writerow(Opt)
+        dev1 = [self.coordMapPanelOpt.tbGdsDevice1.GetSelection(),
+                optCoords[0][0], optCoords[0][1], optCoords[0][2]]
+        writer.writerow(dev1)
+        dev2 = [self.coordMapPanelOpt.tbGdsDevice2.GetSelection(),
+                optCoords[1][0], optCoords[1][1], optCoords[1][2]]
+        writer.writerow(dev2)
+        dev3 = [self.coordMapPanelOpt.tbGdsDevice3.GetSelection(),
+                optCoords[2][0], optCoords[2][1], optCoords[2][2]]
+        writer.writerow(dev3)
+        elecCoords = self.coordMapPanelElec.getMotorCoords()
+        Elec = ['Electrical Alignment']
+        writer.writerow(Elec)
+        elec = ['Device', 'Motor x', 'Motor y', 'Motor z']
+        writer.writerow(elec)
+        dev1 = [self.coordMapPanelElec.tbGdsDevice1.GetSelection(),
+                elecCoords[0][0], elecCoords[0][1], elecCoords[0][2]]
+        writer.writerow(dev1)
+        dev2 = [self.coordMapPanelElec.tbGdsDevice2.GetSelection(),
+                elecCoords[1][0], elecCoords[1][1], elecCoords[1][2]]
+        writer.writerow(dev2)
+        dev3 = [self.coordMapPanelElec.tbGdsDevice3.GetSelection(),
+                elecCoords[2][0], elecCoords[2][1], elecCoords[2][2]]
+        writer.writerow(dev3)
+        f.close()
 
     def OnButton_Import(self, event):
         """ Opens a file dialog to select a csv alignment file and populates all position fields"""
@@ -495,19 +577,22 @@
         next(reader)
         optDev1 = next(reader)
         optDev1 = optDev1  # [dev name, x motor coord, y motor coord, z motor coord]
-        self.coordMapPanelOpt.tbGdsDevice1.SetValue(optDev1[0])
+        self.coordMapPanelOpt.tbGdsDevice1.SetString(0, optDev1[0])
+        self.coordMapPanelOpt.tbGdsDevice1.SetSelection(0)
         self.coordMapPanelOpt.tbxMotorCoord1.SetValue(optDev1[1])
         self.coordMapPanelOpt.tbyMotorCoord1.SetValue(optDev1[2])
         self.coordMapPanelOpt.tbzMotorCoord1.SetValue(optDev1[3])
         optDev2 = next(reader)
         optDev2 = optDev2
-        self.coordMapPanelOpt.tbGdsDevice2.SetValue(optDev2[0])
+        self.coordMapPanelOpt.tbGdsDevice2.SetString(0, optDev2[0])
+        self.coordMapPanelOpt.tbGdsDevice2.SetSelection(0)
         self.coordMapPanelOpt.tbxMotorCoord2.SetValue(optDev2[1])
         self.coordMapPanelOpt.tbyMotorCoord2.SetValue(optDev2[2])
         self.coordMapPanelOpt.tbzMotorCoord2.SetValue(optDev2[3])
         optDev3 = next(reader)
         optDev3 = optDev3
-        self.coordMapPanelOpt.tbGdsDevice3.SetValue(optDev3[0])
+        self.coordMapPanelOpt.tbGdsDevice3.SetString(0, optDev3[0])
+        self.coordMapPanelOpt.tbGdsDevice3.SetSelection(0)
         self.coordMapPanelOpt.tbxMotorCoord3.SetValue(optDev3[1])
         self.coordMapPanelOpt.tbyMotorCoord3.SetValue(optDev3[2])
         self.coordMapPanelOpt.tbzMotorCoord3.SetValue(optDev3[3])
@@ -515,19 +600,22 @@
         next(reader)
         elecDev1 = next(reader)
         elecDev1 = elecDev1
-        self.coordMapPanelElec.tbGdsDevice1.SetValue(elecDev1[0])
+        self.coordMapPanelElec.tbGdsDevice1.SetString(0, elecDev1[0])
+        self.coordMapPanelElec.tbGdsDevice1.SetSelection(0)
         self.coordMapPanelElec.tbxMotorCoord1.SetValue(elecDev1[1])
         self.coordMapPanelElec.tbyMotorCoord1.SetValue(elecDev1[2])
         self.coordMapPanelElec.tbzMotorCoord1.SetValue(elecDev1[3])
         elecDev2 = next(reader)
         elecDev2 = elecDev2
-        self.coordMapPanelElec.tbGdsDevice2.SetValue(elecDev2[0])
+        self.coordMapPanelElec.tbGdsDevice2.SetString(0, elecDev2[0])
+        self.coordMapPanelElec.tbGdsDevice2.SetSelection(0)
         self.coordMapPanelElec.tbxMotorCoord2.SetValue(elecDev2[1])
         self.coordMapPanelElec.tbyMotorCoord2.SetValue(elecDev2[2])
         self.coordMapPanelElec.tbzMotorCoord2.SetValue(elecDev2[3])
         elecDev3 = next(reader)
         elecDev3 = elecDev3
-        self.coordMapPanelElec.tbGdsDevice3.SetValue(elecDev3[0])
+        self.coordMapPanelElec.tbGdsDevice3.SetString(0, elecDev3[0])
+        self.coordMapPanelElec.tbGdsDevice3.SetSelection(0)
         self.coordMapPanelElec.tbxMotorCoord3.SetValue(elecDev3[1])
         self.coordMapPanelElec.tbyMotorCoord3.SetValue(elecDev3[2])
         self.coordMapPanelElec.tbzMotorCoord3.SetValue(elecDev3[3])
@@ -621,18 +709,16 @@
             print(keys)
             print(values)
 
-        # self.checkList.DeleteAllItems()
-        # devicelist = []
-        # for c in range(len(self.dataimport['Device'])):
-        #   devicelist.append(self.dataimport['Device'][c])
-
-        # print(devicelist)
-
     def OnButton_CheckAll(self, event):
         """Selects all items in the devices check list"""
         for ii in range(self.checkList.GetItemCount()):
             self.checkList.CheckItem(ii, True)
 
+    def OnButton_UncheckAll(self, event):
+        """Deselects all items in the devices checklist"""
+        for ii in range(self.checkList.GetItemCount()):
+            self.checkList.CheckItem(ii, False)
+
     # TODO: Modify to move probe out of the way and keep track of chip stage movement
     def OnButton_GotoDeviceOpt(self, event):
         """Moves laser to selected device"""
@@ -655,37 +741,34 @@
                 motorCoord = self.autoMeasure.gdsToMotorCoordsElec(gdsCoord)
                 self.autoMeasure.motorElec.moveAbsoluteXYZ(motorCoord[0], motorCoord[1], motorCoord[2])
 
-    def OnButton_UncheckAll(self, event):
-        """Deselects all items in the devices checklist"""
-        for ii in range(self.checkList.GetItemCount()):
-            self.checkList.CheckItem(ii, False)
-
-    def OnButton_SelectOutputFolder(self, event):
-        """ Opens a file dialog to select an output directory for automatic measurement. """
-        dirDlg = wx.DirDialog(self, "Open", "", wx.DD_DEFAULT_STYLE)
-        dirDlg.ShowModal()
-        self.outputFolderTb.SetValue(dirDlg.GetPath())
-        dirDlg.Destroy()
-
     def OnButton_CalculateOpt(self, event):
-        """ Computes the optical coordinate transformation matrix. """
+        """ Computes the optical coordinate transformation matrix. Used to align the laser with the stage.
+        Used for debugging."""
         A = self.autoMeasure.findCoordinateTransformOpt(self.coordMapPanelOpt.getMotorCoords(),
                                                         self.coordMapPanelOpt.getGdsCoordsOpt())
         print('Coordinate transform matrix')
         print(A)
 
     def OnButton_CalculateElec(self, event):
-        """ Computes the electrical coordinate transformation matrix. """
+        """ Computes the electrical coordinate transformation matrix. Used to align the wedge probe with the
+        stage. Used for debugging."""
         A = self.autoMeasure.findCoordinateTransformElec(self.coordMapPanelElec.getMotorCoords(),
                                                          self.coordMapPanelElec.getGdsCoordsElec())
         print('Coordinate transform matrix')
         print(A)
 
+    def OnButton_SelectOutputFolder(self, event):
+        """ Opens a file dialog to select an output directory for automatic measurement results. """
+        dirDlg = wx.DirDialog(self, "Open", "", wx.DD_DEFAULT_STYLE)
+        dirDlg.ShowModal()
+        self.outputFolderTb.SetValue(dirDlg.GetPath())
+        dirDlg.Destroy()
+
     def OnButton_Start(self, event):
-        """ Starts an automatic measurement. """
+        """ Starts an automatic measurement routine. """
 
+        # Reads parameters from testingParameters tab if no testing parameters file has been uploaded
         if self.parametersImported is False:
-
             path = os.path.realpath(__file__)
             originalFile = os.path.join(path, 'pyOptomip', 'TestingParameters.csv')
             self.readCSV(originalFile)
@@ -699,14 +782,15 @@
         if not os.path.exists(self.autoMeasure.saveFolder):
             os.makedirs(self.autoMeasure.saveFolder)
 
+        # Create list of all devices which are selected for measurement from the checklist
         checkedDevices = []
         for device in self.device_list:
             if self.checkList.IsItemChecked(device.getDeviceID):
                 checkedDevices.append(device)
 
+        # Start measurement using the autoMeasure device
         self.autoMeasure.beginMeasure(checkedDevices, self.dataimport, self.checkList)
 
-
         # Copy settings from laser panel
         self.autoMeasure.laser.ctrlPanel.laserPanel.laserPanel.copySweepSettings()
         # Create a measurement progress dialog.
@@ -716,54 +800,3 @@
         # Enable detector auto measurement
         self.autoMeasure.laser.ctrlPanel.laserPanel.laserPanel.startDetTimer()
 
-    def OnButton_Filter(self, event):
-        """Creates filter frame when filter button is pressed"""
-        self.createFilterFrame()
-        self.Refresh()
-
-    def OnButton_Save(self, event):
-        """Saves the gds devices used for alignment as well as motor positions"""
-        A = self.autoMeasure.findCoordinateTransformOpt(self.coordMapPanelOpt.getMotorCoords(),
-                                                        self.coordMapPanelOpt.getGdsCoordsOpt())
-
-        B = self.autoMeasure.findCoordinateTransformElec(self.coordMapPanelElec.getMotorCoords(),
-                                                         self.coordMapPanelElec.getGdsCoordsElec())
-
-        # Make a folder with the current time
-        fileName = self.coordFileTb.GetValue()
-        timeStr = time.strftime("%d_%b_%Y_%H_%M_%S", time.localtime())
-        csvFileName = os.path.join(self.outputFolderTb.GetValue(), timeStr + '_{}.csv'.format(fileName))
-
-        f = open(csvFileName, 'w', newline='')
-        writer = csv.writer(f)
-        textFilePath = [self.coordFilePath]
-        writer.writerow(textFilePath)
-        optCoords = self.coordMapPanelOpt.getMotorCoords()
-        Opt = ['Optical Alignment']
-        writer.writerow(Opt)
-        Opt = ['Device', 'Motor x', 'Motor y', 'Motor z']
-        writer.writerow(Opt)
-        dev1 = [self.coordMapPanelOpt.tbGdsDevice1.GetValue(),
-                optCoords[0][0], optCoords[0][1], optCoords[0][2]]
-        writer.writerow(dev1)
-        dev2 = [self.coordMapPanelOpt.tbGdsDevice2.GetValue(),
-                optCoords[1][0], optCoords[1][1], optCoords[1][2]]
-        writer.writerow(dev2)
-        dev3 = [self.coordMapPanelOpt.tbGdsDevice3.GetValue(),
-                optCoords[2][0], optCoords[2][1], optCoords[2][2]]
-        writer.writerow(dev3)
-        elecCoords = self.coordMapPanelElec.getMotorCoords()
-        Elec = ['Electrical Alignment']
-        writer.writerow(Elec)
-        elec = ['Device', 'Motor x', 'Motor y', 'Motor z']
-        writer.writerow(elec)
-        dev1 = [self.coordMapPanelElec.tbGdsDevice1.GetValue(),
-                elecCoords[0][0], elecCoords[0][1], elecCoords[0][2]]
-        writer.writerow(dev1)
-        dev2 = [self.coordMapPanelElec.tbGdsDevice2.GetValue(),
-                elecCoords[1][0], elecCoords[1][1], elecCoords[1][2]]
-        writer.writerow(dev2)
-        dev3 = [self.coordMapPanelElec.tbGdsDevice3.GetValue(),
-                elecCoords[2][0], elecCoords[2][1], elecCoords[2][2]]
-        writer.writerow(dev3)
-        f.close()
